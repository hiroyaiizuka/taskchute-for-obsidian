/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TaskChutePlusPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian13 = require("obsidian");

// src/managers/PathManager.ts
var import_obsidian = require("obsidian");
var _PathManager = class _PathManager {
  constructor(plugin) {
    this.plugin = plugin;
  }
  getTaskFolderPath() {
    const path = this.plugin.settings.taskFolderPath || _PathManager.DEFAULT_PATHS.taskFolder;
    return (0, import_obsidian.normalizePath)(path);
  }
  getProjectFolderPath() {
    const path = this.plugin.settings.projectFolderPath || _PathManager.DEFAULT_PATHS.projectFolder;
    return (0, import_obsidian.normalizePath)(path);
  }
  getLogDataPath() {
    const path = this.plugin.settings.logDataPath || _PathManager.DEFAULT_PATHS.logData;
    return (0, import_obsidian.normalizePath)(path);
  }
  getReviewDataPath() {
    const path = this.plugin.settings.reviewDataPath || _PathManager.DEFAULT_PATHS.reviewData;
    return (0, import_obsidian.normalizePath)(path);
  }
  getLogYearPath(year) {
    const logPath = this.getLogDataPath();
    return (0, import_obsidian.normalizePath)(`${logPath}/${year}`);
  }
  async ensureYearFolder(year) {
    const yearPath = this.getLogYearPath(year);
    await this.ensureFolderExists(yearPath);
    return yearPath;
  }
  validatePath(path) {
    if (path.startsWith("/") || path.match(/^[A-Za-z]:\\/)) {
      return { valid: false, error: "\u7D76\u5BFE\u30D1\u30B9\u306F\u4F7F\u7528\u3067\u304D\u307E\u305B\u3093" };
    }
    if (path.includes("..")) {
      return { valid: false, error: "\u30D1\u30B9\u306B'..'\u3092\u542B\u3081\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093" };
    }
    if (path.match(/[<>"|?*]/)) {
      return { valid: false, error: "\u30D1\u30B9\u306B\u7279\u6B8A\u6587\u5B57\u3092\u542B\u3081\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093" };
    }
    return { valid: true };
  }
  async ensureFolderExists(path) {
    const folder = this.plugin.app.vault.getAbstractFileByPath(path);
    if (!folder) {
      try {
        await this.plugin.app.vault.createFolder(path);
      } catch (error) {
        if (error.message && error.message.includes("Folder already exists")) {
          return;
        }
        throw error;
      }
    }
  }
};
_PathManager.DEFAULT_PATHS = {
  taskFolder: "TaskChute/Task",
  projectFolder: "TaskChute/Project",
  logData: "TaskChute/Log",
  reviewData: "TaskChute/Review"
};
var PathManager = _PathManager;

// src/settings.ts
var DEFAULT_SETTINGS = {
  taskFolderPath: PathManager.DEFAULT_PATHS.taskFolder,
  projectFolderPath: PathManager.DEFAULT_PATHS.projectFolder,
  logDataPath: PathManager.DEFAULT_PATHS.logData,
  reviewDataPath: PathManager.DEFAULT_PATHS.reviewData,
  enableSound: false,
  enableFireworks: false,
  enableConfetti: false,
  useOrderBasedSort: true,
  slotKeys: {}
};

// src/managers/RoutineAliasManager.ts
var import_obsidian2 = require("obsidian");
var RoutineAliasManager = class {
  constructor(plugin) {
    this.aliasCache = null;
    this.plugin = plugin;
  }
  getAliasFilePath() {
    const taskFolderPath = this.plugin.pathManager.getTaskFolderPath();
    return (0, import_obsidian2.normalizePath)(`${taskFolderPath}/routine-aliases.json`);
  }
  async loadAliases() {
    if (this.aliasCache) return this.aliasCache;
    const path = this.getAliasFilePath();
    try {
      const file = this.plugin.app.vault.getAbstractFileByPath(path);
      if (file instanceof import_obsidian2.TFile) {
        const content = await this.plugin.app.vault.read(file);
        this.aliasCache = JSON.parse(content);
      } else {
        this.aliasCache = {};
      }
    } catch (error) {
      if (this.plugin._notify) {
        this.plugin._notify("\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306E\u540D\u524D\u5909\u66F4\u5C65\u6B74\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
      } else {
        new import_obsidian2.Notice("\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306E\u540D\u524D\u5909\u66F4\u5C65\u6B74\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
      }
      this.aliasCache = {};
    }
    return this.aliasCache;
  }
  async saveAliases(aliases) {
    try {
      const path = this.getAliasFilePath();
      const file = this.plugin.app.vault.getAbstractFileByPath(path);
      const content = JSON.stringify(aliases, null, 2);
      if (file instanceof import_obsidian2.TFile) {
        await this.plugin.app.vault.modify(file, content);
      } else {
        await this.plugin.app.vault.create(path, content);
      }
      this.aliasCache = aliases;
    } catch (error) {
      if (this.plugin._notify) {
        this.plugin._notify("\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306E\u540D\u524D\u5909\u66F4\u5C65\u6B74\u306E\u4FDD\u5B58\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
      } else {
        new import_obsidian2.Notice("\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306E\u540D\u524D\u5909\u66F4\u5C65\u6B74\u306E\u4FDD\u5B58\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
      }
    }
  }
  async addAlias(newName, oldName) {
    const aliases = await this.loadAliases();
    if (!aliases[newName]) {
      aliases[newName] = [];
    }
    if (aliases[oldName]) {
      aliases[newName] = [...aliases[oldName], oldName];
      delete aliases[oldName];
    } else {
      aliases[newName].push(oldName);
    }
    aliases[newName] = [...new Set(aliases[newName])];
    await this.saveAliases(aliases);
  }
  getAliases(taskName) {
    var _a;
    return ((_a = this.aliasCache) == null ? void 0 : _a[taskName]) || [];
  }
  getAllPossibleNames(taskName) {
    const names = /* @__PURE__ */ new Set([taskName]);
    const directAliases = this.getAliases(taskName);
    directAliases.forEach((alias) => names.add(alias));
    const currentName = this.findCurrentName(taskName);
    if (currentName) {
      names.add(currentName);
      const currentAliases = this.getAliases(currentName);
      currentAliases.forEach((alias) => names.add(alias));
    }
    return Array.from(names);
  }
  findCurrentName(oldName, visited = /* @__PURE__ */ new Set()) {
    if (!this.aliasCache) return null;
    if (visited.has(oldName)) return null;
    visited.add(oldName);
    for (const [current, aliases] of Object.entries(this.aliasCache)) {
      if (aliases.includes(oldName)) {
        return current;
      }
    }
    return null;
  }
};

// src/views/TaskChuteView.ts
var import_obsidian11 = require("obsidian");

// src/utils/time.ts
function calculateNextBoundary(now, boundaries) {
  const currentHour = now.getHours();
  const currentMinute = now.getMinutes();
  for (const boundary of boundaries) {
    if (boundary.hour > currentHour || boundary.hour === currentHour && boundary.minute > currentMinute) {
      const next = new Date(now);
      next.setHours(boundary.hour, boundary.minute, 0, 0);
      return next;
    }
  }
  const tomorrow = new Date(now);
  tomorrow.setDate(tomorrow.getDate() + 1);
  tomorrow.setHours(boundaries[0].hour, boundaries[0].minute, 0, 0);
  return tomorrow;
}
function getCurrentTimeSlot(date = /* @__PURE__ */ new Date()) {
  const hour = date.getHours();
  const minute = date.getMinutes();
  const timeInMinutes = hour * 60 + minute;
  if (timeInMinutes >= 0 && timeInMinutes < 8 * 60) return "0:00-8:00";
  if (timeInMinutes >= 8 * 60 && timeInMinutes < 12 * 60) return "8:00-12:00";
  if (timeInMinutes >= 12 * 60 && timeInMinutes < 16 * 60) return "12:00-16:00";
  return "16:00-0:00";
}
function getSlotFromTime(timeStr) {
  const [hour, minute] = String(timeStr).split(":").map(Number);
  const timeInMinutes = hour * 60 + minute;
  if (timeInMinutes >= 0 && timeInMinutes < 8 * 60) return "0:00-8:00";
  if (timeInMinutes >= 8 * 60 && timeInMinutes < 12 * 60) return "8:00-12:00";
  if (timeInMinutes >= 12 * 60 && timeInMinutes < 16 * 60) return "12:00-16:00";
  return "16:00-0:00";
}

// src/views/LogView.ts
var import_obsidian4 = require("obsidian");

// src/services/HeatmapService.ts
var import_obsidian3 = require("obsidian");
var HeatmapService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async loadYearlyData(year) {
    const yearPath = this.plugin.pathManager.getLogYearPath(year);
    const heatmapPath = (0, import_obsidian3.normalizePath)(`${yearPath}/yearly-heatmap.json`);
    const file = this.plugin.app.vault.getAbstractFileByPath(heatmapPath);
    if (file && file instanceof import_obsidian3.TFile) {
      try {
        const content = await this.plugin.app.vault.read(file);
        const data = JSON.parse(content);
        if (!data || typeof data !== "object" || !data.year || !data.days) {
          throw new Error("Invalid yearly heatmap data");
        }
        return data;
      } catch (_) {
      }
    }
    return await this.generateYearlyData(year);
  }
  async generateYearlyData(year) {
    const yearlyData = {
      year,
      days: {},
      metadata: {
        version: "1.0",
        lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
      }
    };
    try {
      for (let month = 1; month <= 12; month++) {
        const monthString = `${year}-${String(month).padStart(2, "0")}`;
        const logDataPath = this.plugin.pathManager.getLogDataPath();
        const logFilePath = (0, import_obsidian3.normalizePath)(`${logDataPath}/${monthString}-tasks.json`);
        const file2 = this.plugin.app.vault.getAbstractFileByPath(logFilePath);
        if (!file2 || !(file2 instanceof import_obsidian3.TFile)) continue;
        const content2 = await this.plugin.app.vault.read(file2);
        const monthlyLog = JSON.parse(content2);
        if (!monthlyLog || typeof monthlyLog !== "object") continue;
        if (monthlyLog.dailySummary && typeof monthlyLog.dailySummary === "object") {
          for (const [dateString, summary] of Object.entries(monthlyLog.dailySummary)) {
            if (!/^\d{4}-\d{2}-\d{2}$/.test(dateString)) continue;
            if (!dateString.startsWith(`${year}-`)) continue;
            const totalTasks = Number(summary.totalTasks) || 0;
            const completedTasks = Number(summary.completedTasks) || 0;
            const stats = {
              totalTasks,
              completedTasks,
              procrastinatedTasks: Math.max(0, totalTasks - completedTasks),
              completionRate: totalTasks > 0 ? completedTasks / totalTasks : 0
            };
            yearlyData.days[dateString] = stats;
          }
        } else if (monthlyLog.taskExecutions && typeof monthlyLog.taskExecutions === "object") {
          for (const [dateString, dayTasks] of Object.entries(monthlyLog.taskExecutions)) {
            if (!/^\d{4}-\d{2}-\d{2}$/.test(dateString)) continue;
            if (!dateString.startsWith(`${year}-`)) continue;
            if (!Array.isArray(dayTasks)) continue;
            const stats = this.calculateDailyStats(dayTasks);
            yearlyData.days[dateString] = stats;
          }
        }
      }
      const yearPath = await this.plugin.pathManager.ensureYearFolder(String(year));
      const heatmapPath = (0, import_obsidian3.normalizePath)(`${yearPath}/yearly-heatmap.json`);
      const file = this.plugin.app.vault.getAbstractFileByPath(heatmapPath);
      const content = JSON.stringify(yearlyData, null, 2);
      if (file && file instanceof import_obsidian3.TFile) {
        await this.plugin.app.vault.modify(file, content);
      } else {
        await this.plugin.app.vault.create(heatmapPath, content);
      }
    } catch (_) {
    }
    return yearlyData;
  }
  calculateDailyStats(dayTasks) {
    const map = /* @__PURE__ */ new Map();
    for (const task of dayTasks) {
      if (!task || typeof task !== "object") continue;
      const name = task.taskName;
      if (!name || typeof name !== "string") continue;
      const isCompleted = !!task.isCompleted;
      if (!map.has(name)) map.set(name, false);
      if (isCompleted) map.set(name, true);
    }
    const totalTasks = map.size;
    const completedTasks = Array.from(map.values()).filter(Boolean).length;
    return {
      totalTasks,
      completedTasks,
      procrastinatedTasks: Math.max(0, totalTasks - completedTasks),
      completionRate: totalTasks > 0 ? completedTasks / totalTasks : 0
    };
  }
  async updateDailyStats(dateString) {
    var _a;
    try {
      const monthly = await this.loadMonthlyData(dateString);
      const dayTasks = ((_a = monthly.taskExecutions) == null ? void 0 : _a[dateString]) || [];
      const stats = this.calculateDailyStats(dayTasks);
      await this.updateYearlyData(dateString, stats);
      return stats;
    } catch (_) {
      return null;
    }
  }
  async loadMonthlyData(dateString) {
    try {
      const [year, month] = dateString.split("-");
      const monthString = `${year}-${month}`;
      const logDataPath = this.plugin.pathManager.getLogDataPath();
      const logFilePath = (0, import_obsidian3.normalizePath)(`${logDataPath}/${monthString}-tasks.json`);
      const file = this.plugin.app.vault.getAbstractFileByPath(logFilePath);
      if (!file || !(file instanceof import_obsidian3.TFile)) return { taskExecutions: {} };
      const content = await this.plugin.app.vault.read(file);
      return JSON.parse(content);
    } catch (_) {
      return { taskExecutions: {} };
    }
  }
  async updateYearlyData(dateString, stats) {
    try {
      const [year] = dateString.split("-");
      const yearPath = await this.plugin.pathManager.ensureYearFolder(year);
      const heatmapPath = (0, import_obsidian3.normalizePath)(`${yearPath}/yearly-heatmap.json`);
      const file = this.plugin.app.vault.getAbstractFileByPath(heatmapPath);
      let yearly;
      if (file && file instanceof import_obsidian3.TFile) {
        const content = await this.plugin.app.vault.read(file);
        yearly = JSON.parse(content);
      } else {
        yearly = { year: parseInt(year, 10), days: {}, metadata: { version: "1.0" } };
      }
      yearly.days[dateString] = stats;
      if (!yearly.metadata) yearly.metadata = { version: "1.0" };
      yearly.metadata.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
      const out = JSON.stringify(yearly, null, 2);
      if (file && file instanceof import_obsidian3.TFile) {
        await this.plugin.app.vault.modify(file, out);
      } else {
        await this.plugin.app.vault.create(heatmapPath, out);
      }
    } catch (_) {
    }
  }
};

// src/views/LogView.ts
var LogView = class {
  constructor(plugin, container) {
    this.heatmapData = null;
    this.dataCache = {};
    this.plugin = plugin;
    this.container = container;
    this.currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    this.heatmapService = new HeatmapService(plugin);
  }
  async render() {
    this.container.empty();
    this.createHeader();
    const loadingContainer = this.container.createEl("div", {
      cls: "heatmap-loading",
      text: "\u30C7\u30FC\u30BF\u3092\u8AAD\u307F\u8FBC\u307F\u4E2D..."
    });
    try {
      if (this.currentYear === (/* @__PURE__ */ new Date()).getFullYear()) {
        delete this.dataCache[this.currentYear];
        try {
          const yearPath = this.plugin.pathManager.getLogYearPath(this.currentYear);
          const heatmapFile = this.plugin.app.vault.getAbstractFileByPath(`${yearPath}/yearly-heatmap.json`);
          if (heatmapFile && heatmapFile instanceof import_obsidian4.TFile) {
            await this.plugin.app.vault.delete(heatmapFile);
          }
        } catch (_) {
        }
      }
      this.heatmapData = await this.loadYearlyData(this.currentYear);
      loadingContainer.remove();
      this.renderHeatmap();
    } catch (error) {
      loadingContainer.remove();
      new import_obsidian4.Notice(`${this.currentYear}\u5E74\u306E\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F`);
      this.renderEmptyHeatmap(this.currentYear);
    }
  }
  createHeader() {
    const header = this.container.createEl("div", { cls: "taskchute-log-header" });
    header.createEl("h2", { text: "\u30BF\u30B9\u30AF\u5B9F\u884C\u30ED\u30B0", cls: "log-title" });
    const controls = header.createEl("div", { cls: "log-controls" });
    const yearSelector = controls.createEl("select", { cls: "year-selector" });
    const current = (/* @__PURE__ */ new Date()).getFullYear();
    for (let y = current + 1; y >= 2020; y--) {
      const opt = yearSelector.createEl("option", { value: String(y), text: `${y}\u5E74` });
      if (y === this.currentYear) opt.selected = true;
    }
    const refreshButton = controls.createEl("button", {
      cls: "refresh-button",
      text: "\u{1F504} \u30C7\u30FC\u30BF\u66F4\u65B0",
      attr: { title: "\u30AD\u30E3\u30C3\u30B7\u30E5\u3092\u30AF\u30EA\u30A2\u3057\u3066\u518D\u8A08\u7B97" }
    });
    refreshButton.addEventListener("click", async () => {
      delete this.dataCache[this.currentYear];
      try {
        const yearPath = this.plugin.pathManager.getLogYearPath(this.currentYear);
        const heatmapFile = this.plugin.app.vault.getAbstractFileByPath(`${yearPath}/yearly-heatmap.json`);
        if (heatmapFile && heatmapFile instanceof import_obsidian4.TFile) {
          await this.plugin.app.vault.delete(heatmapFile);
        }
      } catch (_) {
      }
      const container = this.container.querySelector(".heatmap-container");
      if (container) container.remove();
      const loading = this.container.createEl("div", { cls: "heatmap-loading", text: "\u30C7\u30FC\u30BF\u3092\u518D\u8A08\u7B97\u4E2D..." });
      try {
        this.heatmapData = await this.loadYearlyData(this.currentYear);
        loading.remove();
        this.renderHeatmap();
        new import_obsidian4.Notice(`${this.currentYear}\u5E74\u306E\u30C7\u30FC\u30BF\u3092\u66F4\u65B0\u3057\u307E\u3057\u305F`);
      } catch (e) {
        loading.remove();
        new import_obsidian4.Notice(`${this.currentYear}\u5E74\u306E\u30C7\u30FC\u30BF\u66F4\u65B0\u306B\u5931\u6557\u3057\u307E\u3057\u305F`);
        this.renderEmptyHeatmap(this.currentYear);
      }
    });
    yearSelector.addEventListener("change", async (e) => {
      this.currentYear = parseInt(e.target.value, 10);
      const container = this.container.querySelector(".heatmap-container");
      if (container) container.remove();
      const loading = this.container.createEl("div", { cls: "heatmap-loading", text: "\u30C7\u30FC\u30BF\u3092\u8AAD\u307F\u8FBC\u307F\u4E2D..." });
      try {
        this.heatmapData = await this.loadYearlyData(this.currentYear);
        loading.remove();
        this.renderHeatmap();
      } catch (err) {
        loading.remove();
        new import_obsidian4.Notice(`${this.currentYear}\u5E74\u306E\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F`);
        this.renderEmptyHeatmap(this.currentYear);
      }
    });
  }
  async loadYearlyData(year) {
    if (this.dataCache[year]) return this.dataCache[year];
    await this.plugin.pathManager.ensureYearFolder(year);
    const data = await this.heatmapService.loadYearlyData(year);
    this.dataCache[year] = data;
    return data;
  }
  renderHeatmap() {
    if (!this.heatmapData) return;
    const existed = this.container.querySelector(".heatmap-container");
    if (existed) existed.remove();
    const heatmapContainer = this.container.createEl("div", { cls: "heatmap-container" });
    const grid = this.createHeatmapGrid(this.heatmapData.year);
    heatmapContainer.appendChild(grid);
    this.applyDataToGrid(this.heatmapData);
  }
  renderEmptyHeatmap(year) {
    const existed = this.container.querySelector(".heatmap-container");
    if (existed) existed.remove();
    const heatmapContainer = this.container.createEl("div", { cls: "heatmap-container" });
    heatmapContainer.createEl("div", { cls: "heatmap-error", text: `${year}\u5E74\u306E\u30C7\u30FC\u30BF\u306F\u5229\u7528\u3067\u304D\u307E\u305B\u3093` });
    const grid = this.createHeatmapGrid(year);
    heatmapContainer.appendChild(grid);
    const cells = grid.querySelectorAll(".heatmap-cell");
    cells.forEach((cell) => {
      ;
      cell.dataset.level = "0";
      cell.dataset.tooltip = "\u30C7\u30FC\u30BF\u306A\u3057";
    });
  }
  applyDataToGrid(data) {
    if (!data.days) return;
    const entries = Object.entries(data.days);
    const batchSize = 50;
    let currentIndex = 0;
    const processBatch = () => {
      const endIndex = Math.min(currentIndex + batchSize, entries.length);
      for (let i = currentIndex; i < endIndex; i++) {
        const [dateString, stats] = entries[i];
        const cell = this.container.querySelector(`[data-date="${dateString}"]`);
        if (cell) {
          const level = this.calculateLevel(stats);
          cell.dataset.level = String(level);
          cell.dataset.tooltip = this.createTooltipText(dateString, stats);
        }
      }
      currentIndex = endIndex;
      if (currentIndex < entries.length) requestAnimationFrame(processBatch);
    };
    requestAnimationFrame(processBatch);
  }
  calculateLevel(stats) {
    if (!stats || stats.totalTasks === 0) return 0;
    if (stats.procrastinatedTasks === 0) return 4;
    const rate = stats.completionRate;
    if (rate >= 0.8) return 3;
    if (rate >= 0.5) return 2;
    if (rate >= 0.2) return 1;
    return 1;
  }
  createTooltipText(dateString, stats) {
    const date = /* @__PURE__ */ new Date(dateString + "T00:00:00");
    const dateText = date.toLocaleDateString("ja-JP", { year: "numeric", month: "long", day: "numeric", weekday: "long" });
    if (!stats || stats.totalTasks === 0) return `${dateText}
\u30BF\u30B9\u30AF\u306A\u3057`;
    return `${dateText}
\u7DCF\u30BF\u30B9\u30AF: ${stats.totalTasks}
\u5B8C\u4E86: ${stats.completedTasks}
\u5148\u9001\u308A: ${stats.procrastinatedTasks}
\u5B8C\u4E86\u7387: ${Math.round(stats.completionRate * 100)}%`;
  }
  addCellEventListeners(cell, dateString) {
    cell.addEventListener("mouseenter", () => this.showTooltip(cell));
    cell.addEventListener("mouseleave", () => this.hideTooltip());
    cell.addEventListener("click", async (e) => {
      e.stopPropagation();
      await this.navigateToDate(dateString);
    });
  }
  showTooltip(cell) {
    this.hideTooltip();
    const tooltipText = cell.dataset.tooltip;
    if (!tooltipText) return;
    const tooltip = document.createElement("div");
    tooltip.className = "heatmap-tooltip";
    tooltip.textContent = tooltipText;
    const rect = cell.getBoundingClientRect();
    const containerRect = this.container.getBoundingClientRect();
    tooltip.style.position = "absolute";
    tooltip.style.left = `${rect.left - containerRect.left}px`;
    tooltip.style.top = `${rect.bottom - containerRect.top + 5}px`;
    tooltip.style.zIndex = "1000";
    this.container.appendChild(tooltip);
    this.currentTooltip = tooltip;
  }
  hideTooltip() {
    const current = this.currentTooltip;
    if (current) {
      current.remove();
      this.currentTooltip = null;
    }
  }
  async navigateToDate(dateString) {
    try {
      const [year, month, day] = dateString.split("-").map(Number);
      const leaves = this.plugin.app.workspace.getLeavesOfType("taskchute-view");
      let leaf;
      if (leaves.length === 0) {
        leaf = this.plugin.app.workspace.getRightLeaf(false);
        await leaf.setViewState({ type: "taskchute-view", active: true });
        await new Promise((r) => setTimeout(r, 300));
        const newLeaves = this.plugin.app.workspace.getLeavesOfType("taskchute-view");
        if (newLeaves.length > 0) leaf = newLeaves[0];
      } else {
        leaf = leaves[0];
      }
      const view = leaf.view;
      if (!view || typeof view.loadTasks !== "function") return;
      view.currentDate = new Date(year, month - 1, day);
      if (view.updateDateLabel && view.containerEl) {
        const dateLabel = view.containerEl.querySelector(".date-nav-label");
        if (dateLabel) view.updateDateLabel(dateLabel);
      }
      await view.loadTasks();
      this.plugin.app.workspace.setActiveLeaf(leaf);
      const modal = this.container.closest(".taskchute-log-modal-overlay");
      if (modal) modal.remove();
    } catch (_) {
    }
  }
  createHeatmapGrid(year) {
    const gridContainer = document.createElement("div");
    gridContainer.className = "heatmap-grid-container";
    const monthLabels = gridContainer.createEl("div", { cls: "heatmap-months" });
    const weekdayContainer = gridContainer.createEl("div", { cls: "heatmap-weekdays-container" });
    const weekdayLabels = weekdayContainer.createEl("div", { cls: "heatmap-weekdays" });
    const weekdays = ["\u65E5", "\u6708", "\u706B", "\u6C34", "\u6728", "\u91D1", "\u571F"];
    weekdays.forEach((day, idx) => {
      const label = weekdayLabels.createEl("span", { cls: "weekday-label" });
      if (idx === 1 || idx === 3 || idx === 5) label.textContent = day;
    });
    const grid = weekdayContainer.createEl("div", { cls: "heatmap-grid" });
    grid.style.gridTemplateColumns = `repeat(53, 11px)`;
    const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const firstDay = new Date(year, 0, 1);
    const firstSunday = new Date(firstDay);
    firstSunday.setDate(firstSunday.getDate() - firstDay.getDay());
    const currentDate = new Date(firstSunday);
    let weekIndex = 0;
    let lastMonthSeen = -1;
    for (let i = 0; i < 371; i++) {
      const dateStr = this.formatDate(currentDate);
      const isCurrentYear = currentDate.getFullYear() === year;
      const cell = grid.createEl("div", {
        cls: isCurrentYear ? "heatmap-cell" : "heatmap-cell empty",
        attr: { "data-date": dateStr, "data-level": "0" }
      });
      if (isCurrentYear) {
        this.addCellEventListeners(cell, dateStr);
        const cm = currentDate.getMonth();
        if (cm !== lastMonthSeen) {
          const label = monthLabels.createEl("span", { cls: "month-label", text: months[cm] });
          label.style.left = `${weekIndex * 13}px`;
          lastMonthSeen = cm;
        }
      }
      currentDate.setDate(currentDate.getDate() + 1);
      if (i > 0 && (i + 1) % 7 === 0) weekIndex++;
    }
    const legend = gridContainer.createEl("div", { cls: "heatmap-legend" });
    legend.createEl("span", { cls: "legend-label", text: "Less" });
    const legendScale = legend.createEl("div", { cls: "legend-scale" });
    for (let i = 0; i <= 4; i++) legendScale.createEl("div", { cls: "legend-cell", attr: { "data-level": String(i) } });
    legend.createEl("span", { cls: "legend-label", text: "More" });
    return gridContainer;
  }
  formatDate(d) {
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
  }
};

// src/services/ReviewService.ts
var import_obsidian5 = require("obsidian");

// src/utils/reviewTemplate.ts
function buildDefaultReviewTemplate(logDataPath) {
  const LOG_LINE = `const LOG_DATA_PATH = ${JSON.stringify(logDataPath)}`;
  const lines = [];
  lines.push("---");
  lines.push("satisfaction: ");
  lines.push("---");
  lines.push("");
  lines.push("### \u96C6\u4E2D\u30FB\u5143\u6C17\u5EA6\u306E\u63A8\u79FB");
  lines.push("```dataviewjs");
  lines.push("// \u30D7\u30E9\u30B0\u30A4\u30F3\u8A2D\u5B9A\u304B\u3089\u53D7\u3051\u53D6\u3063\u305F\u30ED\u30B0\u30C7\u30FC\u30BF\u30D1\u30B9\uFF08\u30D3\u30EB\u30C9\u6642\u306B\u57CB\u3081\u8FBC\u307F\uFF09");
  lines.push(LOG_LINE);
  lines.push("");
  lines.push("// \u30D5\u30A1\u30A4\u30EB\u540D\u304B\u3089\u65E5\u4ED8\u3092\u53D6\u5F97");
  lines.push('// \u30D5\u30A1\u30A4\u30EB\u540D: "Daily - YYYY-MM-DD"');
  lines.push("const fileName = dv.current().file.name");
  lines.push("");
  lines.push("// \u30B7\u30F3\u30D7\u30EB\u306B\u65E5\u4ED8\u30D1\u30BF\u30FC\u30F3\u3060\u3051\u3092\u63A2\u3059");
  lines.push("const dateMatch = fileName.match(/\\d{4}-\\d{2}-\\d{2}/)");
  lines.push("");
  lines.push("if (!dateMatch) {");
  lines.push("  dv.paragraph('\u274C \u30D5\u30A1\u30A4\u30EB\u540D\u304B\u3089\u65E5\u4ED8\u3092\u53D6\u5F97\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002\u30D5\u30A1\u30A4\u30EB\u540D: ' + fileName)");
  lines.push("  return");
  lines.push("}");
  lines.push("");
  lines.push("const currentDate = dateMatch[0] // YYYY-MM-DD");
  lines.push("const [year, month] = currentDate.split('-')");
  lines.push("const monthString = year + '-' + month");
  lines.push("");
  lines.push("// \u30ED\u30B0\u30D5\u30A1\u30A4\u30EB\u30D1\u30B9");
  lines.push("const logPath = LOG_DATA_PATH + '/' + monthString + '-tasks.json'");
  lines.push("");
  lines.push("try {");
  lines.push("  const logFile = dv.app.vault.getAbstractFileByPath(logPath)");
  lines.push("  const content = logFile ? await dv.app.vault.read(logFile) : null");
  lines.push("  if (!content) throw new Error('Log file not found')");
  lines.push("");
  lines.push("  const monthlyLog = JSON.parse(content)");
  lines.push("  const dayTasks = monthlyLog.taskExecutions?.[currentDate] || []");
  lines.push("");
  lines.push("  // \u6642\u9593\u5E2F\u5225\u306B\u30C7\u30FC\u30BF\u3092\u96C6\u8A08");
  lines.push("  const hourlyData = new Array(24).fill(null).map(() => ({ focus: [], energy: [] }))");
  lines.push("");
  lines.push("  dayTasks.forEach(task => {");
  lines.push("    if (task.startTime && (task.focusLevel > 0 || task.energyLevel > 0)) {");
  lines.push('      // startTime\u306F"HH:MM:SS"\u5F62\u5F0F');
  lines.push("      const hourStr = task.startTime.split(':')[0]");
  lines.push("      const hour = parseInt(hourStr, 10)");
  lines.push("      if (hour >= 0 && hour < 24) {");
  lines.push("        if (task.focusLevel > 0) hourlyData[hour].focus.push(task.focusLevel)");
  lines.push("        if (task.energyLevel > 0) hourlyData[hour].energy.push(task.energyLevel)");
  lines.push("      }");
  lines.push("    }");
  lines.push("  })");
  lines.push("");
  lines.push("  const focusData = hourlyData.map(h => h.focus.length > 0");
  lines.push("    ? Math.round(h.focus.reduce((a,b) => a+b) / h.focus.length * 10) / 10");
  lines.push("    : null)");
  lines.push("");
  lines.push("  const energyData = hourlyData.map(h => h.energy.length > 0");
  lines.push("    ? Math.round(h.energy.reduce((a,b) => a+b) / h.energy.length * 10) / 10");
  lines.push("    : null)");
  lines.push("");
  lines.push("  // Charts\u30D7\u30E9\u30B0\u30A4\u30F3\u306A\u3069\u3067\u89E3\u91C8\u3055\u308C\u308Bchart\u30D6\u30ED\u30C3\u30AF\u3092\u751F\u6210");
  lines.push("  const chartBlock = [");
  lines.push("    '````chart',");
  lines.push("    'type: bar',");
  lines.push("    'labels: [0\u6642, 1\u6642, 2\u6642, 3\u6642, 4\u6642, 5\u6642, 6\u6642, 7\u6642, 8\u6642, 9\u6642, 10\u6642, 11\u6642, 12\u6642, 13\u6642, 14\u6642, 15\u6642, 16\u6642, 17\u6642, 18\u6642, 19\u6642, 20\u6642, 21\u6642, 22\u6642, 23\u6642]',");
  lines.push("    'series:',");
  lines.push("    '  - title: \u96C6\u4E2D\u5EA6',");
  lines.push("    '    data: [' + focusData.map(v => v !== null ? v : 0).join(', ') + ']',");
  lines.push("    '  - title: \u5143\u6C17\u5EA6',");
  lines.push("    '    data: [' + energyData.map(v => v !== null ? v : 0).join(', ') + ']',");
  lines.push("    'tension: 0',");
  lines.push("    'width: 80%',");
  lines.push("    'labelColors: false',");
  lines.push("    'fill: false',");
  lines.push("    'beginAtZero: false',");
  lines.push("    '````',");
  lines.push("  ].join('\\n');");
  lines.push("  dv.paragraph(chartBlock)");
  lines.push("} catch (e) {");
  lines.push("  dv.paragraph('\u274C \u30C7\u30FC\u30BF\u304C\u8AAD\u307F\u8FBC\u3081\u307E\u305B\u3093\u3067\u3057\u305F\u3002TaskChute\u306E\u30ED\u30B0\u30D5\u30A1\u30A4\u30EB\u304C\u5B58\u5728\u3059\u308B\u304B\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002')");
  lines.push("}");
  lines.push("");
  lines.push("```");
  lines.push("");
  lines.push("### \u30B3\u30E1\u30F3\u30C8\u4E00\u89A7");
  lines.push("");
  lines.push("```dataviewjs");
  lines.push("// \u30D7\u30E9\u30B0\u30A4\u30F3\u8A2D\u5B9A\u304B\u3089\u53D7\u3051\u53D6\u3063\u305F\u30ED\u30B0\u30C7\u30FC\u30BF\u30D1\u30B9\uFF08\u30D3\u30EB\u30C9\u6642\u306B\u57CB\u3081\u8FBC\u307F\uFF09");
  lines.push(LOG_LINE);
  lines.push("");
  lines.push("// \u30D5\u30A1\u30A4\u30EB\u540D\u304B\u3089\u65E5\u4ED8\u3092\u53D6\u5F97");
  lines.push('// \u30D5\u30A1\u30A4\u30EB\u540D: "Daily - YYYY-MM-DD"');
  lines.push("const fileName = dv.current().file.name");
  lines.push("const dateMatch = fileName.match(/\\d{4}-\\d{2}-\\d{2}/)");
  lines.push("if (!dateMatch) {");
  lines.push("  dv.paragraph('\u274C \u30D5\u30A1\u30A4\u30EB\u540D\u304B\u3089\u65E5\u4ED8\u3092\u53D6\u5F97\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002\u30D5\u30A1\u30A4\u30EB\u540D: ' + fileName)");
  lines.push("  return");
  lines.push("}");
  lines.push("");
  lines.push("const currentDate = dateMatch[0] // YYYY-MM-DD");
  lines.push("const [year, month] = currentDate.split('-')");
  lines.push("const monthString = year + '-' + month");
  lines.push("");
  lines.push("// \u30ED\u30B0\u30D5\u30A1\u30A4\u30EB\u30D1\u30B9");
  lines.push("const logPath = LOG_DATA_PATH + '/' + monthString + '-tasks.json'");
  lines.push("");
  lines.push("try {");
  lines.push("  const logFile = dv.app.vault.getAbstractFileByPath(logPath)");
  lines.push("  const content = logFile ? await dv.app.vault.read(logFile) : null");
  lines.push("  if (!content) throw new Error('Log file not found')");
  lines.push("");
  lines.push("  const monthlyLog = JSON.parse(content)");
  lines.push("  const dayTasks = monthlyLog.taskExecutions?.[currentDate] || []");
  lines.push("");
  lines.push("  // \u30B3\u30E1\u30F3\u30C8\u304C\u3042\u308B\u3001\u3082\u3057\u304F\u306F\u30EC\u30FC\u30C6\u30A3\u30F3\u30B0\u304C\u3042\u308B\u30BF\u30B9\u30AF\u306E\u307F");
  lines.push("  const tasksWithComments = dayTasks");
  lines.push("    .filter(task => task.executionComment || task.focusLevel > 0 || task.energyLevel > 0)");
  lines.push("    .sort((a, b) => new Date(a.startTime) - new Date(b.startTime))");
  lines.push("");
  lines.push("  if (tasksWithComments.length > 0) {");
  lines.push("    const headers = ['\u30BF\u30B9\u30AF\u540D', '\u5B9F\u884C\u6642\u9593', '\u6240\u8981\u6642\u9593', '\u96C6\u4E2D\u5EA6', '\u5143\u6C17\u5EA6', '\u30B3\u30E1\u30F3\u30C8']");
  lines.push("    const tableData = tasksWithComments.map(task => {");
  lines.push("      const startTimeParts = task.startTime.split(':')");
  lines.push("      const stopTimeParts = task.stopTime.split(':')");
  lines.push("      const startTimeStr = startTimeParts[0] + ':' + startTimeParts[1]");
  lines.push("      const stopTimeStr = stopTimeParts[0] + ':' + stopTimeParts[1]");
  lines.push("      const durationMinutes = Math.round(task.duration / 60)");
  lines.push("      return [");
  lines.push("        task.taskName,");
  lines.push("        startTimeStr + ' - ' + stopTimeStr,");
  lines.push("        durationMinutes + '\u5206',");
  lines.push("        task.focusLevel > 0 ? '\u2B50'.repeat(task.focusLevel) : '-',");
  lines.push("        task.energyLevel > 0 ? '\u2B50'.repeat(task.energyLevel) : '-',");
  lines.push("        task.executionComment || '-'");
  lines.push("      ]");
  lines.push("    })");
  lines.push("    dv.table(headers, tableData)");
  lines.push("  } else {");
  lines.push("    dv.paragraph('\u{1F4DD} \u30B3\u30E1\u30F3\u30C8\u4ED8\u304D\u306E\u30BF\u30B9\u30AF\u306F\u3042\u308A\u307E\u305B\u3093\u3002')");
  lines.push("  }");
  lines.push("} catch (e) {");
  lines.push("  dv.paragraph('\u274C \u30C7\u30FC\u30BF\u304C\u8AAD\u307F\u8FBC\u3081\u307E\u305B\u3093\u3067\u3057\u305F\u3002TaskChute\u306E\u30ED\u30B0\u30D5\u30A1\u30A4\u30EB\u304C\u5B58\u5728\u3059\u308B\u304B\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002')");
  lines.push("}");
  lines.push("");
  lines.push("```");
  lines.push("");
  return lines.join("\n");
}

// src/services/ReviewService.ts
var ReviewService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  getReviewFileName(dateStr) {
    return `Daily - ${dateStr}.md`;
  }
  getReviewFilePath(dateStr) {
    const folder = this.plugin.pathManager.getReviewDataPath();
    const fileName = this.getReviewFileName(dateStr);
    return `${folder}/${fileName}`;
  }
  async ensureReviewFile(dateStr) {
    const reviewFolder = this.plugin.pathManager.getReviewDataPath();
    await this.plugin.pathManager.ensureFolderExists(reviewFolder);
    const reviewPath = this.getReviewFilePath(dateStr);
    const existing = this.plugin.app.vault.getAbstractFileByPath(reviewPath);
    if (existing && existing instanceof import_obsidian5.TFile) return existing;
    const logDataPath = this.plugin.pathManager.getLogDataPath();
    const content = buildDefaultReviewTemplate(logDataPath);
    const file = await this.plugin.app.vault.create(reviewPath, content);
    return file;
  }
  async openInSplit(file, leftLeaf) {
    try {
      const ws = this.plugin.app.workspace;
      const rightLeaf = typeof ws.splitActiveLeaf === "function" ? ws.splitActiveLeaf("vertical") : this.plugin.app.workspace.getLeaf("split");
      await rightLeaf.openFile(file);
      this.plugin.app.workspace.setActiveLeaf(leftLeaf);
    } catch (error) {
      new import_obsidian5.Notice("\u30EC\u30D3\u30E5\u30FC\u306E\u8868\u793A\u306B\u5931\u6557\u3057\u307E\u3057\u305F: " + ((error == null ? void 0 : error.message) || error));
      throw error;
    }
  }
};

// src/services/TimerService.ts
var TimerService = class {
  constructor(opts) {
    this.interval = null;
    var _a;
    this.getRunningInstances = opts.getRunningInstances;
    this.onTick = opts.onTick;
    this.intervalMs = (_a = opts.intervalMs) != null ? _a : 1e3;
  }
  start() {
    if (this.interval) return;
    this.interval = setInterval(() => this.tick(), this.intervalMs);
  }
  stop() {
    if (this.interval) {
      clearInterval(this.interval);
      this.interval = null;
    }
  }
  restart() {
    this.stop();
    this.start();
  }
  dispose() {
    this.stop();
  }
  isRunning() {
    return !!this.interval;
  }
  tick() {
    const running = this.getRunningInstances() || [];
    if (running.length === 0) {
      this.stop();
      return;
    }
    for (const inst of running) {
      try {
        this.onTick(inst);
      } catch (_) {
      }
    }
  }
};

// src/services/RoutineService.ts
var _RoutineService_static, isDailyDue_fn, isWeeklyDue_fn, isMonthlyDue_fn, toPositiveInt_fn, toWeekday_fn, isValidWeekday_fn, toDateStrOrUndef_fn, parseDate_fn, compareDate_fn, daysDiff_fn, weekStart_fn;
var RoutineService = class {
  /** Parse frontmatter into a normalized RoutineRule. */
  static parseFrontmatter(fm) {
    var _a, _b;
    if (!fm || typeof fm !== "object") return null;
    const isRoutine = fm.isRoutine === true;
    if (!isRoutine) return null;
    const typeRaw = fm.routine_type || fm.routineType || "daily";
    const type = typeRaw === "daily" || typeRaw === "weekly" || typeRaw === "monthly" ? typeRaw : (
      // Backward-compat: treat weekends/weekdays/custom as weekly variants
      "weekly"
    );
    const enabled = fm.routine_enabled === false ? false : true;
    const interval = __privateMethod(this, _RoutineService_static, toPositiveInt_fn).call(this, fm.routine_interval, 1);
    const rule = {
      type,
      interval,
      start: __privateMethod(this, _RoutineService_static, toDateStrOrUndef_fn).call(this, fm.routine_start),
      end: __privateMethod(this, _RoutineService_static, toDateStrOrUndef_fn).call(this, fm.routine_end),
      enabled
    };
    if (type === "weekly") {
      const weekday = __privateMethod(this, _RoutineService_static, toWeekday_fn).call(this, (_a = fm.routine_weekday) != null ? _a : fm.weekday);
      const weekdays = Array.isArray(fm.weekdays) ? fm.weekdays.filter((d) => __privateMethod(this, _RoutineService_static, isValidWeekday_fn).call(this, d)).map((d) => Number(d)) : void 0;
      const legacyType = fm.routine_type;
      const legacySet = legacyType === "weekdays" ? [1, 2, 3, 4, 5] : legacyType === "weekends" ? [0, 6] : void 0;
      if (weekday !== void 0) rule.weekday = weekday;
      if (weekdays && weekdays.length > 0) rule.weekdaySet = weekdays;
      if (legacySet) rule.weekdaySet = legacySet;
    }
    if (type === "monthly") {
      let week;
      if (fm.routine_week !== void 0) {
        week = fm.routine_week === "last" ? "last" : __privateMethod(this, _RoutineService_static, toPositiveInt_fn).call(this, fm.routine_week, void 0);
      } else if (fm.monthly_week !== void 0) {
        if (fm.monthly_week === "last") {
          week = "last";
        } else {
          const zeroBased = __privateMethod(this, _RoutineService_static, toPositiveInt_fn).call(this, fm.monthly_week, void 0);
          week = zeroBased !== void 0 ? zeroBased + 1 : void 0;
        }
      }
      const weekday = __privateMethod(this, _RoutineService_static, toWeekday_fn).call(this, (_b = fm.routine_weekday) != null ? _b : fm.monthly_weekday);
      if (week !== void 0) rule.week = week;
      if (weekday !== void 0) rule.monthWeekday = weekday;
    }
    return rule;
  }
  /** Determine if a routine is due on the given date (YYYY-MM-DD). */
  static isDue(dateStr, rule, movedTargetDate) {
    if (!rule) return false;
    if (!rule.enabled) return false;
    if (movedTargetDate) {
      return movedTargetDate === dateStr;
    }
    const date = __privateMethod(this, _RoutineService_static, parseDate_fn).call(this, dateStr);
    if (!date) return false;
    if (rule.start) {
      const s = __privateMethod(this, _RoutineService_static, parseDate_fn).call(this, rule.start);
      if (s && __privateMethod(this, _RoutineService_static, compareDate_fn).call(this, date, s) < 0) return false;
    }
    if (rule.end) {
      const e = __privateMethod(this, _RoutineService_static, parseDate_fn).call(this, rule.end);
      if (e && __privateMethod(this, _RoutineService_static, compareDate_fn).call(this, date, e) > 0) return false;
    }
    switch (rule.type) {
      case "daily":
        return __privateMethod(this, _RoutineService_static, isDailyDue_fn).call(this, date, rule);
      case "weekly":
        return __privateMethod(this, _RoutineService_static, isWeeklyDue_fn).call(this, date, rule);
      case "monthly":
        return __privateMethod(this, _RoutineService_static, isMonthlyDue_fn).call(this, date, rule);
      default:
        return false;
    }
  }
};
_RoutineService_static = new WeakSet();
isDailyDue_fn = function(date, rule) {
  const interval = Math.max(1, rule.interval || 1);
  if (!rule.start) return interval === 1;
  const s = __privateMethod(this, _RoutineService_static, parseDate_fn).call(this, rule.start);
  const diff = __privateMethod(this, _RoutineService_static, daysDiff_fn).call(this, s, date);
  return diff >= 0 && diff % interval === 0;
};
isWeeklyDue_fn = function(date, rule) {
  const weekdaySet = rule.weekdaySet;
  if (weekdaySet && Array.isArray(weekdaySet) && weekdaySet.length > 0) {
    return weekdaySet.includes(date.getDay());
  }
  const weekday = rule.weekday;
  if (weekday === void 0) return false;
  const interval = Math.max(1, rule.interval || 1);
  const start = rule.start ? __privateMethod(this, _RoutineService_static, parseDate_fn).call(this, rule.start) : void 0;
  const anchor = start ? __privateMethod(this, _RoutineService_static, weekStart_fn).call(this, start) : __privateMethod(this, _RoutineService_static, weekStart_fn).call(this, new Date(1970, 0, 4));
  const currentWeekStart = __privateMethod(this, _RoutineService_static, weekStart_fn).call(this, date);
  const wdiff = Math.floor((currentWeekStart.getTime() - anchor.getTime()) / (7 * 24 * 60 * 60 * 1e3));
  return wdiff >= 0 && wdiff % interval === 0 && date.getDay() === weekday;
};
isMonthlyDue_fn = function(date, rule) {
  const week = rule.week;
  const weekday = rule.monthWeekday;
  if (week === void 0 || weekday === void 0) return false;
  const interval = Math.max(1, rule.interval || 1);
  if (rule.start) {
    const s = __privateMethod(this, _RoutineService_static, parseDate_fn).call(this, rule.start);
    const mdiff = (date.getFullYear() - s.getFullYear()) * 12 + (date.getMonth() - s.getMonth());
    if (mdiff < 0 || mdiff % interval !== 0) return false;
  }
  if (week === "last") {
    const nextWeek = new Date(date);
    nextWeek.setDate(date.getDate() + 7);
    const isLast = nextWeek.getMonth() !== date.getMonth();
    return isLast && date.getDay() === weekday;
  }
  const occurrence = Math.floor((date.getDate() - 1) / 7) + 1;
  return occurrence === week && date.getDay() === weekday;
};
toPositiveInt_fn = function(value, fallback) {
  const n = Number(value);
  if (Number.isFinite(n) && n >= 1) return Math.floor(n);
  return fallback != null ? fallback : 1;
};
toWeekday_fn = function(value) {
  const n = Number(value);
  return __privateMethod(this, _RoutineService_static, isValidWeekday_fn).call(this, n) ? n : void 0;
};
isValidWeekday_fn = function(n) {
  return Number.isFinite(n) && n >= 0 && n <= 6;
};
toDateStrOrUndef_fn = function(v) {
  if (!v || typeof v !== "string") return void 0;
  return /^\d{4}-\d{2}-\d{2}$/.test(v) ? v : void 0;
};
parseDate_fn = function(dateStr) {
  const m = /^\d{4}-(\d{2})-(\d{2})$/.exec(dateStr);
  if (!m) return null;
  const [y, mo, d] = dateStr.split("-").map(Number);
  return new Date(y, mo - 1, d);
};
compareDate_fn = function(a, b) {
  const aKey = a.getFullYear() * 1e4 + (a.getMonth() + 1) * 100 + a.getDate();
  const bKey = b.getFullYear() * 1e4 + (b.getMonth() + 1) * 100 + b.getDate();
  return aKey === bKey ? 0 : aKey < bKey ? -1 : 1;
};
daysDiff_fn = function(a, b) {
  const msPerDay = 24 * 60 * 60 * 1e3;
  const utcA = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
  const utcB = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());
  return Math.floor((utcB - utcA) / msPerDay);
};
weekStart_fn = function(date) {
  const d = new Date(date);
  const dow = d.getDay();
  d.setDate(d.getDate() - dow);
  d.setHours(0, 0, 0, 0);
  return d;
};
__privateAdd(RoutineService, _RoutineService_static);
var RoutineService_default = RoutineService;

// src/views/TaskChuteView.helpers.ts
async function loadTasksRefactored() {
  var _a;
  this.tasks = [];
  this.taskInstances = [];
  try {
    const dateString = this.getCurrentDateString();
    const todayExecutions = await loadTodayExecutions.call(this, dateString);
    const taskFolderPath = this.plugin.pathManager.getTaskFolderPath();
    const taskFolder = this.app.vault.getAbstractFileByPath(taskFolderPath);
    if (!taskFolder) {
      this.renderTaskList();
      return;
    }
    const taskFiles = taskFolder.children.filter(
      (file) => file.extension === "md"
    );
    const processedTaskNames = /* @__PURE__ */ new Set();
    const processedFilePaths = /* @__PURE__ */ new Set();
    for (const exec of todayExecutions) {
      if (processedTaskNames.has(exec.taskTitle)) continue;
      processedTaskNames.add(exec.taskTitle);
      const taskFile = taskFiles.find(
        (f) => exec.taskPath && f.path === exec.taskPath || f.basename === exec.taskTitle
      );
      const taskExecutions = todayExecutions.filter(
        (e) => e.taskTitle === exec.taskTitle
      );
      const hadVisible = await createTaskFromExecutions.call(this, taskExecutions, taskFile, dateString);
      if (hadVisible && taskFile) {
        processedFilePaths.add(taskFile.path);
      }
    }
    for (const file of taskFiles) {
      if (processedFilePaths.has(file.path)) continue;
      const content = await this.app.vault.read(file);
      const metadata = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if (!content.includes("#task") && !(metadata == null ? void 0 : metadata.estimatedMinutes)) {
        continue;
      }
      const isRoutine = (metadata == null ? void 0 : metadata.isRoutine) === true;
      if (isRoutine) {
        if (shouldShowRoutineTask.call(this, metadata, this.currentDate, dateString)) {
          await createRoutineTask.call(this, file, content, metadata, dateString);
        }
      } else {
        const shouldShow = await shouldShowNonRoutineTask.call(this, file, metadata, dateString);
        if (shouldShow) {
          await createNonRoutineTask.call(this, file, content, metadata, dateString);
        }
      }
    }
    await addDuplicatedInstances.call(this, dateString);
    this.renderTaskList();
  } catch (error) {
    console.error("Failed to load tasks:", error);
    new this.app.constructor.Notice("\u30BF\u30B9\u30AF\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
  }
}
async function loadTodayExecutions(dateString) {
  var _a;
  try {
    const logDataPath = this.plugin.pathManager.getLogDataPath();
    const [year, month] = dateString.split("-");
    const monthString = `${year}-${month}`;
    const logPath = `${logDataPath}/${monthString}-tasks.json`;
    const logFile = this.app.vault.getAbstractFileByPath(logPath);
    if (!logFile) {
      return [];
    }
    const content = await this.app.vault.read(logFile);
    const monthlyLog = JSON.parse(content);
    const dayExecutions = ((_a = monthlyLog.taskExecutions) == null ? void 0 : _a[dateString]) || [];
    return dayExecutions.map((exec) => ({
      taskTitle: exec.taskTitle || exec.taskName,
      taskPath: exec.taskPath || "",
      startTime: exec.startTime,
      stopTime: exec.stopTime,
      slotKey: exec.slotKey || calculateSlotKeyFromTime(exec.startTime),
      instanceId: exec.instanceId
    }));
  } catch (error) {
    console.error("Failed to load today executions:", error);
    return [];
  }
}
function calculateSlotKeyFromTime(timeStr) {
  if (!timeStr) return "none";
  const [hourStr] = timeStr.split(":");
  const hour = parseInt(hourStr, 10);
  if (hour >= 0 && hour < 8) return "0:00-8:00";
  if (hour >= 8 && hour < 12) return "8:00-12:00";
  if (hour >= 12 && hour < 16) return "12:00-16:00";
  if (hour >= 16 && hour < 24) return "16:00-0:00";
  return "none";
}
async function createTaskFromExecutions(executions, file, dateString) {
  var _a, _b;
  const metadata = file ? (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter : null;
  let projectPath = null;
  let projectTitle = null;
  if (metadata == null ? void 0 : metadata.project_path) {
    projectPath = metadata.project_path;
    projectTitle = extractProjectTitle(metadata.project);
  } else if (metadata == null ? void 0 : metadata.project) {
    projectTitle = extractProjectTitle(metadata.project);
    if (projectTitle) {
      const allFiles = this.app.vault.getMarkdownFiles();
      const projectFile = allFiles.find((f) => f.basename === projectTitle);
      if (projectFile) {
        projectPath = projectFile.path;
      }
    }
  }
  const first = executions[0] || {};
  const derivedName = (file == null ? void 0 : file.basename) || typeof first.taskTitle === "string" && first.taskTitle || typeof first.taskPath === "string" && ((_b = first.taskPath.split("/").pop()) == null ? void 0 : _b.replace(/\.md$/, "")) || "Unknown Task";
  const derivedPath = (file == null ? void 0 : file.path) || typeof first.taskPath === "string" && first.taskPath || `TaskChute/Task/${derivedName}.md`;
  const taskData = {
    file: file || null,
    frontmatter: metadata || {},
    path: derivedPath,
    name: derivedName,
    title: derivedName,
    project: metadata == null ? void 0 : metadata.project,
    projectPath,
    projectTitle,
    isRoutine: (metadata == null ? void 0 : metadata.isRoutine) === true || false,
    routineType: metadata == null ? void 0 : metadata.routine_type,
    scheduledTime: metadata == null ? void 0 : metadata.\u958B\u59CB\u6642\u523B,
    isVirtual: !file
  };
  let created = 0;
  for (const exec of executions) {
    const instance = {
      task: taskData,
      instanceId: exec.instanceId || this.generateInstanceId(taskData.path),
      state: "done",
      slotKey: exec.slotKey,
      date: dateString,
      startTime: parseTimeString(exec.startTime, dateString),
      stopTime: parseTimeString(exec.stopTime, dateString),
      executedTitle: exec.taskTitle
    };
    const isDeleted = isInstanceDeleted.call(this, instance.instanceId, taskData.path, dateString);
    const isHidden = isInstanceHidden.call(this, instance.instanceId, taskData.path, dateString);
    if (!isDeleted && !isHidden) {
      this.taskInstances.push(instance);
      created++;
    }
  }
  if (created > 0) {
    this.tasks.push(taskData);
  }
  return created > 0;
}
async function createNonRoutineTask(file, content, metadata, dateString) {
  var _a, _b, _c;
  let projectPath = null;
  let projectTitle = null;
  if (metadata == null ? void 0 : metadata.project_path) {
    projectPath = metadata.project_path;
    projectTitle = extractProjectTitle(metadata.project);
  } else if (metadata == null ? void 0 : metadata.project) {
    projectTitle = extractProjectTitle(metadata.project);
    if (projectTitle) {
      const allFiles = this.app.vault.getMarkdownFiles();
      const projectFile = allFiles.find((f) => f.basename === projectTitle);
      if (projectFile) {
        projectPath = projectFile.path;
      }
    }
  }
  const taskData = {
    file,
    frontmatter: metadata || {},
    path: file.path,
    name: file.basename,
    title: file.basename,
    project: metadata == null ? void 0 : metadata.project,
    projectPath,
    projectTitle,
    isRoutine: false,
    scheduledTime: metadata == null ? void 0 : metadata.\u958B\u59CB\u6642\u523B
  };
  this.tasks.push(taskData);
  const storedSlot = (_c = (_b = (_a = this.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.slotKeys) == null ? void 0 : _c[file.path];
  const slotKey = storedSlot || getScheduledSlotKey(metadata == null ? void 0 : metadata.\u958B\u59CB\u6642\u523B) || "none";
  const instance = {
    task: taskData,
    instanceId: this.generateInstanceId(taskData.path),
    state: "idle",
    slotKey,
    date: dateString
  };
  const isDeleted = isInstanceDeleted.call(this, "", file.path, dateString);
  if (!isDeleted) {
    this.taskInstances.push(instance);
  }
}
async function createRoutineTask(file, content, metadata, dateString) {
  var _a, _b, _c, _d, _e, _f;
  const rule = RoutineService_default.parseFrontmatter(metadata);
  if (!rule || rule.enabled === false) return;
  let projectPath = null;
  let projectTitle = null;
  if (metadata == null ? void 0 : metadata.project_path) {
    projectPath = metadata.project_path;
    projectTitle = extractProjectTitle(metadata.project);
  } else if (metadata == null ? void 0 : metadata.project) {
    projectTitle = extractProjectTitle(metadata.project);
    if (projectTitle) {
      const allFiles = this.app.vault.getMarkdownFiles();
      const projectFile = allFiles.find((f) => f.basename === projectTitle);
      if (projectFile) {
        projectPath = projectFile.path;
      }
    }
  }
  const taskData = {
    file,
    frontmatter: metadata || {},
    path: file.path,
    name: file.basename,
    title: file.basename,
    project: metadata == null ? void 0 : metadata.project,
    projectPath,
    projectTitle,
    isRoutine: true,
    routineType: rule.type,
    routine_type: rule.type,
    routine_interval: rule.interval,
    routine_enabled: rule.enabled,
    routine_start: metadata == null ? void 0 : metadata.routine_start,
    routine_end: metadata == null ? void 0 : metadata.routine_end,
    scheduledTime: metadata == null ? void 0 : metadata.\u958B\u59CB\u6642\u523B,
    // Backward compat fields used elsewhere in UI
    weekday: (_b = (_a = metadata == null ? void 0 : metadata.weekday) != null ? _a : metadata == null ? void 0 : metadata.routine_weekday) != null ? _b : rule.weekday,
    weekdays: metadata == null ? void 0 : metadata.weekdays,
    monthlyWeek: (_d = (_c = metadata == null ? void 0 : metadata.monthly_week) != null ? _c : metadata == null ? void 0 : metadata.routine_week) != null ? _d : rule.week,
    monthlyWeekday: (_f = (_e = metadata == null ? void 0 : metadata.monthly_weekday) != null ? _e : metadata == null ? void 0 : metadata.routine_weekday) != null ? _f : rule.monthWeekday
  };
  this.tasks.push(taskData);
  const instance = {
    task: taskData,
    instanceId: this.generateInstanceId(taskData, dateString),
    state: "idle",
    slotKey: getScheduledSlotKey(metadata == null ? void 0 : metadata.\u958B\u59CB\u6642\u523B) || "none",
    date: dateString
  };
  const isHidden = isInstanceHidden.call(this, instance.instanceId, file.path, dateString);
  const isDeleted = isInstanceDeleted.call(this, instance.instanceId, file.path, dateString);
  if (!isHidden && !isDeleted) {
    this.taskInstances.push(instance);
  }
}
function shouldShowRoutineTask(metadata, date, dateString) {
  if (!metadata) return false;
  const movedTargetDate = metadata.target_date && metadata.target_date !== metadata.routine_start ? metadata.target_date : void 0;
  const rule = RoutineService_default.parseFrontmatter(metadata);
  return RoutineService_default.isDue(dateString, rule, movedTargetDate);
}
function extractProjectTitle(projectField) {
  if (!projectField) return void 0;
  const match = projectField.match(/\[\[([^\]]+)\]\]/);
  if (match) {
    return match[1];
  }
  return projectField;
}
function parseTimeString(timeStr, dateStr) {
  if (!timeStr) return void 0;
  const [hours, minutes, seconds] = timeStr.split(":").map(Number);
  const [year, month, day] = dateStr.split("-").map(Number);
  return new Date(year, month - 1, day, hours, minutes, seconds || 0);
}
function getScheduledSlotKey(scheduledTime) {
  if (!scheduledTime) return void 0;
  const [hourStr] = scheduledTime.split(":");
  const hour = parseInt(hourStr, 10);
  if (hour >= 0 && hour < 8) return "0:00-8:00";
  if (hour >= 8 && hour < 12) return "8:00-12:00";
  if (hour >= 12 && hour < 16) return "12:00-16:00";
  if (hour >= 16 && hour < 24) return "16:00-0:00";
  return void 0;
}
function isInstanceDeleted(instanceId, path, dateString) {
  if (typeof this.isInstanceDeleted === "function") {
    return this.isInstanceDeleted(instanceId, path, dateString);
  }
  return false;
}
function isInstanceHidden(instanceId, path, dateString) {
  if (typeof this.isInstanceHidden === "function") {
    return this.isInstanceHidden(instanceId, path, dateString);
  }
  return false;
}
async function shouldShowNonRoutineTask(file, metadata, dateString) {
  const deletedInstances = typeof this.getDeletedInstances === "function" ? this.getDeletedInstances(dateString) : [];
  const isDeleted = deletedInstances.some(
    (d) => d && d.deletionType === "permanent" && d.path === file.path
  );
  if (isDeleted) {
    return false;
  }
  if (metadata == null ? void 0 : metadata.target_date) {
    const shouldShow = metadata.target_date === dateString;
    return shouldShow;
  }
  try {
    const stats = await this.app.vault.adapter.stat(file.path);
    if (!stats) {
      return false;
    }
    const fileCreationDate = new Date(stats.ctime || stats.mtime);
    const year = fileCreationDate.getFullYear();
    const month = (fileCreationDate.getMonth() + 1).toString().padStart(2, "0");
    const day = fileCreationDate.getDate().toString().padStart(2, "0");
    const fileCreationDateString = `${year}-${month}-${day}`;
    if (dateString === fileCreationDateString) {
      return true;
    }
  } catch (error) {
    return false;
  }
  return false;
}
async function addDuplicatedInstances(dateString) {
  var _a, _b;
  try {
    const snapshot = typeof this.getDayStateSnapshot === "function" ? this.getDayStateSnapshot(dateString) : null;
    const dayState = snapshot || (typeof this.getDayState === "function" ? await this.getDayState(dateString) : null);
    if (!dayState || !Array.isArray(dayState.duplicatedInstances) || dayState.duplicatedInstances.length === 0) {
      return;
    }
    const records = dayState.duplicatedInstances;
    for (const rec of records) {
      const { instanceId, originalPath, slotKey } = rec || {};
      if (!instanceId || !originalPath) continue;
      const exists = this.taskInstances.some((i) => i.instanceId === instanceId);
      if (exists) continue;
      let taskData = this.tasks.find((t) => t.path === originalPath);
      if (!taskData) {
        const file = this.app.vault.getAbstractFileByPath(originalPath);
        const metadata = file ? (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter : void 0;
        const rule = metadata ? RoutineService_default.parseFrontmatter(metadata) : null;
        if (rule && rule.enabled === false) continue;
        if (file) {
          taskData = {
            file,
            frontmatter: metadata || {},
            path: originalPath,
            name: file.basename,
            title: file.basename,
            project: metadata == null ? void 0 : metadata.project,
            projectPath: metadata == null ? void 0 : metadata.project_path,
            projectTitle: extractProjectTitle(metadata == null ? void 0 : metadata.project),
            isRoutine: (metadata == null ? void 0 : metadata.isRoutine) === true || false,
            scheduledTime: metadata == null ? void 0 : metadata.\u958B\u59CB\u6642\u523B
          };
          this.tasks.push(taskData);
        } else {
          const base = ((_b = originalPath.split("/").pop()) == null ? void 0 : _b.replace(/\.md$/, "")) || originalPath;
          taskData = {
            file: null,
            frontmatter: {},
            path: originalPath,
            name: base,
            title: base,
            isRoutine: false,
            isVirtual: true
          };
          this.tasks.push(taskData);
        }
      }
      const instance = {
        task: taskData,
        instanceId,
        state: "idle",
        slotKey: slotKey || "none",
        date: dateString
      };
      const isDeleted = isInstanceDeleted.call(this, instance.instanceId, taskData.path, dateString);
      const isHidden = isInstanceHidden.call(this, instance.instanceId, taskData.path, dateString);
      if (!isDeleted && !isHidden) {
        this.taskInstances.push(instance);
      }
    }
  } catch (e) {
    console.error("Failed to restore duplicated instances:", e);
  }
}

// src/managers/ProjectNoteSyncManager.ts
var import_obsidian6 = require("obsidian");
var ProjectNoteSyncManager = class {
  constructor(app, pathManager) {
    this.app = app;
    this.pathManager = pathManager;
  }
  // プロジェクトノートパスを取得
  async getProjectNotePath(inst) {
    var _a, _b;
    if (!((_a = inst == null ? void 0 : inst.task) == null ? void 0 : _a.projectPath) && !((_b = inst == null ? void 0 : inst.task) == null ? void 0 : _b.projectTitle)) return null;
    if (inst.task.projectPath) {
      return inst.task.projectPath;
    }
    const projectFolderPath = this.pathManager.getProjectFolderPath();
    const projectPath = `${projectFolderPath}/${inst.task.projectTitle}.md`;
    const file = this.app.vault.getAbstractFileByPath(projectPath);
    return file ? projectPath : null;
  }
  // ログセクションを検出または作成
  async ensureLogSection(content) {
    const logSectionRegex = /^#{1,2}\s+(ログ|log|Log|LOG)\s*$/im;
    const match = content.match(logSectionRegex);
    if (match && typeof match.index === "number") {
      return {
        exists: true,
        position: match.index + match[0].length,
        content
      };
    }
    const newContent = content.trimEnd() + "\n\n## \u30ED\u30B0\n";
    return {
      exists: false,
      position: newContent.length,
      content: newContent
    };
  }
  // コメントエントリをフォーマット
  formatCommentEntry(inst, completionData, dateString) {
    const wikilink = `[[${dateString}]]`;
    const comment = completionData.executionComment || "";
    const formattedComment = comment.split("\n").map((line) => `    - ${line}`).join("\n");
    return {
      date: dateString,
      entry: `- ${wikilink}
${formattedComment}`,
      instanceId: inst.instanceId
    };
  }
  // 既存ログをパースして構造化
  parseExistingLogs(content, logSectionPosition) {
    const lines = content.substring(logSectionPosition).split("\n");
    const logs = [];
    let currentDate = null;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const dateMatch = line.match(/^-\s+\[\[(\d{4}-\d{2}-\d{2})\]\]/);
      if (dateMatch) {
        currentDate = dateMatch[1];
        logs.push({ date: currentDate, lineIndex: i, entries: [] });
        continue;
      }
      if (currentDate && line.match(/^(\t|    )-\s+/)) {
        const log = logs[logs.length - 1];
        log.entries.push({ lineIndex: i, content: line });
      }
    }
    return logs;
  }
  // 既存日付の末尾の次の位置を求める
  findInsertPosition(content, existingDateLog, sectionPos) {
    const logContent = content.substring(sectionPos);
    const logLines = logContent.split("\n");
    const lastEntryLine = existingDateLog.lineIndex + existingDateLog.entries.length + 1;
    let relativePosition = 0;
    for (let i = 0; i < lastEntryLine && i < logLines.length; i++) {
      relativePosition += logLines[i].length + 1;
    }
    return sectionPos + relativePosition;
  }
  // 日付の挿入位置を検出（降順）
  findDateInsertPosition(content, logs, newDate, sectionPos) {
    if (logs.length === 0) return sectionPos + 1;
    for (let i = 0; i < logs.length; i++) {
      if (newDate > logs[i].date) {
        const logContent = content.substring(sectionPos);
        const logLines = logContent.split("\n");
        let relativePosition = 0;
        for (let j = 0; j < logs[i].lineIndex && j < logLines.length; j++) {
          relativePosition += logLines[j].length + 1;
        }
        return sectionPos + relativePosition;
      }
    }
    const lastLog = logs[logs.length - 1];
    return this.findInsertPosition(content, lastLog, sectionPos);
  }
  insertAtPosition(content, text, position) {
    return content.substring(0, position) + text + "\n" + content.substring(position);
  }
  formatDateString(date) {
    const y = date.getFullYear();
    const m = (date.getMonth() + 1).toString().padStart(2, "0");
    const d = date.getDate().toString().padStart(2, "0");
    return `${y}-${m}-${d}`;
  }
  // プロジェクトノートを更新
  async updateProjectNote(projectPath, inst, completionData) {
    const file = this.app.vault.getAbstractFileByPath(projectPath);
    if (!file || !(file instanceof import_obsidian6.TFile)) {
      throw new Error(`\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30CE\u30FC\u30C8\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093: ${projectPath}`);
    }
    let content = await this.app.vault.read(file);
    const sectionResult = await this.ensureLogSection(content);
    content = sectionResult.content;
    const taskDate = inst.startTime ? new Date(inst.startTime) : /* @__PURE__ */ new Date();
    const dateString = this.formatDateString(taskDate);
    const entry = this.formatCommentEntry(inst, completionData, dateString);
    const logs = this.parseExistingLogs(content, sectionResult.position);
    const existingDateLog = logs.find((l) => l.date === dateString);
    if (existingDateLog) {
      const insertPos = this.findInsertPosition(content, existingDateLog, sectionResult.position);
      const commentOnly = entry.entry.split("\n").slice(1).join("\n");
      content = this.insertAtPosition(content, commentOnly, insertPos);
    } else {
      const insertPos = this.findDateInsertPosition(content, logs, dateString, sectionResult.position);
      const entryWithSpacing = logs.length > 0 ? `${entry.entry}
` : entry.entry;
      content = this.insertAtPosition(content, entryWithSpacing, insertPos);
    }
    await this.app.vault.modify(file, content);
    return true;
  }
};

// src/services/RunningTasksService.ts
var import_obsidian7 = require("obsidian");
var RunningTasksService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async save(runningInstances) {
    const records = runningInstances.map((inst) => {
      const base = inst.startTime ? new Date(inst.startTime) : /* @__PURE__ */ new Date();
      const y = base.getFullYear();
      const m = String(base.getMonth() + 1).padStart(2, "0");
      const d = String(base.getDate()).padStart(2, "0");
      const dateString = `${y}-${m}-${d}`;
      return {
        date: dateString,
        taskTitle: inst.task.name,
        taskPath: inst.task.path,
        startTime: (inst.startTime ? inst.startTime : /* @__PURE__ */ new Date()).toISOString(),
        slotKey: inst.slotKey,
        originalSlotKey: inst.originalSlotKey,
        instanceId: inst.instanceId,
        taskDescription: inst.task.description || "",
        isRoutine: inst.task.isRoutine === true
      };
    });
    const logDataPath = this.plugin.pathManager.getLogDataPath();
    const dataPath = `${logDataPath}/running-task.json`;
    await this.plugin.app.vault.adapter.write(
      dataPath,
      JSON.stringify(records, null, 2)
    );
  }
  async loadForDate(dateString) {
    try {
      const logDataPath = this.plugin.pathManager.getLogDataPath();
      const dataPath = `${logDataPath}/running-task.json`;
      const file = this.plugin.app.vault.getAbstractFileByPath(dataPath);
      if (!file || !(file instanceof import_obsidian7.TFile)) return [];
      const raw = await this.plugin.app.vault.read(file);
      const json = JSON.parse(raw);
      if (!Array.isArray(json)) return [];
      return json.filter((r) => r.date === dateString);
    } catch (_) {
      return [];
    }
  }
};

// src/services/ExecutionLogService.ts
var import_obsidian8 = require("obsidian");
var ExecutionLogService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  toHMS(d) {
    const pad = (n) => String(n).padStart(2, "0");
    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }
  getMonthKey(date) {
    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, "0");
    return `${y}-${m}`;
  }
  getDateKey(date) {
    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, "0");
    const d = String(date.getDate()).padStart(2, "0");
    return `${y}-${m}-${d}`;
  }
  async saveTaskLog(inst, durationSec) {
    var _a;
    if (!inst.startTime || !inst.stopTime) return;
    const start = new Date(inst.startTime);
    const monthKey = this.getMonthKey(start);
    const dateKey = this.getDateKey(start);
    const logDataPath = this.plugin.pathManager.getLogDataPath();
    const logPath = `${logDataPath}/${monthKey}-tasks.json`;
    let file = this.plugin.app.vault.getAbstractFileByPath(logPath);
    let json = { taskExecutions: {}, dailySummary: {} };
    if (file && file instanceof import_obsidian8.TFile) {
      try {
        const raw = await this.plugin.app.vault.read(file);
        json = raw ? JSON.parse(raw) : json;
      } catch (_) {
      }
    } else {
      await this.plugin.pathManager.ensureFolderExists(logDataPath);
      await this.plugin.app.vault.create(logPath, JSON.stringify(json, null, 2));
      file = this.plugin.app.vault.getAbstractFileByPath(logPath);
    }
    if (!json.taskExecutions) json.taskExecutions = {};
    if (!json.dailySummary) json.dailySummary = {};
    if (!json.taskExecutions[dateKey]) json.taskExecutions[dateKey] = [];
    const exec = {
      taskTitle: inst.task.title || inst.task.name,
      taskPath: inst.task.path,
      instanceId: inst.instanceId,
      slotKey: inst.slotKey,
      startTime: this.toHMS(start),
      stopTime: this.toHMS(inst.stopTime),
      durationSec
    };
    const arr = json.taskExecutions[dateKey];
    const idx = arr.findIndex((e) => e.instanceId === exec.instanceId);
    if (idx >= 0) arr[idx] = exec;
    else arr.push(exec);
    const totalMinutes = arr.reduce((s, e) => s + Math.floor((e.durationSec || 0) / 60), 0);
    json.dailySummary[dateKey] = {
      totalMinutes,
      totalTasks: arr.length,
      completedTasks: arr.length,
      procrastinatedTasks: ((_a = json.dailySummary[dateKey]) == null ? void 0 : _a.procrastinatedTasks) || 0,
      completionRate: arr.length > 0 ? 1 : 0
    };
    await this.plugin.app.vault.modify(file, JSON.stringify(json, null, 2));
  }
  async removeTaskLogForInstanceOnDate(instanceId, dateKey) {
    var _a;
    try {
      const [y, m] = dateKey.split("-");
      const monthKey = `${y}-${m}`;
      const logDataPath = this.plugin.pathManager.getLogDataPath();
      const logPath = `${logDataPath}/${monthKey}-tasks.json`;
      const file = this.plugin.app.vault.getAbstractFileByPath(logPath);
      if (!file || !(file instanceof import_obsidian8.TFile)) return;
      const raw = await this.plugin.app.vault.read(file);
      if (!raw) return;
      let json = {};
      try {
        json = JSON.parse(raw);
      } catch (_) {
        return;
      }
      if (!json.taskExecutions || !Array.isArray(json.taskExecutions[dateKey])) return;
      const filtered = json.taskExecutions[dateKey].filter((e) => e.instanceId !== instanceId);
      json.taskExecutions[dateKey] = filtered;
      const totalMinutes = filtered.reduce((s, e) => s + Math.floor((e.durationSec || 0) / 60), 0);
      if (!json.dailySummary) json.dailySummary = {};
      json.dailySummary[dateKey] = {
        totalMinutes,
        totalTasks: filtered.length,
        completedTasks: filtered.length,
        procrastinatedTasks: ((_a = json.dailySummary[dateKey]) == null ? void 0 : _a.procrastinatedTasks) || 0,
        completionRate: filtered.length > 0 ? 1 : 0
      };
      await this.plugin.app.vault.modify(file, JSON.stringify(json, null, 2));
    } catch (_) {
    }
  }
};

// src/services/TaskCreationService.ts
var import_obsidian9 = require("obsidian");
var TaskCreationService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Generate a unique markdown basename by appending (n) if needed.
   * Does not create files; only computes an available name.
   */
  ensureUniqueBasename(taskName) {
    const taskFolderPath = this.plugin.pathManager.getTaskFolderPath();
    let fileName = taskName;
    let counter = 1;
    while (this.plugin.app.vault.getAbstractFileByPath(`${taskFolderPath}/${fileName}.md`)) {
      fileName = `${taskName} (${counter})`;
      counter++;
    }
    return fileName;
  }
  /**
   * Create a task file with frontmatter and heading.
   * - Adds target_date frontmatter
   * - Keeps H1 heading as original taskName (basename may include suffix)
   * Returns the created TFile.
   */
  async createTaskFile(taskName, dateStr) {
    const taskFolderPath = this.plugin.pathManager.getTaskFolderPath();
    if (typeof this.plugin.pathManager.ensureFolderExists === "function") {
      await this.plugin.pathManager.ensureFolderExists(taskFolderPath);
    }
    const uniqueBase = this.ensureUniqueBasename(taskName);
    const filePath = `${taskFolderPath}/${uniqueBase}.md`;
    const content = [
      "---",
      `target_date: "${dateStr}"`,
      "---",
      "",
      "#task",
      "",
      `# ${taskName}`,
      ""
    ].join("\n");
    const file = await this.plugin.app.vault.create(filePath, content);
    new import_obsidian9.Notice(`\u30BF\u30B9\u30AF\u300C${taskName}\u300D\u3092\u4F5C\u6210\u3057\u307E\u3057\u305F`);
    return file;
  }
};

// src/ui/TaskNameAutocomplete.ts
var import_obsidian10 = require("obsidian");
var TaskNameAutocomplete = class {
  constructor(plugin, inputElement, containerElement, view) {
    this.taskNames = [];
    this.projectNames = [];
    this.selectedIndex = -1;
    this.suggestionsElement = null;
    this.debounceTimer = null;
    this.isVisible = false;
    this.fileEventRefs = [];
    this.plugin = plugin;
    this.inputElement = inputElement;
    this.containerElement = containerElement;
    this.view = view;
  }
  async initialize() {
    await this.loadTaskNames();
    await this.loadProjectNames();
    this.setupEventListeners();
    this.setupFileEventListeners();
  }
  async loadTaskNames() {
    const taskFolderPath = this.plugin.pathManager.getTaskFolderPath();
    const taskFolder = this.plugin.app.vault.getAbstractFileByPath(taskFolderPath);
    if (!(taskFolder instanceof import_obsidian10.TFolder)) return;
    const taskNames = /* @__PURE__ */ new Set();
    const processFolder = (folder) => {
      for (const child of folder.children) {
        if (child instanceof import_obsidian10.TFile && child.extension === "md") {
          const name = child.basename;
          taskNames.add(name);
        } else if (child instanceof import_obsidian10.TFolder) {
          processFolder(child);
        }
      }
    };
    processFolder(taskFolder);
    this.taskNames = Array.from(taskNames).sort();
  }
  async loadProjectNames() {
    const projectFolderPath = this.plugin.pathManager.getProjectFolderPath();
    const projectFolder = this.plugin.app.vault.getAbstractFileByPath(projectFolderPath);
    if (!(projectFolder instanceof import_obsidian10.TFolder)) return;
    const projectNames = /* @__PURE__ */ new Set();
    const processFolder = (folder) => {
      for (const child of folder.children) {
        if (child instanceof import_obsidian10.TFile && child.extension === "md") {
          const name = child.basename;
          projectNames.add(name);
        } else if (child instanceof import_obsidian10.TFolder) {
          processFolder(child);
        }
      }
    };
    processFolder(projectFolder);
    this.projectNames = Array.from(projectNames).sort();
  }
  setupEventListeners() {
    this.inputElement.addEventListener("input", () => {
      if (this.debounceTimer) {
        clearTimeout(this.debounceTimer);
      }
      this.debounceTimer = setTimeout(() => {
        this.showSuggestions();
      }, 100);
    });
    this.inputElement.addEventListener("focus", () => {
      this.showSuggestions();
    });
    this.inputElement.addEventListener("blur", () => {
      setTimeout(() => {
        if (this.suggestionsElement && this.suggestionsElement.contains(document.activeElement)) return;
        this.hideSuggestions();
      }, 200);
    });
    this.inputElement.addEventListener("keydown", (e) => {
      if (!this.isVisible) return;
      switch (e.key) {
        case "ArrowDown":
          e.preventDefault();
          this.selectNext();
          break;
        case "ArrowUp":
          e.preventDefault();
          this.selectPrevious();
          break;
        case "Enter":
          if (this.selectedIndex >= 0) {
            e.preventDefault();
            this.applySuggestion();
          }
          break;
        case "Escape":
          this.hideSuggestions();
          break;
        case "Tab":
          if (this.selectedIndex >= 0) {
            e.preventDefault();
            this.applySuggestion();
          }
          break;
      }
    });
    window.addEventListener("resize", () => this.hideSuggestions());
    window.addEventListener("scroll", () => this.hideSuggestions(), true);
  }
  setupFileEventListeners() {
    const taskFolderPath = this.plugin.pathManager.getTaskFolderPath();
    const projectFolderPath = this.plugin.pathManager.getProjectFolderPath();
    const fileCreated = this.plugin.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian10.TFile && file.path.startsWith(taskFolderPath)) {
        this.loadTaskNames();
      } else if (file instanceof import_obsidian10.TFile && file.path.startsWith(projectFolderPath)) {
        this.loadProjectNames();
      }
    });
    const fileDeleted = this.plugin.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian10.TFile && file.path.startsWith(taskFolderPath)) {
        this.loadTaskNames();
      } else if (file instanceof import_obsidian10.TFile && file.path.startsWith(projectFolderPath)) {
        this.loadProjectNames();
      }
    });
    const fileRenamed = this.plugin.app.vault.on("rename", (file) => {
      if (file instanceof import_obsidian10.TFile && (file.path.startsWith(taskFolderPath) || file.path.startsWith(projectFolderPath))) {
        this.loadTaskNames();
        this.loadProjectNames();
      }
    });
    this.fileEventRefs.push(fileCreated, fileDeleted, fileRenamed);
  }
  showSuggestions() {
    const inputValue = this.inputElement.value.trim().toLowerCase();
    if (!inputValue) {
      this.hideSuggestions();
      return;
    }
    const isProjectSearch = inputValue.includes("@");
    let searchTerm = inputValue;
    let prefix = "";
    if (isProjectSearch) {
      const parts = inputValue.split("@");
      searchTerm = parts[1] || "";
      prefix = parts[0] + "@";
    }
    const source = isProjectSearch ? this.projectNames : this.taskNames;
    const matches = source.filter(
      (name) => name.toLowerCase().includes(searchTerm)
    ).slice(0, 10);
    if (matches.length === 0) {
      this.hideSuggestions();
      return;
    }
    if (this.suggestionsElement) {
      this.suggestionsElement.remove();
    }
    this.suggestionsElement = document.createElement("div");
    this.suggestionsElement.className = "taskchute-autocomplete-suggestions";
    matches.forEach((match, index) => {
      const item = document.createElement("div");
      item.className = "suggestion-item";
      item.textContent = prefix + match;
      item.addEventListener("mouseenter", () => {
        this.selectedIndex = index;
        this.updateSelection(this.suggestionsElement.querySelectorAll(".suggestion-item"));
      });
      item.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.applySuggestionFromText(prefix + match);
      });
      this.suggestionsElement.appendChild(item);
    });
    const rect = this.inputElement.getBoundingClientRect();
    this.suggestionsElement.style.top = `${rect.bottom + 2}px`;
    this.suggestionsElement.style.left = `${rect.left}px`;
    this.suggestionsElement.style.width = `${rect.width}px`;
    document.body.appendChild(this.suggestionsElement);
    this.isVisible = true;
  }
  hideSuggestions() {
    if (this.suggestionsElement) {
      this.suggestionsElement.remove();
      this.suggestionsElement = null;
    }
    this.isVisible = false;
    this.selectedIndex = -1;
  }
  selectNext() {
    if (!this.suggestionsElement) return;
    const items = this.suggestionsElement.querySelectorAll(".suggestion-item");
    if (items.length === 0) return;
    this.selectedIndex = (this.selectedIndex + 1) % items.length;
    this.updateSelection(items);
  }
  selectPrevious() {
    if (!this.suggestionsElement) return;
    const items = this.suggestionsElement.querySelectorAll(".suggestion-item");
    if (items.length === 0) return;
    this.selectedIndex = this.selectedIndex <= 0 ? items.length - 1 : this.selectedIndex - 1;
    this.updateSelection(items);
  }
  updateSelection(items) {
    items.forEach((item, index) => {
      if (index === this.selectedIndex) {
        item.classList.add("suggestion-item-selected");
      } else {
        item.classList.remove("suggestion-item-selected");
      }
    });
  }
  applySuggestion() {
    if (!this.suggestionsElement || this.selectedIndex < 0) return;
    const items = this.suggestionsElement.querySelectorAll(".suggestion-item");
    const selectedItem = items[this.selectedIndex];
    if (selectedItem) {
      const text = selectedItem.textContent || "";
      this.applySuggestionFromText(text);
    }
  }
  applySuggestionFromText(text) {
    this.inputElement.value = text;
    this.hideSuggestions();
    this.inputElement.dispatchEvent(new Event("input", { bubbles: true }));
    this.inputElement.dispatchEvent(new Event("change", { bubbles: true }));
    this.inputElement.dispatchEvent(new CustomEvent("autocomplete-selected", {
      detail: { taskName: text },
      bubbles: true
    }));
    this.inputElement.focus();
  }
  destroy() {
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }
    this.fileEventRefs.forEach((ref) => {
      this.plugin.app.vault.offref(ref);
    });
    this.hideSuggestions();
  }
};

// src/views/TaskChuteView.ts
var NavigationStateManager = class {
  constructor() {
    this.selectedSection = null;
    this.isOpen = false;
  }
};
var TaskChuteView = class extends import_obsidian11.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.tasks = [];
    this.taskInstances = [];
    this.currentInstance = null;
    this.globalTimerInterval = null;
    this.timerService = null;
    this.logView = null;
    this.selectedTaskInstance = null;
    this.autocompleteInstances = [];
    this.dayStateCache = /* @__PURE__ */ new Map();
    this.currentDayState = null;
    this.currentDayStateKey = null;
    // Boundary Check (idle-task-auto-move feature)
    this.boundaryCheckTimeout = null;
    // Debounce Timer
    this.renderDebounceTimer = null;
    // Debug helper flag
    // Task Name Validator
    this.TaskNameValidator = {
      INVALID_CHARS_PATTERN: /[:|\/\\#^]/g,
      validate(taskName) {
        const invalidChars = taskName.match(this.INVALID_CHARS_PATTERN);
        return {
          isValid: !invalidChars,
          invalidChars: invalidChars ? [...new Set(invalidChars)] : []
        };
      },
      getErrorMessage(invalidChars) {
        return `\u4F7F\u7528\u3067\u304D\u306A\u3044\u6587\u5B57\u304C\u542B\u307E\u308C\u3066\u3044\u307E\u3059: ${invalidChars.join(", ")}`;
      }
    };
    this.plugin = plugin;
    const today = /* @__PURE__ */ new Date();
    this.currentDate = new Date(
      today.getFullYear(),
      today.getMonth(),
      today.getDate()
    );
    this.useOrderBasedSort = this.plugin.settings.useOrderBasedSort !== false;
    this.navigationState = new NavigationStateManager();
    this.runningTasksService = new RunningTasksService(this.plugin);
    this.executionLogService = new ExecutionLogService(this.plugin);
    this.taskCreationService = new TaskCreationService(this.plugin);
  }
  getViewType() {
    return "taskchute-view";
  }
  getDisplayText() {
    return "TaskChute";
  }
  getIcon() {
    return "checkmark";
  }
  // ===========================================
  // Core Lifecycle Methods
  // ===========================================
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    this.scheduleBoundaryCheck();
    await this.setupUI(container);
    await this.loadTasks();
    this.checkBoundaryTasks();
    await this.restoreRunningTaskState();
    this.ensureTimerService();
    this.setupResizeObserver();
    this.initializeNavigationEventListeners();
    this.setupEventListeners();
  }
  async onClose() {
    this.cleanupAutocompleteInstances();
    this.cleanupTimers();
  }
  // ===========================================
  // UI Setup Methods
  // ===========================================
  async setupUI(container) {
    const topBarContainer = container.createEl("div", {
      cls: "top-bar-container"
    });
    this.createDrawerToggle(topBarContainer);
    this.createDateNavigation(topBarContainer);
    this.createActionButtons(topBarContainer);
    const mainContainer = container.createEl("div", {
      cls: "taskchute-container"
    });
    const contentContainer = mainContainer.createEl("div", {
      cls: "main-container"
    });
    this.createNavigationUI(contentContainer);
    const taskListContainer = contentContainer.createEl("div", {
      cls: "task-list-container"
    });
    this.taskList = taskListContainer.createEl("div", { cls: "task-list" });
  }
  createDrawerToggle(topBarContainer) {
    const drawerToggle = topBarContainer.createEl("button", {
      cls: "drawer-toggle",
      attr: { title: "\u30CA\u30D3\u30B2\u30FC\u30B7\u30E7\u30F3\u3092\u958B\u304F" }
    });
    drawerToggle.createEl("span", {
      cls: "drawer-toggle-icon",
      text: "\u2630"
    });
  }
  createDateNavigation(topBarContainer) {
    const navContainer = topBarContainer.createEl("div", {
      cls: "date-nav-container compact"
    });
    const leftBtn = navContainer.createEl("button", {
      cls: "date-nav-arrow",
      text: "<"
    });
    const calendarBtn = navContainer.createEl("button", {
      cls: "calendar-btn",
      text: "\u{1F5D3}\uFE0F",
      attr: { title: "\u30AB\u30EC\u30F3\u30C0\u30FC\u3092\u958B\u304F" },
      style: "font-size:18px;padding:0 6px;background:none;border:none;cursor:pointer;"
    });
    const dateLabel = navContainer.createEl("span", { cls: "date-nav-label" });
    const rightBtn = navContainer.createEl("button", {
      cls: "date-nav-arrow",
      text: ">"
    });
    this.updateDateLabel(dateLabel);
    leftBtn.addEventListener("click", async () => {
      this.currentDate.setDate(this.currentDate.getDate() - 1);
      this.updateDateLabel(dateLabel);
      await this.reloadTasksAndRestore({ runBoundaryCheck: true });
    });
    rightBtn.addEventListener("click", async () => {
      this.currentDate.setDate(this.currentDate.getDate() + 1);
      this.updateDateLabel(dateLabel);
      await this.reloadTasksAndRestore({ runBoundaryCheck: true });
    });
    this.setupCalendarButton(calendarBtn, dateLabel);
    topBarContainer.createEl("div", {
      cls: "header-divider"
    });
  }
  createActionButtons(topBarContainer) {
    const actionSection = topBarContainer.createEl("div", {
      cls: "header-action-section"
    });
    const addTaskButton = actionSection.createEl("button", {
      cls: "add-task-button repositioned",
      text: "+",
      attr: { title: "\u65B0\u3057\u3044\u30BF\u30B9\u30AF\u3092\u8FFD\u52A0" }
    });
    const robotButton = actionSection.createEl("button", {
      cls: "robot-terminal-button",
      text: "\u{1F916}",
      attr: { title: "\u30BF\u30FC\u30DF\u30CA\u30EB\u3092\u958B\u304F" }
    });
    addTaskButton.addEventListener("click", () => this.showAddTaskModal());
    robotButton.addEventListener("click", async () => {
      try {
        await this.app.commands.executeCommandById(
          "terminal:open-terminal.integrated.root"
        );
      } catch (error) {
        new import_obsidian11.Notice("\u30BF\u30FC\u30DF\u30CA\u30EB\u3092\u958B\u3051\u307E\u305B\u3093\u3067\u3057\u305F: " + error.message);
      }
    });
  }
  // Utility: reload tasks and immediately restore running-state from persistence
  async reloadTasksAndRestore(options = {}) {
    await this.loadTasks();
    await this.restoreRunningTaskState();
    this.renderTaskList();
    if (options.runBoundaryCheck) {
      await this.checkBoundaryTasks();
    }
    this.scheduleBoundaryCheck();
  }
  createNavigationUI(contentContainer) {
    this.navigationOverlay = contentContainer.createEl("div", {
      cls: "navigation-overlay navigation-overlay-hidden"
    });
    this.navigationPanel = contentContainer.createEl("div", {
      cls: "navigation-panel navigation-panel-hidden"
    });
    const navMenu = this.navigationPanel.createEl("nav", {
      cls: "navigation-nav"
    });
    this.navigationContent = this.navigationPanel.createEl("div", {
      cls: "navigation-content"
    });
    const navigationItems = [
      { key: "routine", label: "\u30EB\u30FC\u30C1\u30F3", icon: "\u{1F504}" },
      { key: "review", label: "\u30EC\u30D3\u30E5\u30FC", icon: "\u{1F4CB}" },
      { key: "log", label: "\u30ED\u30B0", icon: "\u{1F4CA}" },
      { key: "project", label: "\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8", icon: "\u{1F4C1}" }
    ];
    navigationItems.forEach((item) => {
      const navItem = navMenu.createEl("div", {
        cls: "navigation-nav-item",
        attr: { "data-section": item.key }
      });
      navItem.createEl("span", {
        cls: "navigation-nav-icon",
        text: item.icon
      });
      navItem.createEl("span", {
        cls: "navigation-nav-label",
        text: item.label
      });
      navItem.addEventListener("click", () => {
        this.handleNavigationItemClick(item.key);
      });
    });
  }
  // ===========================================
  // Date Management Methods
  // ===========================================
  updateDateLabel(label) {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const current = new Date(this.currentDate);
    current.setHours(0, 0, 0, 0);
    const isToday = current.getTime() === today.getTime();
    const dayName = current.toLocaleDateString("ja-JP", { weekday: "short" });
    const dateStr = `${this.currentDate.getMonth() + 1}/${this.currentDate.getDate()}`;
    label.textContent = isToday ? `\u4ECA\u65E5 (${dateStr} ${dayName})` : `${dateStr} ${dayName}`;
  }
  getCurrentDateString() {
    const y = this.currentDate.getFullYear();
    const m = (this.currentDate.getMonth() + 1).toString().padStart(2, "0");
    const d = this.currentDate.getDate().toString().padStart(2, "0");
    return `${y}-${m}-${d}`;
  }
  parseDateString(dateStr) {
    const [y, m, d] = dateStr.split("-").map((value) => parseInt(value, 10));
    return new Date(y, (m || 1) - 1, d || 1);
  }
  async ensureDayStateForDate(dateStr) {
    const cached = this.dayStateCache.get(dateStr);
    if (cached) {
      if (dateStr === this.getCurrentDateString()) {
        this.currentDayState = cached;
        this.currentDayStateKey = dateStr;
      }
      return cached;
    }
    const date = this.parseDateString(dateStr);
    const loaded = await this.plugin.dayStateService.loadDay(date);
    this.dayStateCache.set(dateStr, loaded);
    if (dateStr === this.getCurrentDateString()) {
      this.currentDayState = loaded;
      this.currentDayStateKey = dateStr;
    }
    return loaded;
  }
  async getDayState(dateStr) {
    return this.ensureDayStateForDate(dateStr);
  }
  getDayStateSnapshot(dateStr) {
    var _a;
    return (_a = this.dayStateCache.get(dateStr)) != null ? _a : null;
  }
  async ensureDayStateForCurrentDate() {
    const dateStr = this.getCurrentDateString();
    return this.ensureDayStateForDate(dateStr);
  }
  getCurrentDayState() {
    const dateStr = this.getCurrentDateString();
    let state = this.dayStateCache.get(dateStr);
    if (!state) {
      state = {
        hiddenRoutines: [],
        deletedInstances: [],
        duplicatedInstances: [],
        orders: {}
      };
      this.dayStateCache.set(dateStr, state);
    }
    this.currentDayState = state;
    this.currentDayStateKey = dateStr;
    return state;
  }
  async persistDayState(dateStr) {
    const state = this.dayStateCache.get(dateStr);
    if (!state) return;
    const date = this.parseDateString(dateStr);
    await this.plugin.dayStateService.saveDay(date, state);
  }
  getOrderKey(inst) {
    var _a, _b;
    const slot = inst.slotKey || "none";
    const dayState = this.getCurrentDayState();
    const isDuplicate = dayState.duplicatedInstances.some(
      (dup) => (dup == null ? void 0 : dup.instanceId) && dup.instanceId === inst.instanceId
    );
    if (isDuplicate || !((_a = inst.task) == null ? void 0 : _a.path)) {
      return inst.instanceId ? `${inst.instanceId}::${slot}` : null;
    }
    if ((_b = inst.task) == null ? void 0 : _b.path) {
      return `${inst.task.path}::${slot}`;
    }
    return inst.instanceId ? `${inst.instanceId}::${slot}` : null;
  }
  normalizeState(state) {
    if (state === "done") return "done";
    if (state === "running" || state === "paused") return "running";
    return "idle";
  }
  getStatePriority(state) {
    const normalized = this.normalizeState(state);
    if (normalized === "done") return 0;
    if (normalized === "running") return 1;
    return 2;
  }
  setupCalendarButton(calendarBtn, dateLabel) {
    calendarBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      const oldInput = document.getElementById("calendar-date-input");
      if (oldInput) oldInput.remove();
      const input = document.createElement("input");
      input.type = "date";
      input.id = "calendar-date-input";
      input.classList.add("taskchute-input-absolute");
      input.style.left = `${calendarBtn.getBoundingClientRect().left}px`;
      input.style.top = `${calendarBtn.getBoundingClientRect().top - 900}px`;
      input.style.zIndex = "10000";
      const y = this.currentDate.getFullYear();
      const m = (this.currentDate.getMonth() + 1).toString().padStart(2, "0");
      const d = this.currentDate.getDate().toString().padStart(2, "0");
      input.value = `${y}-${m}-${d}`;
      document.body.appendChild(input);
      setTimeout(() => {
        try {
          input.focus();
          input.click();
          if (input.showPicker && typeof input.showPicker === "function") {
            input.showPicker();
          } else {
            const mouseEvent = new MouseEvent("mousedown", {
              view: window,
              bubbles: true,
              cancelable: true
            });
            input.dispatchEvent(mouseEvent);
          }
        } catch (e2) {
        }
      }, 50);
      input.addEventListener("change", async () => {
        const [yy, mm, dd] = input.value.split("-").map(Number);
        this.currentDate = new Date(yy, mm - 1, dd);
        this.updateDateLabel(dateLabel);
        await this.reloadTasksAndRestore({ runBoundaryCheck: true });
        input.remove();
      });
      input.addEventListener("blur", () => input.remove());
    });
  }
  // ===========================================
  // Task Loading and Rendering Methods
  // ===========================================
  async loadTasks() {
    await this.ensureDayStateForCurrentDate();
    await loadTasksRefactored.call(this);
  }
  async processTaskFile(file) {
    var _a;
    try {
      const content = await this.app.vault.read(file);
      const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if (!content.includes("#task") && !(frontmatter == null ? void 0 : frontmatter.estimatedMinutes)) {
        return;
      }
      const taskData = {
        file,
        frontmatter: frontmatter || {},
        path: file.path,
        name: file.basename,
        project: frontmatter == null ? void 0 : frontmatter.project,
        isRoutine: (frontmatter == null ? void 0 : frontmatter.isRoutine) === true,
        routine_type: frontmatter == null ? void 0 : frontmatter.routine_type,
        routine_start: frontmatter == null ? void 0 : frontmatter.routine_start,
        routine_end: frontmatter == null ? void 0 : frontmatter.routine_end,
        routine_week: frontmatter == null ? void 0 : frontmatter.routine_week,
        routine_day: frontmatter == null ? void 0 : frontmatter.routine_day,
        flexible_schedule: frontmatter == null ? void 0 : frontmatter.flexible_schedule
      };
      this.tasks.push(taskData);
    } catch (error) {
      console.error(`Failed to process task file ${file.path}:`, error);
    }
  }
  async loadTaskInstances() {
    const dateStr = this.getCurrentDateString();
    for (const task of this.tasks) {
      if (!this.shouldShowTaskForDate(task, this.currentDate)) {
        continue;
      }
      const instance = {
        task,
        instanceId: this.generateInstanceId(task, dateStr),
        state: "idle",
        slotKey: this.getTaskSlotKey(task),
        date: dateStr
      };
      if (this.isInstanceDeleted(instance.instanceId, task.path, dateStr) || this.isInstanceHidden(instance.instanceId, task.path, dateStr)) {
        continue;
      }
      this.loadInstanceState(instance, dateStr);
      this.taskInstances.push(instance);
    }
  }
  shouldShowTaskForDate(task, date) {
    if (!task.isRoutine) {
      return true;
    }
    const dayOfWeek = date.getDay();
    switch (task.routine_type) {
      case "daily":
        return true;
      case "weekdays":
        return dayOfWeek >= 1 && dayOfWeek <= 5;
      // Monday to Friday
      case "weekends":
        return dayOfWeek === 0 || dayOfWeek === 6;
      // Saturday and Sunday
      case "weekly":
        return true;
      // Simplified for now
      case "monthly":
        return true;
      // Simplified for now
      default:
        return true;
    }
  }
  generateInstanceId(task, dateStr) {
    return `${task.path}_${dateStr}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  getTaskSlotKey(task) {
    var _a;
    const storedSlot = (_a = this.plugin.settings.slotKeys) == null ? void 0 : _a[task.path];
    if (storedSlot) {
      return storedSlot;
    }
    return "none";
  }
  loadInstanceState(instance, dateStr) {
    const stateKey = `taskchute-instance-state-${instance.instanceId}`;
    const savedState = localStorage.getItem(stateKey);
    if (savedState) {
      try {
        const parsed = JSON.parse(savedState);
        instance.state = parsed.state || "idle";
        instance.startTime = parsed.startTime ? new Date(parsed.startTime) : void 0;
        instance.stopTime = parsed.stopTime ? new Date(parsed.stopTime) : void 0;
        instance.pausedDuration = parsed.pausedDuration || 0;
        instance.actualMinutes = parsed.actualMinutes;
        instance.comment = parsed.comment;
        instance.focusLevel = parsed.focusLevel;
        instance.energyLevel = parsed.energyLevel;
      } catch (error) {
        console.error("Failed to parse instance state:", error);
      }
    }
  }
  // ===========================================
  // Task Rendering Methods
  // ===========================================
  renderTaskList() {
    const scrollTop = this.taskList.scrollTop;
    const scrollLeft = this.taskList.scrollLeft;
    this.applyResponsiveClasses();
    this.sortTaskInstancesByTimeOrder();
    this.taskList.empty();
    const timeSlots = {};
    this.getTimeSlotKeys().forEach((slot) => {
      timeSlots[slot] = [];
    });
    let noTimeInstances = [];
    this.taskInstances.forEach((inst) => {
      if (inst.slotKey && inst.slotKey !== "none") {
        if (!timeSlots[inst.slotKey]) {
          timeSlots[inst.slotKey] = [];
        }
        timeSlots[inst.slotKey].push(inst);
      } else {
        noTimeInstances.push(inst);
      }
    });
    this.renderNoTimeGroup(noTimeInstances);
    this.getTimeSlotKeys().forEach((slot) => {
      const instancesInSlot = timeSlots[slot];
      this.renderTimeSlotGroup(slot, instancesInSlot);
    });
    this.taskList.scrollTop = scrollTop;
    this.taskList.scrollLeft = scrollLeft;
    this.updateTotalTasksCount();
  }
  renderNoTimeGroup(instances) {
    const noTimeHeader = this.taskList.createEl("div", {
      cls: "time-slot-header other",
      text: "\u6642\u9593\u6307\u5B9A\u306A\u3057"
    });
    this.setupTimeSlotDragHandlers(noTimeHeader, "none");
    const sortedInstances = this.sortByOrder(instances);
    sortedInstances.forEach((inst, idx) => {
      this.createTaskInstanceItem(inst, "none", idx);
    });
  }
  renderTimeSlotGroup(slot, instances) {
    const timeSlotHeader = this.taskList.createEl("div", {
      cls: "time-slot-header",
      text: slot
    });
    this.setupTimeSlotDragHandlers(timeSlotHeader, slot);
    const sortedInstances = this.sortByOrder(instances);
    sortedInstances.forEach((inst, idx) => {
      this.createTaskInstanceItem(inst, slot, idx);
    });
  }
  createTaskInstanceItem(inst, slot, idx) {
    const taskItem = this.taskList.createEl("div", { cls: "task-item" });
    if (inst.task.path) {
      taskItem.setAttribute("data-task-path", inst.task.path);
    }
    if (inst.instanceId) {
      taskItem.setAttribute("data-instance-id", inst.instanceId);
    }
    taskItem.setAttribute("data-slot", slot || "none");
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const viewDate = new Date(this.currentDate);
    viewDate.setHours(0, 0, 0, 0);
    const isFutureTask = viewDate > today;
    if (inst.state === "done") {
      taskItem.classList.add("completed");
    }
    this.createDragHandle(taskItem, inst, slot, idx);
    this.createPlayStopButton(taskItem, inst, isFutureTask);
    this.createTaskName(taskItem, inst);
    this.createProjectDisplay(taskItem, inst);
    this.createTimeRangeDisplay(taskItem, inst);
    this.createDurationTimerDisplay(taskItem, inst);
    this.createCommentButton(taskItem, inst);
    this.createRoutineButton(taskItem, inst);
    this.createSettingsButton(taskItem, inst);
    this.setupTaskItemEventListeners(taskItem, inst);
  }
  createDragHandle(taskItem, inst, slot, idx) {
    const isDraggable = inst.state !== "done";
    const dragHandle = taskItem.createEl("div", {
      cls: "drag-handle",
      attr: isDraggable ? { draggable: "true", title: "\u30C9\u30E9\u30C3\u30B0\u3057\u3066\u79FB\u52D5" } : { title: "\u5B8C\u4E86\u6E08\u307F\u30BF\u30B9\u30AF" }
    });
    if (!isDraggable) {
      dragHandle.classList.add("disabled");
    }
    const svg = dragHandle.createSvg("svg", {
      attr: {
        width: "10",
        height: "16",
        viewBox: "0 0 10 16",
        fill: "currentColor"
      }
    });
    svg.createSvg("circle", { attr: { cx: "2", cy: "2", r: "1.5" } });
    svg.createSvg("circle", { attr: { cx: "8", cy: "2", r: "1.5" } });
    svg.createSvg("circle", { attr: { cx: "2", cy: "8", r: "1.5" } });
    svg.createSvg("circle", { attr: { cx: "8", cy: "8", r: "1.5" } });
    svg.createSvg("circle", { attr: { cx: "2", cy: "14", r: "1.5" } });
    svg.createSvg("circle", { attr: { cx: "8", cy: "14", r: "1.5" } });
    if (isDraggable) {
      this.setupDragEvents(dragHandle, taskItem, slot, idx);
    }
    dragHandle.addEventListener("click", (e) => {
      e.stopPropagation();
      this.selectTaskForKeyboard(inst, taskItem);
    });
  }
  createPlayStopButton(taskItem, inst, isFutureTask) {
    let btnCls = "play-stop-button";
    let btnText = "\u25B6\uFE0F";
    let btnTitle = "\u30B9\u30BF\u30FC\u30C8";
    if (isFutureTask) {
      btnCls += " future-task-button";
      btnText = "\u2014";
      btnTitle = "\u672A\u6765\u306E\u30BF\u30B9\u30AF\u306F\u5B9F\u884C\u3067\u304D\u307E\u305B\u3093";
    } else if (inst.state === "running") {
      btnCls += " stop";
      btnText = "\u23F9";
      btnTitle = "\u30B9\u30C8\u30C3\u30D7";
    } else if (inst.state === "done") {
      btnText = "\u2611\uFE0F";
      btnTitle = "\u5B8C\u4E86\u30BF\u30B9\u30AF\u3092\u518D\u8A08\u6E2C";
    }
    const playButton = taskItem.createEl("button", {
      cls: btnCls,
      text: btnText,
      attr: { title: btnTitle }
    });
    if (isFutureTask) {
      playButton.disabled = true;
    }
    playButton.addEventListener("click", async (e) => {
      e.stopPropagation();
      if (isFutureTask) {
        new import_obsidian11.Notice("\u672A\u6765\u306E\u30BF\u30B9\u30AF\u306F\u5B9F\u884C\u3067\u304D\u307E\u305B\u3093\u3002", 2e3);
        return;
      }
      if (inst.state === "running") {
        await this.stopInstance(inst);
      } else if (inst.state === "idle") {
        await this.startInstance(inst);
      } else if (inst.state === "done") {
        await this.duplicateAndStartInstance(inst);
      }
    });
  }
  createTaskName(taskItem, inst) {
    const taskName = taskItem.createEl("span", {
      cls: "task-name",
      text: inst.task.name
    });
    taskName.style.color = "var(--text-accent)";
    taskName.addEventListener("click", async (e) => {
      e.stopPropagation();
      try {
        await this.app.workspace.openLinkText(inst.task.path, "", false);
      } catch (error) {
        new import_obsidian11.Notice("\u30BF\u30B9\u30AF\u30D5\u30A1\u30A4\u30EB\u3092\u958B\u3051\u307E\u305B\u3093\u3067\u3057\u305F");
      }
    });
  }
  createProjectDisplay(taskItem, inst) {
    const projectDisplay = taskItem.createEl("span", {
      cls: "taskchute-project-display"
    });
    if (inst.task.projectPath && inst.task.projectTitle) {
      const projectButton = projectDisplay.createEl("span", {
        cls: "taskchute-project-button",
        attr: {
          title: `\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8: ${inst.task.projectTitle}`
        }
      });
      const folderIcon = projectButton.createEl("span", {
        cls: "taskchute-project-icon",
        text: "\u{1F4C1}"
      });
      const projectName = projectButton.createEl("span", {
        cls: "taskchute-project-name",
        text: inst.task.projectTitle.replace(/^Project\s*-\s*/, "")
      });
      projectButton.addEventListener("click", async (e) => {
        e.stopPropagation();
        await this.showUnifiedProjectModal(inst);
      });
      const externalLinkIcon = projectDisplay.createEl("span", {
        cls: "taskchute-external-link",
        text: "\u{1F517}",
        attr: { title: "\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30CE\u30FC\u30C8\u3092\u958B\u304F" }
      });
      externalLinkIcon.addEventListener("click", async (e) => {
        e.stopPropagation();
        await this.openProjectInSplit(inst.task.projectPath);
      });
    } else {
      const projectPlaceholder = projectDisplay.createEl("span", {
        cls: "taskchute-project-placeholder",
        attr: { title: "\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3092\u8A2D\u5B9A" }
      });
      projectPlaceholder.addEventListener("click", async (e) => {
        e.stopPropagation();
        await this.showProjectModal(inst);
      });
    }
  }
  createTimeRangeDisplay(taskItem, inst) {
    const timeRangeEl = taskItem.createEl("span", {
      cls: "task-time-range"
    });
    const formatTime = (date) => date ? date.toLocaleTimeString("ja-JP", {
      hour: "2-digit",
      minute: "2-digit"
    }) : "";
    if (inst.state === "running" && inst.startTime) {
      timeRangeEl.textContent = `${formatTime(inst.startTime)} \u2192`;
      timeRangeEl.classList.add("editable");
      timeRangeEl.addEventListener("click", (e) => {
        e.stopPropagation();
        this.showTimeEditModal(inst);
      });
    } else if (inst.state === "done" && inst.startTime && inst.stopTime) {
      timeRangeEl.textContent = `${formatTime(inst.startTime)} \u2192 ${formatTime(inst.stopTime)}`;
      timeRangeEl.classList.add("editable");
      timeRangeEl.addEventListener("click", (e) => {
        e.stopPropagation();
        this.showTimeEditModal(inst);
      });
    } else {
      timeRangeEl.textContent = "";
    }
  }
  createDurationTimerDisplay(taskItem, inst) {
    if (inst.state === "done" && inst.startTime && inst.stopTime) {
      const durationEl = taskItem.createEl("span", {
        cls: "task-duration"
      });
      const duration = this.calculateCrossDayDuration(inst.startTime, inst.stopTime);
      const hours = Math.floor(duration / 36e5);
      const minutes = Math.floor(duration % 36e5 / 6e4) % 60;
      const durationStr = `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}`;
      durationEl.textContent = durationStr;
      if (inst.startTime.getDate() !== inst.stopTime.getDate()) {
        durationEl.setAttribute("title", "\u65E5\u3092\u8DE8\u3044\u3060\u30BF\u30B9\u30AF");
      }
    } else if (inst.state === "running") {
      const timerEl = taskItem.createEl("span", {
        cls: "task-timer-display"
      });
      this.updateTimerDisplay(timerEl, inst);
    } else {
      taskItem.createEl("span", {
        cls: "task-duration-placeholder"
      });
    }
  }
  createCommentButton(taskItem, inst) {
    const commentButton = taskItem.createEl("button", {
      cls: "comment-button",
      text: "\u{1F4AC}",
      attr: {
        "data-task-state": inst.state
      }
    });
    if (inst.state !== "done") {
      commentButton.classList.add("disabled");
      commentButton.setAttribute("disabled", "true");
    }
    commentButton.addEventListener("click", async (e) => {
      e.stopPropagation();
      if (inst.state !== "done") {
        return;
      }
      await this.showTaskCompletionModal(inst);
    });
    this.hasCommentData(inst).then((hasComment) => {
      if (hasComment) {
        commentButton.classList.add("active");
      } else {
        commentButton.classList.remove("active");
        if (inst.state === "done") {
          commentButton.classList.add("no-comment");
        }
      }
    });
  }
  createRoutineButton(taskItem, inst) {
    const routineButton = taskItem.createEl("button", {
      cls: `routine-button ${inst.task.isRoutine ? "active" : ""}`,
      text: "\u{1F504}",
      attr: {
        title: inst.task.isRoutine ? `\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF` : "\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306B\u8A2D\u5B9A"
      }
    });
    routineButton.addEventListener("click", (e) => {
      e.stopPropagation();
      if (inst.task.isRoutine) {
        this.showRoutineEditModal(inst.task, routineButton);
      } else {
        this.toggleRoutine(inst.task, routineButton);
      }
    });
  }
  createSettingsButton(taskItem, inst) {
    const settingsButton = taskItem.createEl("button", {
      cls: "settings-task-button",
      text: "\u2699\uFE0F",
      attr: { title: "\u30BF\u30B9\u30AF\u8A2D\u5B9A" }
    });
    settingsButton.addEventListener("click", (e) => {
      e.stopPropagation();
      this.showTaskSettingsTooltip(inst, settingsButton);
    });
  }
  // ===========================================
  // Missing Method Placeholders
  // ===========================================
  async duplicateAndStartInstance(inst) {
    const newInst = await this.duplicateInstance(
      inst,
      /*returnOnly*/
      true
    );
    if (!newInst) return;
    this.renderTaskList();
    await this.startInstance(newInst);
    this.renderTaskList();
  }
  async duplicateInstance(inst, returnOnly = false) {
    try {
      await this.ensureDayStateForCurrentDate();
      const dateStr = this.getCurrentDateString();
      const newInstance = {
        task: inst.task,
        instanceId: this.generateInstanceId(inst.task, dateStr),
        state: "idle",
        // 重要: 複製は元タスクのスロットの直下に入れる
        slotKey: inst.slotKey,
        originalSlotKey: inst.slotKey,
        startTime: void 0,
        stopTime: void 0
      };
      this.calculateDuplicateTaskOrder(newInstance, inst);
      this.taskInstances.push(newInstance);
      this.saveInstanceState(newInstance);
      const dayState = this.getCurrentDayState();
      if (!dayState.duplicatedInstances.some((d) => d.instanceId === newInstance.instanceId)) {
        dayState.duplicatedInstances.push({
          instanceId: newInstance.instanceId,
          originalPath: inst.task.path,
          slotKey: newInstance.slotKey,
          originalSlotKey: inst.slotKey,
          timestamp: Date.now()
        });
        await this.persistDayState(dateStr);
      }
      this.renderTaskList();
      new import_obsidian11.Notice(`\u300C${inst.task.title}\u300D\u3092\u8907\u88FD\u3057\u307E\u3057\u305F`);
      return returnOnly ? newInstance : void 0;
    } catch (error) {
      console.error("Failed to duplicate instance:", error);
      new import_obsidian11.Notice("\u30BF\u30B9\u30AF\u306E\u8907\u88FD\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  // 元直下に挿入されるよう order を計算
  calculateDuplicateTaskOrder(newInst, originalInst) {
    var _a;
    try {
      const slot = originalInst.slotKey || "none";
      const normalizedState = this.normalizeState(originalInst.state);
      const sameState = this.taskInstances.filter(
        (inst) => inst !== newInst && (inst.slotKey || "none") === slot && this.normalizeState(inst.state) === normalizedState
      );
      const sortedSameState = [...sameState].sort((a, b) => {
        var _a2, _b;
        return ((_a2 = a.order) != null ? _a2 : 0) - ((_b = b.order) != null ? _b : 0);
      });
      const originalIndex = sortedSameState.indexOf(originalInst);
      const insertIndex = originalIndex >= 0 ? originalIndex + 1 : sortedSameState.length;
      newInst.slotKey = slot;
      newInst.order = this.calculateSimpleOrder(insertIndex, sameState);
    } catch (_) {
      newInst.order = ((_a = originalInst.order) != null ? _a : 0) + 100;
    }
  }
  normalizeOrdersForDrag(instances) {
    if (!instances || instances.length === 0) {
      return;
    }
    const sorted = [...instances].sort((a, b) => {
      var _a, _b;
      const orderA = Number.isFinite(a.order) ? a.order : Number.MAX_SAFE_INTEGER;
      const orderB = Number.isFinite(b.order) ? b.order : Number.MAX_SAFE_INTEGER;
      if (orderA === orderB) {
        return (((_a = a.task) == null ? void 0 : _a.title) || "").localeCompare(((_b = b.task) == null ? void 0 : _b.title) || "");
      }
      return orderA - orderB;
    });
    let cursor = 100;
    sorted.forEach((inst) => {
      inst.order = cursor;
      cursor += 100;
    });
  }
  calculateSimpleOrder(targetIndex, sameTasks) {
    var _a, _b;
    if (!sameTasks || sameTasks.length === 0) {
      return 100;
    }
    const working = [...sameTasks];
    const needsSeed = working.some((inst) => !Number.isFinite(inst.order));
    if (needsSeed) {
      this.normalizeOrdersForDrag(working);
    }
    const sorted = working.sort((a, b) => a.order - b.order);
    const clampedIndex = Math.min(Math.max(targetIndex, 0), sorted.length);
    if (clampedIndex <= 0) {
      const firstOrder = sorted[0].order;
      const result = Number.isFinite(firstOrder) ? firstOrder - 100 : 100;
      return result;
    }
    if (clampedIndex >= sorted.length) {
      const lastOrder = sorted[sorted.length - 1].order;
      const result = Number.isFinite(lastOrder) ? lastOrder + 100 : (sorted.length + 1) * 100;
      return result;
    }
    const prevOrder = sorted[clampedIndex - 1].order;
    const nextOrder = sorted[clampedIndex].order;
    if (!Number.isFinite(prevOrder) || !Number.isFinite(nextOrder) || nextOrder - prevOrder <= 1) {
      this.normalizeOrdersForDrag(working);
      working.sort((a, b) => a.order - b.order);
      const normalizedPrev = (_a = working[clampedIndex - 1]) == null ? void 0 : _a.order;
      const normalizedNext = (_b = working[clampedIndex]) == null ? void 0 : _b.order;
      return Math.floor(((normalizedPrev != null ? normalizedPrev : 0) + (normalizedNext != null ? normalizedNext : (normalizedPrev != null ? normalizedPrev : 0) + 100)) / 2);
    }
    return Math.floor((prevOrder + nextOrder) / 2);
  }
  async showTaskCompletionModal(inst) {
    const existingComment = await this.getExistingTaskComment(inst);
    const modal = document.createElement("div");
    modal.className = "taskchute-comment-modal";
    const modalContent = modal.createEl("div", {
      cls: "taskchute-comment-content"
    });
    const header = modalContent.createEl("div", { cls: "taskchute-modal-header" });
    const headerText = existingComment ? `\u270F\uFE0F \u300C${inst.task.title}\u300D\u306E\u30B3\u30E1\u30F3\u30C8\u3092\u7DE8\u96C6` : `\u{1F389} \u304A\u75B2\u308C\u69D8\u3067\u3057\u305F\uFF01\u300C${inst.task.title}\u300D\u304C\u5B8C\u4E86\u3057\u307E\u3057\u305F`;
    header.createEl("h2", { text: headerText });
    if (inst.state === "done" && inst.actualTime) {
      const timeInfo = modalContent.createEl("div", { cls: "taskchute-time-info" });
      const duration = this.formatTime(inst.actualTime);
      const startTime = inst.startTime ? new Date(inst.startTime).toLocaleTimeString("ja-JP", { hour: "2-digit", minute: "2-digit" }) : "";
      const endTime = inst.stopTime ? new Date(inst.stopTime).toLocaleTimeString("ja-JP", { hour: "2-digit", minute: "2-digit" }) : "";
      timeInfo.createEl("div", {
        text: `\u5B9F\u884C\u6642\u9593: ${duration}`,
        cls: "time-duration"
      });
      if (startTime && endTime) {
        timeInfo.createEl("div", {
          text: `\u958B\u59CB: ${startTime} \u7D42\u4E86: ${endTime}`,
          cls: "time-range"
        });
      }
    }
    const ratingSection = modalContent.createEl("div", { cls: "taskchute-rating-section" });
    ratingSection.createEl("h3", { text: "\u4ECA\u56DE\u306E\u30BF\u30B9\u30AF\u306F\u3044\u304B\u304C\u3067\u3057\u305F\u304B\uFF1F" });
    const focusGroup = ratingSection.createEl("div", { cls: "rating-group" });
    focusGroup.createEl("label", { text: "\u96C6\u4E2D\u5EA6:", cls: "rating-label" });
    const initialFocusRating = (existingComment == null ? void 0 : existingComment.focusLevel) || 0;
    const focusRating = focusGroup.createEl("div", {
      cls: "star-rating",
      attr: { "data-rating": initialFocusRating.toString() }
    });
    for (let i = 1; i <= 5; i++) {
      const star = focusRating.createEl("span", {
        cls: `star ${i <= initialFocusRating ? "taskchute-star-filled" : "taskchute-star-empty"}`,
        text: "\u2B50"
      });
      star.addEventListener("click", () => {
        this.setRating(focusRating, i);
      });
      star.addEventListener("mouseenter", () => {
        this.highlightRating(focusRating, i);
      });
      star.addEventListener("mouseleave", () => {
        this.resetRatingHighlight(focusRating);
      });
    }
    this.updateRatingDisplay(focusRating, initialFocusRating);
    const energyGroup = ratingSection.createEl("div", { cls: "rating-group" });
    energyGroup.createEl("label", { text: "\u5143\u6C17\u5EA6:", cls: "rating-label" });
    const initialEnergyRating = (existingComment == null ? void 0 : existingComment.energyLevel) || 0;
    const energyRating = energyGroup.createEl("div", {
      cls: "star-rating",
      attr: { "data-rating": initialEnergyRating.toString() }
    });
    for (let i = 1; i <= 5; i++) {
      const star = energyRating.createEl("span", {
        cls: `star ${i <= initialEnergyRating ? "taskchute-star-filled" : "taskchute-star-empty"}`,
        text: "\u2B50"
      });
      star.addEventListener("click", () => {
        this.setRating(energyRating, i);
      });
      star.addEventListener("mouseenter", () => {
        this.highlightRating(energyRating, i);
      });
      star.addEventListener("mouseleave", () => {
        this.resetRatingHighlight(energyRating);
      });
    }
    this.updateRatingDisplay(energyRating, initialEnergyRating);
    const commentSection = modalContent.createEl("div", { cls: "taskchute-comment-section" });
    commentSection.createEl("label", { text: "\u611F\u60F3\u30FB\u5B66\u3073\u30FB\u6B21\u56DE\u3078\u306E\u6539\u5584\u70B9:", cls: "comment-label" });
    const commentInput = commentSection.createEl("textarea", {
      cls: "taskchute-comment-textarea",
      placeholder: "\u4ECA\u56DE\u306E\u30BF\u30B9\u30AF\u3067\u611F\u3058\u305F\u3053\u3068\u3001\u5B66\u3093\u3060\u3053\u3068\u3001\u6B21\u56DE\u3078\u306E\u6539\u5584\u70B9\u306A\u3069\u3092\u81EA\u7531\u306B\u304A\u66F8\u304D\u304F\u3060\u3055\u3044..."
    });
    if (existingComment == null ? void 0 : existingComment.executionComment) {
      commentInput.value = existingComment.executionComment;
    }
    const buttonGroup = modalContent.createEl("div", { cls: "taskchute-comment-actions" });
    const cancelButton = buttonGroup.createEl("button", {
      type: "button",
      cls: "taskchute-button-cancel",
      text: "\u30AD\u30E3\u30F3\u30BB\u30EB"
    });
    const saveButton = buttonGroup.createEl("button", {
      type: "button",
      cls: "taskchute-button-save",
      text: "\u4FDD\u5B58"
    });
    const closeModal = () => {
      document.body.removeChild(modal);
    };
    const handleEsc = (e) => {
      if (e.key === "Escape") {
        closeModal();
        document.removeEventListener("keydown", handleEsc);
      }
    };
    document.addEventListener("keydown", handleEsc);
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        closeModal();
      }
    });
    cancelButton.addEventListener("click", closeModal);
    saveButton.addEventListener("click", async () => {
      const focusValue = parseInt(focusRating.getAttribute("data-rating") || "0");
      const energyValue = parseInt(energyRating.getAttribute("data-rating") || "0");
      await this.saveTaskComment(inst, {
        comment: commentInput.value,
        energy: energyValue,
        focus: focusValue,
        focusLevel: focusValue,
        // 新形式との互換性
        energyLevel: energyValue,
        // 新形式との互換性
        executionComment: commentInput.value,
        // 新形式との互換性
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
      closeModal();
      this.renderTaskList();
    });
    document.body.appendChild(modal);
    commentInput.focus();
  }
  // 星評価ヘルパー関数
  setRating(ratingEl, value) {
    ratingEl.setAttribute("data-rating", value.toString());
    this.updateRatingDisplay(ratingEl, value);
  }
  highlightRating(ratingEl, value) {
    this.updateRatingDisplay(ratingEl, value);
  }
  resetRatingHighlight(ratingEl) {
    const currentRating = parseInt(ratingEl.getAttribute("data-rating") || "0");
    this.updateRatingDisplay(ratingEl, currentRating);
  }
  updateRatingDisplay(ratingEl, value) {
    const stars = ratingEl.querySelectorAll(".star");
    stars.forEach((star, index) => {
      if (index < value) {
        star.classList.add("taskchute-star-filled");
        star.classList.remove("taskchute-star-empty");
      } else {
        star.classList.add("taskchute-star-empty");
        star.classList.remove("taskchute-star-filled");
      }
    });
  }
  // 10段階を5段階に変換
  convertToFiveScale(value) {
    if (value === 0) return 0;
    if (value > 5) return Math.ceil(value / 2);
    return value;
  }
  async hasCommentData(inst) {
    try {
      const existingComment = await this.getExistingTaskComment(inst);
      if (!existingComment) {
        return false;
      }
      return existingComment.executionComment && existingComment.executionComment.trim().length > 0 || existingComment.focusLevel > 0 || existingComment.energyLevel > 0;
    } catch (error) {
      return false;
    }
  }
  async getExistingTaskComment(inst) {
    var _a;
    try {
      if (!inst.instanceId) {
        return null;
      }
      const currentDate = this.currentDate;
      const year = currentDate.getFullYear();
      const month = (currentDate.getMonth() + 1).toString().padStart(2, "0");
      const day = currentDate.getDate().toString().padStart(2, "0");
      const monthString = `${year}-${month}`;
      const logDataPath = this.plugin.pathManager.getLogDataPath();
      const logFilePath = `${logDataPath}/${monthString}-tasks.json`;
      const logFile = this.app.vault.getAbstractFileByPath(logFilePath);
      if (!logFile || !(logFile instanceof import_obsidian11.TFile)) {
        return null;
      }
      const logContent = await this.app.vault.read(logFile);
      const monthlyLog = JSON.parse(logContent);
      const dateString = `${year}-${month}-${day}`;
      const todayTasks = ((_a = monthlyLog.taskExecutions) == null ? void 0 : _a[dateString]) || [];
      const existingEntry = todayTasks.find(
        (entry) => entry.instanceId === inst.instanceId
      );
      return existingEntry || null;
    } catch (error) {
      return null;
    }
  }
  async saveTaskComment(inst, data) {
    var _a, _b, _c, _d, _e, _f;
    try {
      if (!inst.instanceId) {
        throw new Error("instanceId is required");
      }
      const currentDate = this.currentDate;
      const year = currentDate.getFullYear();
      const month = (currentDate.getMonth() + 1).toString().padStart(2, "0");
      const day = currentDate.getDate().toString().padStart(2, "0");
      const monthString = `${year}-${month}`;
      const logDataPath = this.plugin.pathManager.getLogDataPath();
      const logFilePath = `${logDataPath}/${monthString}-tasks.json`;
      const dateString = `${year}-${month}-${day}`;
      const logFile = this.app.vault.getAbstractFileByPath(logFilePath);
      let monthlyLog = { taskExecutions: {} };
      if (logFile && logFile instanceof import_obsidian11.TFile) {
        const logContent = await this.app.vault.read(logFile);
        monthlyLog = JSON.parse(logContent);
      }
      if (!monthlyLog.taskExecutions) {
        monthlyLog.taskExecutions = {};
      }
      if (!monthlyLog.taskExecutions[dateString]) {
        monthlyLog.taskExecutions[dateString] = [];
      }
      const todayTasks = monthlyLog.taskExecutions[dateString];
      const existingIndex = todayTasks.findIndex(
        (entry) => entry.instanceId === inst.instanceId
      );
      const existingTaskData = existingIndex >= 0 ? { ...todayTasks[existingIndex] } : null;
      const pad = (n) => String(n).padStart(2, "0");
      const toHMS = (d) => d ? `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}` : "";
      const durationSec = inst.startTime && inst.stopTime ? Math.floor(this.calculateCrossDayDuration(inst.startTime, inst.stopTime) / 1e3) : 0;
      const commentData = {
        instanceId: inst.instanceId,
        taskPath: ((_a = inst.task) == null ? void 0 : _a.path) || "",
        taskName: ((_b = inst.task) == null ? void 0 : _b.name) || "",
        startTime: toHMS(inst.startTime),
        stopTime: toHMS(inst.stopTime),
        duration: durationSec,
        executionComment: (data.comment || "").trim(),
        focusLevel: data.focus || 0,
        energyLevel: data.energy || 0,
        isCompleted: inst.state === "done",
        project_path: ((_c = inst.task) == null ? void 0 : _c.projectPath) || null,
        project: ((_d = inst.task) == null ? void 0 : _d.projectTitle) ? `[[${inst.task.projectTitle}]]` : null,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
      if (existingIndex >= 0) {
        todayTasks[existingIndex] = {
          ...todayTasks[existingIndex],
          // 変化しうるフィールドのみ更新
          executionComment: commentData.executionComment,
          focusLevel: commentData.focusLevel,
          energyLevel: commentData.energyLevel,
          startTime: commentData.startTime || todayTasks[existingIndex].startTime,
          stopTime: commentData.stopTime || todayTasks[existingIndex].stopTime,
          duration: durationSec || todayTasks[existingIndex].duration,
          isCompleted: commentData.isCompleted,
          project_path: (_e = commentData.project_path) != null ? _e : todayTasks[existingIndex].project_path,
          project: (_f = commentData.project) != null ? _f : todayTasks[existingIndex].project,
          lastCommentUpdate: (/* @__PURE__ */ new Date()).toISOString(),
          timestamp: commentData.timestamp
        };
      } else {
        todayTasks.push(commentData);
      }
      if (logFile && logFile instanceof import_obsidian11.TFile) {
        await this.app.vault.modify(logFile, JSON.stringify(monthlyLog, null, 2));
      } else {
        await this.app.vault.create(logFilePath, JSON.stringify(monthlyLog, null, 2));
      }
      const completionData = {
        executionComment: (data.comment || "").trim(),
        focusLevel: data.focus,
        energyLevel: data.energy
      };
      if (completionData.executionComment && (inst.task.projectPath || inst.task.projectTitle) && this.hasCommentChanged(existingTaskData, completionData)) {
        await this.syncCommentToProjectNote(inst, completionData);
      }
      new import_obsidian11.Notice("\u30B3\u30E1\u30F3\u30C8\u3092\u4FDD\u5B58\u3057\u307E\u3057\u305F");
    } catch (error) {
      console.error("Failed to save comment:", error);
      new import_obsidian11.Notice("\u30B3\u30E1\u30F3\u30C8\u306E\u4FDD\u5B58\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  // コメント本文の変更検出
  hasCommentChanged(oldData, newData) {
    var _a, _b;
    const oldComment = (_a = oldData == null ? void 0 : oldData.executionComment) != null ? _a : "";
    const newComment = (_b = newData == null ? void 0 : newData.executionComment) != null ? _b : "";
    return oldComment !== newComment;
  }
  // プロジェクトノートにコメントを同期
  async syncCommentToProjectNote(inst, completionData) {
    try {
      const syncManager = new ProjectNoteSyncManager(this.app, this.plugin.pathManager);
      const projectPath = await syncManager.getProjectNotePath(inst);
      if (!projectPath) return;
      await syncManager.updateProjectNote(projectPath, inst, completionData);
    } catch (error) {
      new import_obsidian11.Notice(`\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30CE\u30FC\u30C8\u306E\u66F4\u65B0\u306B\u5931\u6557\u3057\u307E\u3057\u305F: ${error.message || error}`);
    }
  }
  showRoutineEditModal(task, button) {
    var _a;
    const modal = document.createElement("div");
    modal.className = "task-modal-overlay";
    const modalContent = modal.createEl("div", { cls: "task-modal-content" });
    const modalHeader = modalContent.createEl("div", { cls: "modal-header" });
    modalHeader.createEl("h3", { text: `\u300C${task.title}\u300D\u306E\u30EB\u30FC\u30C1\u30F3\u8A2D\u5B9A` });
    const closeButton = modalHeader.createEl("button", {
      cls: "modal-close-button",
      text: "\xD7",
      attr: { title: "\u9589\u3058\u308B" }
    });
    const form = modalContent.createEl("form", { cls: "task-form" });
    const typeGroup = form.createEl("div", { cls: "form-group" });
    typeGroup.createEl("label", { text: "\u30EB\u30FC\u30C1\u30F3\u30BF\u30A4\u30D7:", cls: "form-label" });
    const typeSelect = typeGroup.createEl("select", {
      cls: "form-input"
    });
    const options = [
      { value: "daily", text: "\u65E5\u3054\u3068" },
      { value: "weekly", text: "\u9031\u3054\u3068\uFF08\u66DC\u65E5\u6307\u5B9A\uFF09" },
      { value: "monthly", text: "\u6708\u3054\u3068\uFF08\u66DC\u65E5\u6307\u5B9A\uFF09" }
    ];
    options.forEach((opt) => {
      const option = typeSelect.createEl("option", {
        value: opt.value,
        text: opt.text
      });
      if (task.routine_type === opt.value) {
        option.selected = true;
      }
    });
    typeSelect.value = task.routine_type === "weekly" || task.routine_type === "monthly" ? task.routine_type : "daily";
    const timeGroup = form.createEl("div", { cls: "form-group" });
    timeGroup.createEl("label", { text: "\u958B\u59CB\u4E88\u5B9A\u6642\u523B:", cls: "form-label" });
    const timeInput = timeGroup.createEl("input", {
      type: "time",
      cls: "form-input",
      value: task.scheduledTime || "09:00"
    });
    const intervalGroup = form.createEl("div", { cls: "form-group" });
    intervalGroup.createEl("label", { text: "\u9593\u9694:", cls: "form-label" });
    const intervalInput = intervalGroup.createEl("input", {
      type: "number",
      cls: "form-input",
      attr: { min: "1", step: "1" },
      value: String((_a = task.routine_interval) != null ? _a : 1)
    });
    const enabledGroup = form.createEl("div", { cls: "form-group" });
    const enabledLabel = enabledGroup.createEl("label", { text: "\u6709\u52B9:", cls: "form-label" });
    const enabledToggle = enabledGroup.createEl("input", {
      type: "checkbox"
    });
    enabledToggle.checked = task.routine_enabled !== false;
    const weeklyGroup = form.createEl("div", {
      cls: "form-group"
    });
    weeklyGroup.style.display = "none";
    weeklyGroup.createEl("label", { text: "\u66DC\u65E5\u3092\u9078\u629E:", cls: "form-label" });
    const weekdayContainer = weeklyGroup.createEl("div", { cls: "weekday-checkboxes" });
    const weekdays = [
      { value: 0, label: "\u65E5" },
      { value: 1, label: "\u6708" },
      { value: 2, label: "\u706B" },
      { value: 3, label: "\u6C34" },
      { value: 4, label: "\u6728" },
      { value: 5, label: "\u91D1" },
      { value: 6, label: "\u571F" }
    ];
    const weekdayCheckboxes = [];
    weekdays.forEach((day) => {
      const label = weekdayContainer.createEl("label", {
        cls: "weekday-checkbox-label"
      });
      const checkbox = label.createEl("input", {
        type: "checkbox",
        value: day.value.toString()
      });
      weekdayCheckboxes.push(checkbox);
      if (typeof task.weekday === "number") {
        checkbox.checked = task.weekday === day.value;
      } else if (task.weekdays && Array.isArray(task.weekdays)) {
        checkbox.checked = task.weekdays.includes(day.value);
      }
      label.createEl("span", { text: day.label });
      checkbox.addEventListener("change", () => {
        if (checkbox.checked) {
          weekdayCheckboxes.forEach((cb) => {
            if (cb !== checkbox) cb.checked = false;
          });
        }
      });
    });
    const monthlyGroup = form.createEl("div", {
      cls: "form-group"
    });
    monthlyGroup.style.display = "none";
    monthlyGroup.createEl("label", { text: "\u6708\u6B21\u8A2D\u5B9A:", cls: "form-label" });
    const monthlyContainer = monthlyGroup.createEl("div", {
      cls: "monthly-settings",
      style: "display: flex; gap: 10px; align-items: center;"
    });
    monthlyContainer.createEl("span", { text: "\u7B2C" });
    const weekSelect = monthlyContainer.createEl("select", {
      cls: "form-input",
      style: "width: 60px;"
    });
    for (let i = 1; i <= 5; i++) {
      const option = weekSelect.createEl("option", {
        value: (i - 1).toString(),
        text: i.toString()
      });
      if (task.monthly_week === i - 1) {
        option.selected = true;
      }
    }
    const lastOpt = weekSelect.createEl("option", { value: "last", text: "\u6700\u7D42" });
    if (task.monthly_week === "last") lastOpt.selected = true;
    monthlyContainer.createEl("span", { text: "\u9031\u306E" });
    const monthlyWeekdaySelect = monthlyContainer.createEl("select", {
      cls: "form-input",
      style: "width: 80px;"
    });
    weekdays.forEach((day) => {
      const option = monthlyWeekdaySelect.createEl("option", {
        value: day.value.toString(),
        text: day.label + "\u66DC\u65E5"
      });
      if (task.monthly_weekday === day.value) {
        option.selected = true;
      }
    });
    typeSelect.addEventListener("change", () => {
      const selectedType = typeSelect.value;
      weeklyGroup.style.display = "none";
      monthlyGroup.style.display = "none";
      if (selectedType === "weekly") {
        weeklyGroup.style.display = "block";
      } else if (selectedType === "monthly") {
        monthlyGroup.style.display = "block";
      }
    });
    if (typeSelect.value === "weekly") {
      weeklyGroup.style.display = "block";
    } else if (typeSelect.value === "monthly") {
      monthlyGroup.style.display = "block";
    }
    const buttonGroup = form.createEl("div", { cls: "form-button-group" });
    const cancelButton = buttonGroup.createEl("button", {
      type: "button",
      cls: "form-button cancel",
      text: "\u30AD\u30E3\u30F3\u30BB\u30EB"
    });
    const saveButton = buttonGroup.createEl("button", {
      type: "submit",
      cls: "form-button create",
      text: "\u4FDD\u5B58"
    });
    let removeButton = null;
    if (task.isRoutine) {
      removeButton = buttonGroup.createEl("button", {
        type: "button",
        cls: "form-button cancel",
        text: "\u30EB\u30FC\u30C1\u30F3\u3092\u5916\u3059"
      });
    }
    closeButton.addEventListener("click", () => {
      document.body.removeChild(modal);
    });
    cancelButton.addEventListener("click", () => {
      document.body.removeChild(modal);
    });
    if (removeButton) {
      removeButton.addEventListener("click", async (e) => {
        e.preventDefault();
        e.stopPropagation();
        await this.toggleRoutine(task, button);
        if (modal.parentNode) document.body.removeChild(modal);
      });
    }
    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      const scheduledTime = timeInput.value;
      const routineType = typeSelect.value;
      const interval = Math.max(1, parseInt(intervalInput.value || "1", 10) || 1);
      const enabled = !!enabledToggle.checked;
      if (!scheduledTime) {
        new import_obsidian11.Notice("\u958B\u59CB\u6642\u523B\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044");
        return;
      }
      if (routineType === "weekly") {
        const selectedWeekdays = weekdayCheckboxes.filter((cb) => cb.checked).map((cb) => parseInt(cb.value));
        if (selectedWeekdays.length === 0) {
          new import_obsidian11.Notice("\u66DC\u65E5\u3092\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044");
          return;
        }
      }
      await this.setRoutineTaskWithDetails(
        task,
        button,
        scheduledTime,
        routineType,
        {
          weekdays: routineType === "weekly" ? weekdayCheckboxes.filter((cb) => cb.checked).map((cb) => parseInt(cb.value)) : void 0,
          monthly_week: routineType === "monthly" ? weekSelect.value === "last" ? "last" : parseInt(weekSelect.value) : void 0,
          monthly_weekday: routineType === "monthly" ? parseInt(monthlyWeekdaySelect.value) : void 0,
          interval,
          enabled
        }
      );
      document.body.removeChild(modal);
    });
    document.body.appendChild(modal);
    timeInput.focus();
  }
  async toggleRoutine(task, button) {
    try {
      if (task.isRoutine) {
        const file = task.path && this.app.vault.getAbstractFileByPath(task.path) || null;
        if (!file || !(file instanceof import_obsidian11.TFile)) {
          const taskFolderPath = this.plugin.pathManager.getTaskFolderPath();
          const fallbackPath = `${taskFolderPath}/${task.title}.md`;
          const fb = this.app.vault.getAbstractFileByPath(fallbackPath);
          if (!fb || !(fb instanceof import_obsidian11.TFile)) {
            new import_obsidian11.Notice(`\u30BF\u30B9\u30AF\u30D5\u30A1\u30A4\u30EB\u300C${task.title}.md\u300D\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093`);
            return;
          }
          await this.app.fileManager.processFrontMatter(fb, (frontmatter) => {
            const y = this.currentDate.getFullYear();
            const m = (this.currentDate.getMonth() + 1).toString().padStart(2, "0");
            const d = this.currentDate.getDate().toString().padStart(2, "0");
            frontmatter.routine_end = `${y}-${m}-${d}`;
            frontmatter.isRoutine = false;
            delete frontmatter.\u958B\u59CB\u6642\u523B;
            return frontmatter;
          });
        } else {
          await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
            const y = this.currentDate.getFullYear();
            const m = (this.currentDate.getMonth() + 1).toString().padStart(2, "0");
            const d = this.currentDate.getDate().toString().padStart(2, "0");
            frontmatter.routine_end = `${y}-${m}-${d}`;
            frontmatter.isRoutine = false;
            delete frontmatter.\u958B\u59CB\u6642\u523B;
            return frontmatter;
          });
        }
        task.isRoutine = false;
        task.scheduledTime = null;
        button.classList.remove("active");
        button.setAttribute("title", "\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306B\u8A2D\u5B9A");
        await this.reloadTasksAndRestore();
        new import_obsidian11.Notice(`\u300C${task.title}\u300D\u3092\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u304B\u3089\u89E3\u9664\u3057\u307E\u3057\u305F`);
      } else {
        this.showRoutineEditModal(task, button);
      }
    } catch (error) {
      console.error("[TaskChute] toggleRoutine failed:", error);
      const msg = error && (error.message || String(error)) || "";
      new import_obsidian11.Notice(`\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306E\u8A2D\u5B9A\u306B\u5931\u6557\u3057\u307E\u3057\u305F: ${msg}`);
    }
  }
  showTaskSettingsTooltip(inst, button) {
    const existingTooltip = document.querySelector(".task-settings-tooltip");
    if (existingTooltip) {
      existingTooltip.remove();
    }
    const tooltip = document.createElement("div");
    tooltip.className = "task-settings-tooltip";
    const tooltipHeader = tooltip.createEl("div", {
      cls: "tooltip-header"
    });
    const closeButton = tooltipHeader.createEl("button", {
      cls: "tooltip-close-button",
      text: "\xD7",
      attr: { title: "\u9589\u3058\u308B" }
    });
    closeButton.addEventListener("click", (e) => {
      e.stopPropagation();
      tooltip.remove();
    });
    const resetItem = tooltip.createEl("div", {
      cls: "tooltip-item",
      text: "\u21A9\uFE0F \u672A\u5B9F\u884C\u306B\u623B\u3059"
    });
    if (inst.state === "idle") {
      resetItem.classList.add("disabled");
      resetItem.setAttribute("title", "\u3053\u306E\u30BF\u30B9\u30AF\u306F\u672A\u5B9F\u884C\u3067\u3059");
    } else {
      resetItem.setAttribute("title", "\u30BF\u30B9\u30AF\u3092\u5B9F\u884C\u524D\u306E\u72B6\u614B\u306B\u623B\u3057\u307E\u3059");
    }
    resetItem.addEventListener("click", async (e) => {
      e.stopPropagation();
      tooltip.remove();
      if (inst.state !== "idle") {
        await this.resetTaskToIdle(inst);
      }
    });
    const moveItem = tooltip.createEl("div", {
      cls: "tooltip-item",
      text: "\u{1F4C5} \u30BF\u30B9\u30AF\u3092\u79FB\u52D5"
    });
    moveItem.setAttribute("title", "\u30BF\u30B9\u30AF\u3092\u5225\u306E\u65E5\u4ED8\u306B\u79FB\u52D5\u3057\u307E\u3059");
    moveItem.addEventListener("click", (e) => {
      e.stopPropagation();
      tooltip.remove();
      this.showTaskMoveDatePicker(inst, button);
    });
    const duplicateItem = tooltip.createEl("div", {
      cls: "tooltip-item",
      text: "\u{1F4C4} \u30BF\u30B9\u30AF\u3092\u8907\u88FD"
    });
    duplicateItem.setAttribute("title", "\u540C\u3058\u30BF\u30B9\u30AF\u3092\u3059\u3050\u4E0B\u306B\u8FFD\u52A0\u3057\u307E\u3059");
    duplicateItem.addEventListener("click", async (e) => {
      e.stopPropagation();
      tooltip.remove();
      await this.duplicateInstance(inst);
    });
    const deleteItem = tooltip.createEl("div", {
      cls: "tooltip-item delete-item",
      text: "\u{1F5D1}\uFE0F \u30BF\u30B9\u30AF\u3092\u524A\u9664"
    });
    deleteItem.addEventListener("click", async (e) => {
      e.stopPropagation();
      tooltip.remove();
      const hasHistory = await this.hasExecutionHistory(inst.task.path);
      if (inst.task.isRoutine || hasHistory) {
        await this.deleteRoutineTask(inst);
      } else {
        await this.deleteNonRoutineTask(inst);
      }
    });
    const buttonRect = button.getBoundingClientRect();
    const windowHeight = window.innerHeight;
    const windowWidth = window.innerWidth;
    const tooltipHeight = 250;
    const tooltipWidth = 200;
    tooltip.style.position = "fixed";
    tooltip.style.zIndex = "10000";
    if (buttonRect.bottom + tooltipHeight > windowHeight) {
      tooltip.style.bottom = `${windowHeight - buttonRect.top + 5}px`;
      tooltip.style.top = "auto";
    } else {
      tooltip.style.top = `${buttonRect.bottom + 5}px`;
      tooltip.style.bottom = "auto";
    }
    if (buttonRect.left + tooltipWidth > windowWidth) {
      tooltip.style.right = `${windowWidth - buttonRect.right}px`;
      tooltip.style.left = "auto";
    } else {
      tooltip.style.left = `${buttonRect.left}px`;
      tooltip.style.right = "auto";
    }
    tooltip.style.minWidth = "180px";
    tooltip.style.maxWidth = "250px";
    document.body.appendChild(tooltip);
    const closeTooltip = (e) => {
      if (!tooltip.contains(e.target) && e.target !== button) {
        tooltip.remove();
        document.removeEventListener("click", closeTooltip);
      }
    };
    setTimeout(() => {
      document.addEventListener("click", closeTooltip);
    }, 100);
  }
  // ===========================================
  // Task State Management Methods
  // ===========================================
  async startInstance(inst) {
    try {
      const today = /* @__PURE__ */ new Date();
      today.setHours(0, 0, 0, 0);
      const viewDate = new Date(this.currentDate);
      viewDate.setHours(0, 0, 0, 0);
      if (viewDate.getTime() > today.getTime()) {
        new import_obsidian11.Notice("\u672A\u6765\u306E\u30BF\u30B9\u30AF\u306F\u5B9F\u884C\u3067\u304D\u307E\u305B\u3093\u3002", 2e3);
        return;
      }
      try {
        const currentSlot = getCurrentTimeSlot(/* @__PURE__ */ new Date());
        if (inst.slotKey !== currentSlot) {
          if (!inst.originalSlotKey) inst.originalSlotKey = inst.slotKey;
          inst.slotKey = currentSlot;
        }
      } catch (_) {
      }
      inst.state = "running";
      inst.startTime = /* @__PURE__ */ new Date();
      this.currentInstance = inst;
      try {
        if (!inst.task.isRoutine && viewDate.getTime() !== today.getTime()) {
          const file = this.app.vault.getAbstractFileByPath(inst.task.path);
          if (file instanceof import_obsidian11.TFile) {
            const y = today.getFullYear();
            const m = String(today.getMonth() + 1).padStart(2, "0");
            const d = String(today.getDate()).padStart(2, "0");
            await this.app.fileManager.processFrontMatter(file, (fm) => {
              fm.target_date = `${y}-${m}-${d}`;
              return fm;
            });
          }
        }
      } catch (_) {
      }
      this.saveInstanceState(inst);
      await this.saveRunningTasksState();
      this.renderTaskList();
      if (!this.globalTimerInterval) this.startGlobalTimer();
      new import_obsidian11.Notice(`\u958B\u59CB: ${inst.task.name}`);
    } catch (error) {
      console.error("Failed to start instance:", error);
      new import_obsidian11.Notice("\u30BF\u30B9\u30AF\u306E\u958B\u59CB\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  async stopInstance(inst) {
    var _a;
    try {
      if (inst.state !== "running") {
        return;
      }
      inst.state = "done";
      inst.stopTime = /* @__PURE__ */ new Date();
      if (inst.startTime) {
        const duration2 = this.calculateCrossDayDuration(inst.startTime, inst.stopTime);
        inst.actualMinutes = Math.floor(duration2 / (1e3 * 60));
      }
      if (this.currentInstance === inst) {
        this.currentInstance = null;
      }
      this.saveInstanceState(inst);
      const duration = Math.floor(this.calculateCrossDayDuration(inst.startTime, inst.stopTime) / 1e3);
      await this.executionLogService.saveTaskLog(inst, duration);
      await this.saveRunningTasksState();
      (_a = this.timerService) == null ? void 0 : _a.restart();
      try {
        const start = inst.startTime || /* @__PURE__ */ new Date();
        const yyyy = start.getFullYear();
        const mm = String(start.getMonth() + 1).padStart(2, "0");
        const dd = String(start.getDate()).padStart(2, "0");
        const dateStr = `${yyyy}-${mm}-${dd}`;
        const heatmap = new HeatmapService(this.plugin);
        await heatmap.updateDailyStats(dateStr);
      } catch (_) {
      }
      this.sortTaskInstancesByTimeOrder();
      await this.saveTaskOrders();
      this.renderTaskList();
      new import_obsidian11.Notice(`\u5B8C\u4E86: ${inst.task.name} (${inst.actualMinutes || 0}\u5206)`);
    } catch (error) {
      console.error("Failed to stop instance:", error);
      new import_obsidian11.Notice("\u30BF\u30B9\u30AF\u306E\u505C\u6B62\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  calculateCrossDayDuration(startTime, stopTime) {
    if (!startTime || !stopTime) return 0;
    let duration = stopTime.getTime() - startTime.getTime();
    if (duration < 0) {
      duration += 24 * 60 * 60 * 1e3;
    }
    return duration;
  }
  // ===========================================
  // Running Task Persistence Methods
  // ===========================================
  async saveRunningTasksState() {
    try {
      const runningInstances = this.taskInstances.filter((inst) => inst.state === "running");
      await this.runningTasksService.save(runningInstances);
    } catch (e) {
      console.error("[TaskChute] \u5B9F\u884C\u4E2D\u30BF\u30B9\u30AF\u306E\u4FDD\u5B58\u306B\u5931\u6557:", e);
    }
  }
  async restoreRunningTaskState() {
    try {
      const currentDateString = this.getCurrentDateString();
      const runningTasksData = await this.runningTasksService.loadForDate(currentDateString);
      if (!Array.isArray(runningTasksData) || runningTasksData.length === 0) return;
      const deletedInstances = this.getDeletedInstances(currentDateString);
      const deletedTasks = deletedInstances.filter((inst) => inst.deletionType === "permanent").map((inst) => inst.path);
      let restored = false;
      for (const runningData of runningTasksData) {
        if (runningData.date !== currentDateString) {
          continue;
        }
        if (runningData.taskPath && deletedTasks.includes(runningData.taskPath)) {
          continue;
        }
        let runningInstance = this.taskInstances.find(
          (inst) => inst.instanceId === runningData.instanceId
        );
        if (!runningInstance) {
          runningInstance = this.taskInstances.find(
            (inst) => inst.task.path === runningData.taskPath && inst.state === "idle"
          );
        }
        if (runningInstance) {
          try {
            const desiredSlot = runningData.slotKey || getCurrentTimeSlot(/* @__PURE__ */ new Date());
            if (runningInstance.slotKey !== desiredSlot) {
              if (!runningInstance.originalSlotKey) {
                runningInstance.originalSlotKey = runningInstance.slotKey;
              }
              runningInstance.slotKey = desiredSlot;
            }
          } catch (_) {
          }
          runningInstance.state = "running";
          runningInstance.startTime = new Date(runningData.startTime);
          runningInstance.stopTime = null;
          if (runningData.instanceId && runningInstance.instanceId !== runningData.instanceId) {
            runningInstance.instanceId = runningData.instanceId;
          }
          if (!runningInstance.originalSlotKey && runningData.originalSlotKey) {
            runningInstance.originalSlotKey = runningData.originalSlotKey;
          }
          this.currentInstance = runningInstance;
          restored = true;
        } else {
          const taskData = this.tasks.find((t) => t.path === runningData.taskPath);
          if (taskData) {
            const recreated = {
              task: taskData,
              instanceId: runningData.instanceId || this.generateInstanceId(taskData, currentDateString),
              state: "running",
              slotKey: runningData.slotKey || getCurrentTimeSlot(/* @__PURE__ */ new Date()),
              originalSlotKey: runningData.originalSlotKey,
              startTime: new Date(runningData.startTime),
              stopTime: null
            };
            this.taskInstances.push(recreated);
            this.currentInstance = recreated;
            restored = true;
          }
        }
      }
      if (restored) {
        this.startGlobalTimer();
        this.renderTaskList();
      }
    } catch (e) {
      console.error("[TaskChute] \u5B9F\u884C\u4E2D\u30BF\u30B9\u30AF\u306E\u5FA9\u5143\u306B\u5931\u6557:", e);
    }
  }
  saveInstanceState(inst) {
    var _a, _b;
    const stateKey = `taskchute-instance-state-${inst.instanceId}`;
    const state = {
      state: inst.state,
      startTime: (_a = inst.startTime) == null ? void 0 : _a.toISOString(),
      stopTime: (_b = inst.stopTime) == null ? void 0 : _b.toISOString(),
      pausedDuration: inst.pausedDuration,
      actualMinutes: inst.actualMinutes,
      comment: inst.comment,
      focusLevel: inst.focusLevel,
      energyLevel: inst.energyLevel
    };
    try {
      localStorage.setItem(stateKey, JSON.stringify(state));
    } catch (error) {
      console.error("Failed to save instance state:", error);
    }
  }
  // saveTaskLog moved to ExecutionLogService
  /**
   * Remove an execution log entry for the given instance on the current view date
   * and recalculate the daily summary. This is used when a completed task is
   * reverted back to idle ("未実行に戻す").
   */
  async removeTaskLogForInstanceOnCurrentDate(instanceId) {
    try {
      if (!instanceId) return;
      const dateStr = this.getCurrentDateString();
      await this.executionLogService.removeTaskLogForInstanceOnDate(instanceId, dateStr);
    } catch (e) {
      console.error("[TaskChute] removeTaskLogForInstanceOnCurrentDate failed:", e);
    }
  }
  // ===========================================
  // Timer Management Methods
  // ===========================================
  startGlobalTimer() {
    var _a;
    this.ensureTimerService();
    (_a = this.timerService) == null ? void 0 : _a.start();
  }
  updateAllTimers() {
    this.ensureTimerService();
    const running = this.taskInstances.filter((inst) => inst.state === "running");
    if (running.length === 0) {
      this.stopGlobalTimer();
      return;
    }
    running.forEach((inst) => this.onTimerTick(inst));
  }
  // ===========================================
  // Time Edit Modal (開始/終了時刻の編集)
  // ===========================================
  showTimeEditModal(inst) {
    if (!(inst.startTime && (inst.state === "running" || inst.state === "done"))) return;
    const modal = document.createElement("div");
    modal.className = "task-modal-overlay";
    const modalContent = modal.createEl("div", { cls: "task-modal-content" });
    const header = modalContent.createEl("div", { cls: "modal-header" });
    header.createEl("h3", { text: `\u300C${inst.task.title || inst.task.name}\u300D\u306E\u6642\u523B\u3092\u7DE8\u96C6` });
    const closeBtn = header.createEl("button", { cls: "modal-close-button", text: "\xD7" });
    closeBtn.addEventListener("click", () => modal.remove());
    const form = modalContent.createEl("form", { cls: "task-form" });
    const startGroup = form.createEl("div", { cls: "form-group" });
    startGroup.createEl("label", { text: "\u958B\u59CB\u6642\u523B:", cls: "form-label" });
    const pad = (n) => String(n).padStart(2, "0");
    const toHM = (d) => d ? `${pad(d.getHours())}:${pad(d.getMinutes())}` : "";
    const startInput = startGroup.createEl("input", {
      type: "time",
      cls: "form-input",
      value: toHM(inst.startTime)
    });
    const startClear = startGroup.createEl("button", { type: "button", cls: "form-button secondary", text: "\u30AF\u30EA\u30A2", attr: { style: "margin-left: 8px; padding: 4px 12px; font-size: 12px;" } });
    startClear.addEventListener("click", () => {
      startInput.value = "";
    });
    let stopInput = null;
    if (inst.state === "done" && inst.stopTime) {
      const stopGroup = form.createEl("div", { cls: "form-group" });
      stopGroup.createEl("label", { text: "\u7D42\u4E86\u6642\u523B:", cls: "form-label" });
      stopInput = stopGroup.createEl("input", {
        type: "time",
        cls: "form-input",
        value: toHM(inst.stopTime)
      });
      const stopClear = stopGroup.createEl("button", { type: "button", cls: "form-button secondary", text: "\u30AF\u30EA\u30A2", attr: { style: "margin-left: 8px; padding: 4px 12px; font-size: 12px;" } });
      stopClear.addEventListener("click", () => {
        if (stopInput) stopInput.value = "";
      });
    }
    const desc = form.createEl("div", { cls: "form-group" }).createEl("p", { cls: "form-description", attr: { style: "margin-top: 12px; font-size: 12px; color: var(--text-muted);" } });
    if (inst.state === "running") {
      desc.textContent = "\u958B\u59CB\u6642\u523B\u3092\u524A\u9664\u3059\u308B\u3068\u3001\u30BF\u30B9\u30AF\u306F\u672A\u5B9F\u884C\u72B6\u614B\u306B\u623B\u308A\u307E\u3059\u3002";
    } else {
      desc.textContent = "\u7D42\u4E86\u6642\u523B\u306E\u307F\u524A\u9664\uFF1A\u5B9F\u884C\u4E2D\u306B\u623B\u308A\u307E\u3059\n\u4E21\u65B9\u524A\u9664\uFF1A\u672A\u5B9F\u884C\u306B\u623B\u308A\u307E\u3059";
    }
    const buttons = form.createEl("div", { cls: "form-button-group" });
    const cancelBtn = buttons.createEl("button", { type: "button", cls: "form-button cancel", text: "\u30AD\u30E3\u30F3\u30BB\u30EB" });
    const saveBtn = buttons.createEl("button", { type: "submit", cls: "form-button create", text: "\u4FDD\u5B58" });
    cancelBtn.addEventListener("click", () => modal.remove());
    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      const newStart = (startInput.value || "").trim();
      const newStop = stopInput ? (stopInput.value || "").trim() : "";
      if (inst.state === "running") {
        if (!newStart) {
          await this.resetTaskToIdle(inst);
          modal.remove();
          return;
        }
        await this.updateRunningInstanceStartTime(inst, newStart);
      } else if (inst.state === "done") {
        if (!newStart && !newStop) {
          await this.resetTaskToIdle(inst);
          modal.remove();
          return;
        } else if (newStart && !newStop) {
          await this.transitionToRunningWithStart(inst, newStart);
          modal.remove();
          return;
        } else if (newStart && newStop) {
          if (newStart >= newStop) {
            new import_obsidian11.Notice("\u958B\u59CB\u6642\u523B\u306F\u7D42\u4E86\u6642\u523B\u3088\u308A\u524D\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059");
            return;
          }
          await this.updateInstanceTimes(inst, newStart, newStop);
        } else {
          new import_obsidian11.Notice("\u958B\u59CB\u6642\u523B\u306F\u5FC5\u9808\u3067\u3059");
          return;
        }
      }
      modal.remove();
    });
    document.body.appendChild(modal);
    startInput.focus();
  }
  async updateInstanceTimes(inst, startStr, stopStr) {
    const base = inst.startTime || new Date(this.currentDate);
    const [sh, sm] = startStr.split(":").map((n) => parseInt(n, 10));
    const [eh, em] = stopStr.split(":").map((n) => parseInt(n, 10));
    inst.startTime = new Date(base.getFullYear(), base.getMonth(), base.getDate(), sh, sm, 0, 0);
    inst.stopTime = new Date(base.getFullYear(), base.getMonth(), base.getDate(), eh, em, 0, 0);
    const newSlot = getSlotFromTime(startStr);
    if (inst.slotKey !== newSlot) {
      inst.slotKey = newSlot;
      if (inst.task.path) {
        this.plugin.settings.slotKeys[inst.task.path] = newSlot;
        void this.plugin.saveSettings();
      }
    }
    const durationSec = Math.floor(this.calculateCrossDayDuration(inst.startTime, inst.stopTime) / 1e3);
    await this.executionLogService.saveTaskLog(inst, durationSec);
    this.renderTaskList();
    new import_obsidian11.Notice(`\u300C${inst.task.title || inst.task.name}\u300D\u306E\u6642\u523B\u3092\u66F4\u65B0\u3057\u307E\u3057\u305F`);
  }
  async updateRunningInstanceStartTime(inst, startStr) {
    const base = inst.startTime || new Date(this.currentDate);
    const [sh, sm] = startStr.split(":").map((n) => parseInt(n, 10));
    inst.startTime = new Date(base.getFullYear(), base.getMonth(), base.getDate(), sh, sm, 0, 0);
    const newSlot = getSlotFromTime(startStr);
    if (inst.slotKey !== newSlot) {
      inst.slotKey = newSlot;
      if (inst.task.path) {
        this.plugin.settings.slotKeys[inst.task.path] = newSlot;
        void this.plugin.saveSettings();
      }
    }
    await this.saveRunningTasksState();
    this.renderTaskList();
    new import_obsidian11.Notice(`\u300C${inst.task.title || inst.task.name}\u300D\u306E\u958B\u59CB\u6642\u523B\u3092\u66F4\u65B0\u3057\u307E\u3057\u305F`);
  }
  async transitionToRunningWithStart(inst, startStr) {
    if (inst.state !== "done") return;
    const base = inst.startTime || new Date(this.currentDate);
    const [sh, sm] = startStr.split(":").map((n) => parseInt(n, 10));
    if (inst.instanceId) {
      await this.removeTaskLogForInstanceOnCurrentDate(inst.instanceId);
    }
    inst.state = "running";
    inst.startTime = new Date(base.getFullYear(), base.getMonth(), base.getDate(), sh, sm, 0, 0);
    inst.stopTime = void 0;
    const newSlot = getSlotFromTime(startStr);
    if (inst.slotKey !== newSlot) {
      inst.slotKey = newSlot;
      if (inst.task.path) {
        this.plugin.settings.slotKeys[inst.task.path] = newSlot;
        void this.plugin.saveSettings();
      }
    }
    await this.saveRunningTasksState();
    this.renderTaskList();
    new import_obsidian11.Notice(`\u300C${inst.task.title || inst.task.name}\u300D\u3092\u5B9F\u884C\u4E2D\u306B\u623B\u3057\u307E\u3057\u305F`);
  }
  updateTimerDisplay(timerEl, inst) {
    if (!inst.startTime) return;
    const now = /* @__PURE__ */ new Date();
    const elapsed = now.getTime() - inst.startTime.getTime();
    const hours = Math.floor(elapsed / (1e3 * 60 * 60));
    const minutes = Math.floor(elapsed % (1e3 * 60 * 60) / (1e3 * 60));
    const seconds = Math.floor(elapsed % (1e3 * 60) / 1e3);
    timerEl.textContent = `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
  }
  stopGlobalTimer() {
    var _a;
    (_a = this.timerService) == null ? void 0 : _a.stop();
  }
  // ===========================================
  // Event Handler Methods
  // ===========================================
  setupEventListeners() {
    this.registerDomEvent(document, "keydown", (e) => {
      this.handleKeyboardShortcut(e);
    });
    this.registerDomEvent(this.containerEl, "click", (e) => {
      if (!e.target.closest(".task-item")) {
        this.clearTaskSelection();
      }
    });
    this.registerEvent(
      this.app.vault.on("rename", async (file, oldPath) => {
        await this.handleFileRename(file, oldPath);
      })
    );
  }
  // ===========================================
  // TimerService integration
  // ===========================================
  ensureTimerService() {
    if (this.timerService) return;
    this.timerService = new TimerService({
      getRunningInstances: () => this.taskInstances.filter((inst) => inst.state === "running"),
      onTick: (inst) => this.onTimerTick(inst),
      intervalMs: 1e3
    });
  }
  onTimerTick(inst) {
    const selector = `[data-instance-id="${inst.instanceId}"] .task-timer-display`;
    const timerEl = this.taskList.querySelector(selector);
    if (timerEl) {
      this.updateTimerDisplay(timerEl, inst);
    }
  }
  setupPlayStopButton(button, inst) {
    button.addEventListener("click", async (e) => {
      e.stopPropagation();
      if (inst.state === "running") {
        await this.stopInstance(inst);
      } else if (inst.state === "idle") {
        await this.startInstance(inst);
      }
    });
  }
  setupTaskItemEventListeners(taskItem, inst) {
    taskItem.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      this.showTaskContextMenu(e, inst);
    });
    this.setupTaskItemDragDrop(taskItem, inst);
    taskItem.addEventListener("click", (e) => {
      const target = e.target;
      if (target.closest('button, a, input, textarea, .drag-handle, [contenteditable="true"]')) return;
      this.selectTaskForKeyboard(inst, taskItem);
    });
  }
  setupTaskItemDragDrop(taskItem, inst) {
    taskItem.addEventListener("dragover", (e) => {
      e.preventDefault();
      this.handleDragOver(e, taskItem, inst);
    });
    taskItem.addEventListener("dragleave", () => {
      this.clearDragoverClasses(taskItem);
    });
    taskItem.addEventListener("drop", (e) => {
      e.preventDefault();
      this.handleDrop(e, taskItem, inst);
    });
  }
  setupDragEvents(dragHandle, taskItem, slot, idx) {
    dragHandle.addEventListener("dragstart", (e) => {
      e.dataTransfer.setData("text/plain", `${slot != null ? slot : "none"}::${idx}`);
      taskItem.classList.add("dragging");
    });
    dragHandle.addEventListener("dragend", () => {
      taskItem.classList.remove("dragging");
    });
  }
  setupTimeSlotDragHandlers(header, slot) {
    header.addEventListener("dragover", (e) => {
      e.preventDefault();
      header.classList.add("dragover");
    });
    header.addEventListener("dragleave", () => {
      header.classList.remove("dragover");
    });
    header.addEventListener("drop", (e) => {
      e.preventDefault();
      header.classList.remove("dragover");
      this.handleSlotDrop(e, slot);
    });
  }
  // ===========================================
  // Command Methods (for external commands)
  // ===========================================
  async duplicateSelectedTask() {
    if (this.selectedTaskInstance) {
      await this.duplicateInstance(this.selectedTaskInstance);
      this.clearTaskSelection();
    } else {
      new import_obsidian11.Notice("\u30BF\u30B9\u30AF\u304C\u9078\u629E\u3055\u308C\u3066\u3044\u307E\u305B\u3093");
    }
  }
  deleteSelectedTask() {
    if (this.selectedTaskInstance) {
      this.showDeleteConfirmDialog(this.selectedTaskInstance).then((confirmed) => {
        if (confirmed) {
          this.deleteTask(this.selectedTaskInstance);
        }
      });
    } else {
      new import_obsidian11.Notice("\u30BF\u30B9\u30AF\u304C\u9078\u629E\u3055\u308C\u3066\u3044\u307E\u305B\u3093");
    }
  }
  async resetSelectedTask() {
    if (this.selectedTaskInstance) {
      await this.resetTaskToIdle(this.selectedTaskInstance);
      this.clearTaskSelection();
    } else {
      new import_obsidian11.Notice("\u30BF\u30B9\u30AF\u304C\u9078\u629E\u3055\u308C\u3066\u3044\u307E\u305B\u3093");
    }
  }
  showTodayTasks() {
    const today = /* @__PURE__ */ new Date();
    this.currentDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
    const dateLabel = this.containerEl.querySelector(".date-nav-label");
    if (dateLabel) {
      this.updateDateLabel(dateLabel);
    }
    this.reloadTasksAndRestore({ runBoundaryCheck: true }).then(() => {
      new import_obsidian11.Notice(`\u4ECA\u65E5\u306E\u30BF\u30B9\u30AF\u3092\u8868\u793A\u3057\u307E\u3057\u305F`);
    });
  }
  reorganizeIdleTasks() {
    this.moveIdleTasksToCurrentTime();
    new import_obsidian11.Notice("\u30A2\u30A4\u30C9\u30EB\u30BF\u30B9\u30AF\u3092\u6574\u7406\u3057\u307E\u3057\u305F");
  }
  // ===========================================
  // Utility Methods
  // ===========================================
  getTimeSlotKeys() {
    return ["0:00-8:00", "8:00-12:00", "12:00-16:00", "16:00-0:00"];
  }
  sortTaskInstancesByTimeOrder() {
    if (this.useOrderBasedSort) {
      const savedOrders = this.loadSavedOrders();
      this.applySavedOrders(savedOrders);
      this.ensureOrdersAcrossSlots(savedOrders, { forceDone: true, persist: false });
    }
  }
  applySavedOrders(savedOrders) {
    this.taskInstances.forEach((inst) => {
      const key = this.getOrderKey(inst);
      if (!key) return;
      const saved = savedOrders[key];
      if (typeof saved === "number" && Number.isFinite(saved)) {
        inst.order = saved;
      }
    });
  }
  ensureOrdersAcrossSlots(savedOrders, options = {}) {
    const slots = /* @__PURE__ */ new Set(["none", ...this.getTimeSlotKeys()]);
    slots.forEach((slot) => this.ensureOrdersForSlot(slot, savedOrders, options));
    if (options.persist) {
      void this.saveTaskOrders();
    }
  }
  ensureOrdersForSlot(slotKey, savedOrders, options = {}) {
    const instances = this.taskInstances.filter((inst) => (inst.slotKey || "none") === slotKey);
    if (instances.length === 0) return;
    const done = instances.filter((inst) => inst.state === "done");
    const running = instances.filter((inst) => inst.state === "running" || inst.state === "paused");
    const idle = instances.filter((inst) => inst.state === "idle");
    let maxOrder = 0;
    const assignSequential = (items, startOrder, step = 100) => {
      let cursor = startOrder;
      items.forEach((inst) => {
        inst.order = cursor;
        cursor += step;
        maxOrder = Math.max(maxOrder, cursor - step);
      });
      return cursor;
    };
    const shouldRecomputeDone = options.forceDone || done.some((inst) => inst.order === void 0 || inst.order === null);
    if (shouldRecomputeDone) {
      const sortedDone = [...done].sort((a, b) => {
        const ta = a.startTime ? a.startTime.getTime() : Infinity;
        const tb = b.startTime ? b.startTime.getTime() : Infinity;
        return ta - tb;
      });
      assignSequential(sortedDone, 100);
    } else {
      done.forEach((inst) => {
        if (typeof inst.order === "number") {
          maxOrder = Math.max(maxOrder, inst.order);
        }
      });
    }
    running.forEach((inst) => {
      if (typeof inst.order === "number") {
        maxOrder = Math.max(maxOrder, inst.order);
      }
    });
    const runningMissing = running.filter((inst) => inst.order === void 0 || inst.order === null);
    if (runningMissing.length > 0) {
      runningMissing.sort((a, b) => {
        var _a, _b, _c, _d;
        return ((_b = (_a = a.startTime) == null ? void 0 : _a.getTime()) != null ? _b : 0) - ((_d = (_c = b.startTime) == null ? void 0 : _c.getTime()) != null ? _d : 0);
      });
      assignSequential(runningMissing, maxOrder + 100);
    }
    idle.forEach((inst) => {
      if (typeof inst.order === "number") {
        maxOrder = Math.max(maxOrder, inst.order);
      }
    });
    const idleMissing = idle.filter((inst) => inst.order === void 0 || inst.order === null);
    if (idleMissing.length > 0) {
      idleMissing.sort((a, b) => {
        var _a, _b, _c, _d;
        const ta = (_a = a == null ? void 0 : a.task) == null ? void 0 : _a.scheduledTime;
        const tb = (_b = b == null ? void 0 : b.task) == null ? void 0 : _b.scheduledTime;
        if (!ta && !tb) return (((_c = a.task) == null ? void 0 : _c.title) || "").localeCompare(((_d = b.task) == null ? void 0 : _d.title) || "");
        if (!ta) return 1;
        if (!tb) return -1;
        const [ha, ma] = ta.split(":").map((n) => parseInt(n, 10));
        const [hb, mb] = tb.split(":").map((n) => parseInt(n, 10));
        return ha * 60 + ma - (hb * 60 + mb);
      });
      assignSequential(idleMissing, maxOrder + 100);
    }
  }
  async saveTaskOrders() {
    await this.ensureDayStateForCurrentDate();
    const dateStr = this.getCurrentDateString();
    const dayState = this.getCurrentDayState();
    const orders = {};
    this.taskInstances.forEach((inst) => {
      if (inst.order === void 0 || inst.order === null) return;
      const key = this.getOrderKey(inst);
      if (!key) return;
      orders[key] = inst.order;
    });
    if (Array.isArray(dayState.duplicatedInstances) && dayState.duplicatedInstances.length > 0) {
      dayState.duplicatedInstances = dayState.duplicatedInstances.map((dup) => {
        var _a;
        if (!dup || !dup.instanceId) return dup;
        const inst = this.taskInstances.find((i) => i.instanceId === dup.instanceId);
        if (!inst) return dup;
        return {
          ...dup,
          slotKey: inst.slotKey,
          originalSlotKey: (_a = inst.originalSlotKey) != null ? _a : dup.originalSlotKey
        };
      });
    }
    dayState.orders = orders;
    await this.persistDayState(dateStr);
  }
  loadSavedOrders() {
    const dateStr = this.getCurrentDateString();
    const state = this.dayStateCache.get(dateStr);
    if (!state || !state.orders) {
      return {};
    }
    const raw = state.orders;
    const normalized = {};
    let mutated = false;
    for (const [key, value] of Object.entries(raw)) {
      if (typeof value === "number" && Number.isFinite(value)) {
        normalized[key] = value;
        continue;
      }
      if (value && typeof value === "object") {
        const order = Number(value.order);
        if (!Number.isFinite(order)) continue;
        const slot = value.slot || "none";
        const normalizedKey = key.includes("::") ? key : `${key}::${slot}`;
        normalized[normalizedKey] = order;
        mutated = true;
      }
    }
    if (mutated || Object.values(raw).some((v) => typeof v !== "number")) {
      state.orders = normalized;
      this.dayStateCache.set(dateStr, state);
      void this.persistDayState(dateStr);
    }
    return normalized;
  }
  getSavedOrderForSlot(inst, slotKey, savedOrders) {
    const originalSlot = inst.slotKey;
    inst.slotKey = slotKey;
    const key = this.getOrderKey(inst);
    inst.slotKey = originalSlot;
    if (!key) return void 0;
    return savedOrders[key];
  }
  sortByOrder(instances) {
    return instances.sort((a, b) => {
      var _a, _b, _c, _d;
      const statePriority = { done: 0, running: 1, paused: 1, idle: 2 };
      const sa = (_a = statePriority[a.state]) != null ? _a : 3;
      const sb = (_b = statePriority[b.state]) != null ? _b : 3;
      if (sa !== sb) return sa - sb;
      const hasOrderA = a.order !== void 0 && a.order !== null;
      const hasOrderB = b.order !== void 0 && b.order !== null;
      if (hasOrderA && hasOrderB) {
        if (a.order !== b.order) return a.order - b.order;
      } else if (hasOrderA && !hasOrderB) {
        return -1;
      } else if (!hasOrderA && hasOrderB) {
        return 1;
      }
      if (a.state === "done" && b.state === "done") {
        const ta = a.startTime ? a.startTime.getTime() : Infinity;
        const tb = b.startTime ? b.startTime.getTime() : Infinity;
        if (ta !== tb) return ta - tb;
        return 0;
      }
      const tA = (_c = a == null ? void 0 : a.task) == null ? void 0 : _c.scheduledTime;
      const tB = (_d = b == null ? void 0 : b.task) == null ? void 0 : _d.scheduledTime;
      if (!tA && !tB) return 0;
      if (!tA) return 1;
      if (!tB) return -1;
      const [ha, ma] = tA.split(":").map((n) => parseInt(n, 10));
      const [hb, mb] = tB.split(":").map((n) => parseInt(n, 10));
      return ha * 60 + ma - (hb * 60 + mb);
    });
  }
  async moveTaskToSlot(inst, newSlot, stateInsertIndex) {
    await this.ensureDayStateForCurrentDate();
    const targetSlot = newSlot || "none";
    const normalizedState = this.normalizeState(inst.state);
    const sameStateTasks = this.taskInstances.filter(
      (t) => t !== inst && (t.slotKey || "none") === targetSlot && this.normalizeState(t.state) === normalizedState
    ).sort((a, b) => {
      var _a, _b;
      return ((_a = a.order) != null ? _a : 0) - ((_b = b.order) != null ? _b : 0);
    });
    const insertIndex = stateInsertIndex !== void 0 ? Math.max(0, Math.min(stateInsertIndex, sameStateTasks.length)) : sameStateTasks.length;
    const referenceTasks = [...sameStateTasks];
    inst.slotKey = targetSlot;
    this.persistSlotAssignment(inst);
    const newOrder = this.calculateSimpleOrder(insertIndex, referenceTasks);
    inst.order = newOrder;
    await this.saveTaskOrders();
    this.sortTaskInstancesByTimeOrder();
    this.renderTaskList();
  }
  applyResponsiveClasses() {
    const width = this.containerEl.clientWidth;
    const classList = this.containerEl.classList;
    classList.remove("narrow", "medium", "wide");
    if (width < 400) {
      classList.add("narrow");
    } else if (width < 600) {
      classList.add("medium");
    } else {
      classList.add("wide");
    }
  }
  setupResizeObserver() {
    const resizeObserver = new ResizeObserver(() => {
      this.applyResponsiveClasses();
    });
    resizeObserver.observe(this.containerEl);
  }
  initializeNavigationEventListeners() {
    const drawerToggle = this.containerEl.querySelector(".drawer-toggle");
    if (drawerToggle) {
      drawerToggle.addEventListener("click", () => {
        this.toggleNavigation();
      });
    }
    if (this.navigationOverlay) {
      this.navigationOverlay.addEventListener("click", () => {
        this.closeNavigation();
      });
    }
  }
  scheduleBoundaryCheck() {
    if (this.boundaryCheckTimeout) {
      clearTimeout(this.boundaryCheckTimeout);
    }
    const now = /* @__PURE__ */ new Date();
    const boundaries = [
      { hour: 0, minute: 0 },
      { hour: 8, minute: 0 },
      { hour: 12, minute: 0 },
      { hour: 16, minute: 0 }
    ];
    const next = calculateNextBoundary(now, boundaries);
    const delay = Math.max(0, next.getTime() - now.getTime() + 1e3);
    this.boundaryCheckTimeout = setTimeout(() => {
      this.checkBoundaryTasks();
      this.scheduleBoundaryCheck();
    }, delay);
  }
  async checkBoundaryTasks() {
    try {
      const today = /* @__PURE__ */ new Date();
      today.setHours(0, 0, 0, 0);
      const viewDate = new Date(this.currentDate);
      viewDate.setHours(0, 0, 0, 0);
      if (viewDate.getTime() !== today.getTime()) return;
      const currentSlot = getCurrentTimeSlot(/* @__PURE__ */ new Date());
      const slots = this.getTimeSlotKeys();
      const currentIndex = slots.indexOf(currentSlot);
      if (currentIndex < 0) return;
      let moved = false;
      this.taskInstances.forEach((inst) => {
        if (inst.state !== "idle") return;
        const slot = inst.slotKey || "none";
        if (slot === "none") return;
        const idx = slots.indexOf(slot);
        if (idx >= 0 && idx < currentIndex) {
          inst.slotKey = currentSlot;
          this.persistSlotAssignment(inst);
          moved = true;
        }
      });
      if (moved) {
        this.sortTaskInstancesByTimeOrder();
        await this.saveTaskOrders();
        this.renderTaskList();
      }
    } catch (e) {
      console.error("[TaskChute] boundary move failed:", e);
    }
  }
  updateTotalTasksCount() {
    const completedTasks = this.taskInstances.filter((inst) => inst.state === "done");
  }
  cleanupAutocompleteInstances() {
    if (this.autocompleteInstances) {
      this.autocompleteInstances.forEach((instance) => {
        if (instance && instance.cleanup) {
          instance.cleanup();
        }
      });
      this.autocompleteInstances = [];
    }
  }
  cleanupTimers() {
    var _a;
    if (this.globalTimerInterval) {
      clearInterval(this.globalTimerInterval);
      this.globalTimerInterval = null;
    }
    if (this.boundaryCheckTimeout) {
      clearTimeout(this.boundaryCheckTimeout);
      this.boundaryCheckTimeout = null;
    }
    if (this.renderDebounceTimer) {
      clearTimeout(this.renderDebounceTimer);
      this.renderDebounceTimer = null;
    }
    (_a = this.timerService) == null ? void 0 : _a.dispose();
    this.timerService = null;
  }
  // Styles are provided by styles.css; dynamic CSS injection removed
  // ===========================================
  // Placeholder Methods (to be implemented)
  // ===========================================
  async handleNavigationItemClick(section) {
    if (section === "log") {
      this.openLogModal();
      this.closeNavigation();
      return;
    }
    if (section === "review") {
      await this.showReviewSection();
      this.closeNavigation();
      return;
    }
    if (section === "routine") {
      await this.renderRoutineList();
      this.openNavigation();
      return;
    }
    new import_obsidian11.Notice(`${section} \u6A5F\u80FD\u306F\u5B9F\u88C5\u4E2D\u3067\u3059`);
  }
  // Render routine list with enabled toggle
  async renderRoutineList() {
    var _a;
    if (!this.navigationContent) return;
    this.navigationContent.empty();
    const header = this.navigationContent.createEl("div", { cls: "routine-list-header" });
    header.createEl("h3", { text: "\u30EB\u30FC\u30C1\u30F3\u4E00\u89A7" });
    const hint = this.navigationContent.createEl("div", { cls: "routine-list-hint" });
    hint.textContent = "\u3053\u3053\u3067\u306F\u6709\u52B9/\u7121\u52B9\u3092\u5207\u308A\u66FF\u3048\u3067\u304D\u307E\u3059\u3002\u8A2D\u5B9A\u306E\u8A73\u7D30\u306F\u5404\u30BF\u30B9\u30AF\u306E\u8A2D\u5B9A\u304B\u3089\u7DE8\u96C6\u3057\u3066\u304F\u3060\u3055\u3044\u3002";
    const list = this.navigationContent.createEl("div", { cls: "routine-list" });
    const taskFolderPath = this.plugin.pathManager.getTaskFolderPath();
    const all = this.app.vault.getMarkdownFiles();
    const files = all.filter((f) => f.path.startsWith(taskFolderPath + "/"));
    files.sort((a, b) => a.basename.localeCompare(b.basename, "ja"));
    let count = 0;
    for (const file of files) {
      const fm = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if (!fm || fm.isRoutine !== true) continue;
      count++;
      const row = this.createRoutineRow(file, fm);
      list.appendChild(row);
    }
    if (count === 0) {
      const none = this.navigationContent.createEl("div", { cls: "routine-empty" });
      none.textContent = "\u30EB\u30FC\u30C1\u30F3\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093";
    }
  }
  createRoutineRow(file, fm) {
    const row = document.createElement("div");
    row.className = "routine-row";
    const title = row.createEl("div", { cls: "routine-title", text: file.basename });
    const typeBadge = row.createEl("span", { cls: "routine-type-badge" });
    const type = fm.routine_type || "daily";
    const interval = Math.max(1, Number(fm.routine_interval || 1));
    typeBadge.textContent = this.getRoutineTypeLabel(type, interval, fm);
    const toggleWrap = row.createEl("label", { cls: "routine-enabled-toggle" });
    const toggle = toggleWrap.createEl("input", { type: "checkbox" });
    toggle.checked = fm.routine_enabled !== false;
    toggle.title = "\u6709\u52B9/\u7121\u52B9";
    toggle.addEventListener("change", async (e) => {
      var _a;
      await this.updateRoutineEnabled(file, toggle.checked);
      await this.reloadTasksAndRestore({ runBoundaryCheck: true });
      const newFm = ((_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter) || {};
      typeBadge.textContent = this.getRoutineTypeLabel(newFm.routine_type || "daily", Math.max(1, Number(newFm.routine_interval || 1)), newFm);
    });
    const editBtn = row.createEl("button", { cls: "routine-edit-btn", text: "\u7DE8\u96C6" });
    editBtn.addEventListener("click", (e) => {
      var _a, _b;
      e.stopPropagation();
      const task = {
        title: file.basename,
        isRoutine: true,
        scheduledTime: fm.\u958B\u59CB\u6642\u523B,
        routine_type: fm.routine_type || "daily",
        routine_interval: fm.routine_interval || 1,
        routine_enabled: fm.routine_enabled !== false,
        weekday: (_a = fm.routine_weekday) != null ? _a : fm.weekday,
        weekdays: fm.weekdays,
        monthly_week: fm.routine_week !== void 0 ? fm.routine_week === "last" ? "last" : Number(fm.routine_week) - 1 : fm.monthly_week,
        monthly_weekday: (_b = fm.routine_weekday) != null ? _b : fm.monthly_weekday
      };
      this.showRoutineEditModal(task, editBtn);
    });
    return row;
  }
  getRoutineTypeLabel(type, interval, fm) {
    var _a, _b, _c, _d;
    const dayNames = ["\u65E5", "\u6708", "\u706B", "\u6C34", "\u6728", "\u91D1", "\u571F"];
    switch (type) {
      case "daily":
        return `${interval}\u65E5\u3054\u3068`;
      case "weekly": {
        const wd = (_b = (_a = fm.routine_weekday) != null ? _a : fm.weekday) != null ? _b : Array.isArray(fm.weekdays) ? fm.weekdays[0] : void 0;
        const dayLabel = typeof wd === "number" ? dayNames[wd] + "\u66DC" : "\u66DC\u65E5\u672A\u6307\u5B9A";
        return `${interval}\u9031\u3054\u3068 ${dayLabel}`;
      }
      case "monthly": {
        const w = (_c = fm.routine_week) != null ? _c : typeof fm.monthly_week === "number" ? fm.monthly_week + 1 : fm.monthly_week === "last" ? "last" : void 0;
        const wd = (_d = fm.routine_weekday) != null ? _d : fm.monthly_weekday;
        const weekLabel = w === "last" ? "\u6700\u7D42" : `\u7B2C${w}`;
        const dayLabel = typeof wd === "number" ? dayNames[wd] + "\u66DC" : "";
        return `${interval}\u30F6\u6708\u3054\u3068 ${weekLabel}${dayLabel}`.trim();
      }
      case "weekdays":
        return "\u5E73\u65E5\u306E\u307F";
      case "weekends":
        return "\u9031\u672B\u306E\u307F";
      default:
        return type;
    }
  }
  async updateRoutineEnabled(file, enabled) {
    await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      frontmatter.routine_enabled = enabled;
      return frontmatter;
    });
  }
  // Show Daily Review in right split
  async showReviewSection() {
    try {
      const today = /* @__PURE__ */ new Date();
      const todayStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, "0")}-${String(today.getDate()).padStart(2, "0")}`;
      const selectedStr = this.getCurrentDateString();
      const reviewDate = new Date(selectedStr);
      const dateStr = reviewDate > new Date(todayStr) ? todayStr : selectedStr;
      const review = new ReviewService(this.plugin);
      const file = await review.ensureReviewFile(dateStr);
      await review.openInSplit(file, this.leaf);
    } catch (error) {
      new import_obsidian11.Notice("\u30EC\u30D3\u30E5\u30FC\u306E\u8868\u793A\u306B\u5931\u6557\u3057\u307E\u3057\u305F: " + ((error == null ? void 0 : error.message) || error));
    }
  }
  openLogModal() {
    const overlay = document.createElement("div");
    overlay.className = "taskchute-log-modal-overlay";
    const content = overlay.createEl("div", { cls: "taskchute-log-modal-content" });
    const closeBtn = content.createEl("button", { cls: "log-modal-close", text: "\xD7", attr: { title: "\u9589\u3058\u308B" } });
    closeBtn.addEventListener("click", () => {
      if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
    });
    const logView = new LogView(this.plugin, content);
    logView.render();
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) {
        if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
      }
    });
    document.body.appendChild(overlay);
  }
  async handleKeyboardShortcut(e) {
    const active = document.activeElement;
    if (active && active !== document.body && (active.tagName === "INPUT" || active.tagName === "TEXTAREA" || active.isContentEditable)) {
      return;
    }
    if (document.querySelector(".modal") || document.querySelector(".task-modal-overlay")) return;
    if (!this.selectedTaskInstance) return;
    switch ((e.key || "").toLowerCase()) {
      case "c":
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          await this.duplicateInstance(this.selectedTaskInstance);
          this.clearTaskSelection();
        }
        break;
      case "d":
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          this.deleteSelectedTask();
        }
        break;
      case "u":
        if (e.ctrlKey || e.metaKey) {
          e.preventDefault();
          if (this.selectedTaskInstance.state !== "idle") {
            await this.resetTaskToIdle(this.selectedTaskInstance);
            this.clearTaskSelection();
          } else {
            new import_obsidian11.Notice("\u3053\u306E\u30BF\u30B9\u30AF\u306F\u65E2\u306B\u672A\u5B9F\u884C\u72B6\u614B\u3067\u3059");
          }
        }
        break;
    }
  }
  selectTaskForKeyboard(inst, taskItem) {
    this.selectedTaskInstance = inst;
    this.containerEl.querySelectorAll(".task-item.keyboard-selected").forEach((el) => el.classList.remove("keyboard-selected"));
    taskItem.classList.add("keyboard-selected");
  }
  clearTaskSelection() {
    this.selectedTaskInstance = null;
    this.containerEl.querySelectorAll(".task-item.keyboard-selected").forEach((el) => el.classList.remove("keyboard-selected"));
  }
  async deleteTask(inst) {
    if (!inst) return;
    if (!inst.task.isRoutine) {
      await this.deleteNonRoutineTask(inst);
    } else {
      await this.deleteRoutineTask(inst);
    }
  }
  async deleteNonRoutineTask(inst) {
    if (inst.instanceId) {
      await this.deleteTaskLogsByInstanceId(inst.task.path, inst.instanceId);
    }
    await this.deleteInstance(inst);
  }
  async deleteRoutineTask(inst) {
    const dateStr = this.getCurrentDateString();
    await this.ensureDayStateForCurrentDate();
    const dayState = this.getCurrentDayState();
    const isDuplicated = this.isDuplicatedTask(inst);
    const alreadyHidden = dayState.hiddenRoutines.some((h) => {
      if (isDuplicated) {
        if (typeof h === "string") return false;
        return h.instanceId === inst.instanceId;
      }
      if (typeof h === "string") {
        return h === inst.task.path;
      }
      return h.path === inst.task.path && !h.instanceId;
    });
    if (!alreadyHidden) {
      dayState.hiddenRoutines.push({
        path: inst.task.path,
        instanceId: isDuplicated ? inst.instanceId : null
      });
      await this.persistDayState(dateStr);
    }
    if (inst.instanceId) {
      await this.deleteTaskLogsByInstanceId(inst.task.path, inst.instanceId);
    }
    await this.deleteInstance(inst);
  }
  isDuplicatedTask(inst) {
    const dayState = this.getCurrentDayState();
    return dayState.duplicatedInstances.some((d) => d.instanceId === inst.instanceId);
  }
  async deleteTaskLogsByInstanceId(taskPath, instanceId) {
    try {
      const logDataPath = this.plugin.pathManager.getLogDataPath();
      const [year, month] = this.getCurrentDateString().split("-");
      const monthString = `${year}-${month}`;
      const logPath = `${logDataPath}/${monthString}-tasks.json`;
      const logFile = this.app.vault.getAbstractFileByPath(logPath);
      if (!logFile || !(logFile instanceof import_obsidian11.TFile)) {
        return 0;
      }
      const content = await this.app.vault.read(logFile);
      const monthlyLog = JSON.parse(content);
      let deletedCount = 0;
      for (const dateKey in monthlyLog.taskExecutions) {
        const dayExecutions = monthlyLog.taskExecutions[dateKey];
        const beforeLength = dayExecutions.length;
        monthlyLog.taskExecutions[dateKey] = dayExecutions.filter(
          (exec) => exec.instanceId !== instanceId
        );
        deletedCount += beforeLength - monthlyLog.taskExecutions[dateKey].length;
      }
      if (deletedCount > 0) {
        await this.app.vault.modify(logFile, JSON.stringify(monthlyLog, null, 2));
      }
      return deletedCount;
    } catch (error) {
      console.error("Failed to delete task logs:", error);
      return 0;
    }
  }
  showTaskContextMenu(e, inst) {
    new import_obsidian11.Notice("\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u30E1\u30CB\u30E5\u30FC\u306F\u5B9F\u88C5\u4E2D\u3067\u3059");
  }
  handleDragOver(e, taskItem, inst) {
    e.preventDefault();
    this.clearDragoverClasses(taskItem);
    if (inst.state === "done") {
      taskItem.classList.add("dragover-invalid");
      return;
    }
    const rect = taskItem.getBoundingClientRect();
    const y = e.clientY - rect.top;
    const height = rect.height;
    const isBottomHalf = y > height / 2;
    if (isBottomHalf) {
      taskItem.classList.add("dragover-bottom");
    } else {
      taskItem.classList.add("dragover-top");
    }
  }
  clearDragoverClasses(taskItem) {
    taskItem.classList.remove("dragover", "dragover-top", "dragover-bottom", "dragover-invalid");
  }
  handleDrop(e, taskItem, targetInst) {
    var _a;
    const data = (_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain");
    if (!data) {
      this.clearDragoverClasses(taskItem);
      return;
    }
    const [sourceSlot, sourceIdx] = data.split("::");
    const targetSlot = targetInst.slotKey || "none";
    const sourceInst = this.taskInstances.find((inst) => {
      const instSlot = inst.slotKey || "none";
      const slotInstances = this.taskInstances.filter((t) => (t.slotKey || "none") === instSlot);
      const sortedSlotInstances = this.sortByOrder(slotInstances);
      const idx = sortedSlotInstances.indexOf(inst);
      return instSlot === sourceSlot && idx === parseInt(sourceIdx);
    });
    if (!sourceInst || sourceInst.state === "done") {
      this.clearDragoverClasses(taskItem);
      return;
    }
    const rect = taskItem.getBoundingClientRect();
    const y = e.clientY - rect.top;
    const isBottomHalf = y > rect.height / 2;
    const targetSlotTasks = this.taskInstances.filter(
      (t) => (t.slotKey || "none") === targetSlot
    );
    const sortedTargetTasks = this.sortByOrder(targetSlotTasks);
    const targetWithoutSource = sortedTargetTasks.filter((t) => t !== sourceInst);
    const targetIndex = sortedTargetTasks.indexOf(targetInst);
    let newPosition = isBottomHalf ? targetIndex + 1 : targetIndex;
    const sourcePriority = this.getStatePriority(sourceInst.state);
    let minAllowed = 0;
    for (const task of sortedTargetTasks) {
      if (this.getStatePriority(task.state) < sourcePriority) {
        minAllowed++;
      }
    }
    let boundaryAfter = sortedTargetTasks.length;
    for (let i = 0; i < sortedTargetTasks.length; i++) {
      if (this.getStatePriority(sortedTargetTasks[i].state) > sourcePriority) {
        boundaryAfter = i;
        break;
      }
    }
    if (newPosition < minAllowed) {
      new import_obsidian11.Notice("\u5B8C\u4E86\u6E08\u307F\u30FB\u5B9F\u884C\u4E2D\u30BF\u30B9\u30AF\u3088\u308A\u4E0A\u306B\u306F\u914D\u7F6E\u3067\u304D\u307E\u305B\u3093");
      this.clearDragoverClasses(taskItem);
      return;
    }
    if (newPosition > boundaryAfter) {
      newPosition = boundaryAfter;
    }
    if (sourceSlot === targetSlot) {
      const sourceIndex = sortedTargetTasks.indexOf(sourceInst);
      if (sourceIndex < newPosition) {
        newPosition--;
      }
    }
    const clampedPosition = Math.max(0, Math.min(newPosition, targetWithoutSource.length));
    let stateInsertIndex = 0;
    const normalizedSourceState = this.normalizeState(sourceInst.state);
    for (let i = 0; i < clampedPosition; i++) {
      const candidate = targetWithoutSource[i];
      if (this.normalizeState(candidate.state) === normalizedSourceState) {
        stateInsertIndex++;
      }
    }
    void this.moveTaskToSlot(sourceInst, targetSlot, stateInsertIndex).catch((error) => {
      console.error("[TaskChute]", "moveTaskToSlot failed", error);
    });
    this.clearDragoverClasses(taskItem);
  }
  handleSlotDrop(e, slot) {
    var _a;
    const data = (_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain");
    if (!data) return;
    const [sourceSlot, sourceIdx] = data.split("::");
    const sourceInst = this.taskInstances.find((inst) => {
      const instSlot = inst.slotKey || "none";
      const slotInstances = this.taskInstances.filter((t) => (t.slotKey || "none") === instSlot);
      const sortedSlotInstances = this.sortByOrder(slotInstances);
      const idx = sortedSlotInstances.indexOf(inst);
      return instSlot === sourceSlot && idx === parseInt(sourceIdx);
    });
    if (!sourceInst || sourceInst.state === "done") return;
    const normalizedSlot = slot || "none";
    const normalizedState = this.normalizeState(sourceInst.state);
    const sameStateTasks = this.taskInstances.filter(
      (t) => t !== sourceInst && (t.slotKey || "none") === normalizedSlot && this.normalizeState(t.state) === normalizedState
    );
    const insertIndex = sameStateTasks.length;
    void this.moveTaskToSlot(sourceInst, slot, insertIndex);
  }
  toggleNavigation() {
    this.navigationState.isOpen = !this.navigationState.isOpen;
    if (this.navigationState.isOpen) {
      this.openNavigation();
    } else {
      this.closeNavigation();
    }
  }
  openNavigation() {
    this.navigationPanel.classList.remove("navigation-panel-hidden");
    this.navigationOverlay.classList.remove("navigation-overlay-hidden");
  }
  closeNavigation() {
    this.navigationPanel.classList.add("navigation-panel-hidden");
    this.navigationOverlay.classList.add("navigation-overlay-hidden");
  }
  async setRoutineTask(task, button, scheduledTime) {
    try {
      const primaryPath = task.path || "";
      let file = primaryPath ? this.app.vault.getAbstractFileByPath(primaryPath) : null;
      if (!file) {
        const taskFolderPath = this.plugin.pathManager.getTaskFolderPath();
        const fallbackPath = `${taskFolderPath}/${task.title}.md`;
        file = this.app.vault.getAbstractFileByPath(fallbackPath);
      }
      if (!file || !(file instanceof import_obsidian11.TFile)) {
        new import_obsidian11.Notice(`\u30BF\u30B9\u30AF\u30D5\u30A1\u30A4\u30EB\u300C${task.title}.md\u300D\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093`);
        return;
      }
      await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
        frontmatter.isRoutine = true;
        frontmatter.\u958B\u59CB\u6642\u523B = scheduledTime;
        frontmatter.routine_type = "daily";
        const y = this.currentDate.getFullYear();
        const m = (this.currentDate.getMonth() + 1).toString().padStart(2, "0");
        const d = this.currentDate.getDate().toString().padStart(2, "0");
        frontmatter.routine_start = `${y}-${m}-${d}`;
        delete frontmatter.routine_end;
        return frontmatter;
      });
      task.isRoutine = true;
      task.scheduledTime = scheduledTime;
      button.classList.add("active");
      button.setAttribute("title", `\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\uFF08${scheduledTime}\u958B\u59CB\u4E88\u5B9A\uFF09`);
      await this.reloadTasksAndRestore({ runBoundaryCheck: true });
      new import_obsidian11.Notice(`\u300C${task.title}\u300D\u3092\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306B\u8A2D\u5B9A\u3057\u307E\u3057\u305F\uFF08${scheduledTime}\u958B\u59CB\u4E88\u5B9A\uFF09`);
    } catch (error) {
      console.error("Failed to set routine task:", error);
      const msg = error && (error.message || String(error)) || "";
      new import_obsidian11.Notice(`\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306E\u8A2D\u5B9A\u306B\u5931\u6557\u3057\u307E\u3057\u305F: ${msg}`);
    }
  }
  async setRoutineTaskWithDetails(task, button, scheduledTime, routineType, details) {
    try {
      const primaryPath = task.path || "";
      let file = primaryPath ? this.app.vault.getAbstractFileByPath(primaryPath) : null;
      if (!file) {
        const taskFolderPath = this.plugin.pathManager.getTaskFolderPath();
        const fallbackPath = `${taskFolderPath}/${task.title}.md`;
        file = this.app.vault.getAbstractFileByPath(fallbackPath);
      }
      if (!file || !(file instanceof import_obsidian11.TFile)) {
        new import_obsidian11.Notice(`\u30BF\u30B9\u30AF\u30D5\u30A1\u30A4\u30EB\u300C${task.title}.md\u300D\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093`);
        return;
      }
      await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
        frontmatter.isRoutine = true;
        frontmatter.\u958B\u59CB\u6642\u523B = scheduledTime;
        frontmatter.routine_type = routineType;
        frontmatter.routine_enabled = details.enabled !== false;
        frontmatter.routine_interval = Math.max(1, details.interval || 1);
        const y = this.currentDate.getFullYear();
        const m = (this.currentDate.getMonth() + 1).toString().padStart(2, "0");
        const d = this.currentDate.getDate().toString().padStart(2, "0");
        frontmatter.routine_start = `${y}-${m}-${d}`;
        delete frontmatter.routine_end;
        delete frontmatter.weekday;
        delete frontmatter.weekdays;
        delete frontmatter.monthly_week;
        delete frontmatter.monthly_weekday;
        delete frontmatter.routine_week;
        delete frontmatter.routine_weekday;
        switch (routineType) {
          case "daily":
            break;
          case "weekdays":
          case "weekends":
            break;
          case "weekly":
            if (details.weekdays && details.weekdays.length > 0) {
              const chosen = details.weekdays[0];
              frontmatter.routine_weekday = chosen;
            }
            break;
          case "monthly":
            if (details.monthly_week !== void 0 && details.monthly_weekday !== void 0) {
              const w = details.monthly_week === "last" ? "last" : typeof details.monthly_week === "number" ? details.monthly_week + 1 : void 0;
              if (w !== void 0) frontmatter.routine_week = w;
              frontmatter.routine_weekday = details.monthly_weekday;
            }
            break;
        }
        return frontmatter;
      });
      task.isRoutine = true;
      task.scheduledTime = scheduledTime;
      task.routine_type = routineType;
      task.routine_interval = Math.max(1, details.interval || 1);
      task.routine_enabled = details.enabled !== false;
      if (routineType === "weekly" && details.weekdays) {
        task.weekday = details.weekdays[0];
        task.weekdays = details.weekdays;
      } else if (routineType === "monthly") {
        task.monthly_week = details.monthly_week;
        task.monthly_weekday = details.monthly_weekday;
      }
      button.classList.add("active");
      let tooltipText = `\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\uFF08${scheduledTime}\u958B\u59CB\u4E88\u5B9A\uFF09`;
      switch (routineType) {
        case "daily":
          tooltipText += ` - ${task.routine_interval || 1}\u65E5\u3054\u3068`;
          break;
        case "weekdays":
          tooltipText += " - \u5E73\u65E5\u306E\u307F";
          break;
        case "weekends":
          tooltipText += " - \u9031\u672B\u306E\u307F";
          break;
        case "weekly":
          if (details.weekdays) {
            const dayNames = ["\u65E5", "\u6708", "\u706B", "\u6C34", "\u6728", "\u91D1", "\u571F"];
            const day = dayNames[details.weekdays[0]];
            tooltipText += ` - ${task.routine_interval || 1}\u9031\u3054\u3068 ${day}\u66DC`;
          }
          break;
        case "monthly":
          if (details.monthly_week !== void 0 && details.monthly_weekday !== void 0) {
            const dayNames = ["\u65E5", "\u6708", "\u706B", "\u6C34", "\u6728", "\u91D1", "\u571F"];
            const weekLabel = details.monthly_week === "last" ? "\u6700\u7D42" : `\u7B2C${details.monthly_week + 1}`;
            tooltipText += ` - ${task.routine_interval || 1}\u30F6\u6708\u3054\u3068 ${weekLabel}${dayNames[details.monthly_weekday]}\u66DC\u65E5`;
          }
          break;
      }
      button.setAttribute("title", tooltipText);
      await this.reloadTasksAndRestore({ runBoundaryCheck: true });
      new import_obsidian11.Notice(`\u300C${task.title}\u300D\u3092\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306B\u8A2D\u5B9A\u3057\u307E\u3057\u305F`);
    } catch (error) {
      console.error("Failed to set routine task:", error);
      const msg = error && (error.message || String(error)) || "";
      new import_obsidian11.Notice(`\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306E\u8A2D\u5B9A\u306B\u5931\u6557\u3057\u307E\u3057\u305F: ${msg}`);
    }
  }
  async deleteInstanceWithConfirm(inst) {
    const confirmed = await this.showDeleteConfirmDialog(inst);
    if (confirmed) {
      await this.deleteInstance(inst);
    }
  }
  showDeleteConfirmDialog(inst) {
    return new Promise((resolve) => {
      const modal = document.createElement("div");
      modal.className = "task-modal-overlay";
      const modalContent = modal.createEl("div", { cls: "task-modal-content" });
      modalContent.createEl("h3", { text: "\u30BF\u30B9\u30AF\u306E\u524A\u9664\u78BA\u8A8D" });
      modalContent.createEl("p", {
        text: `\u300C${inst.task.title}\u300D\u3092\u524A\u9664\u3057\u3066\u3082\u3088\u308D\u3057\u3044\u3067\u3059\u304B\uFF1F`
      });
      const buttonContainer = modalContent.createEl("div", {
        cls: "modal-button-container"
      });
      const confirmButton = buttonContainer.createEl("button", {
        text: "\u524A\u9664",
        cls: "mod-cta"
      });
      const cancelButton = buttonContainer.createEl("button", {
        text: "\u30AD\u30E3\u30F3\u30BB\u30EB"
      });
      confirmButton.addEventListener("click", () => {
        modal.remove();
        resolve(true);
      });
      cancelButton.addEventListener("click", () => {
        modal.remove();
        resolve(false);
      });
      document.body.appendChild(modal);
    });
  }
  async deleteInstance(inst) {
    try {
      await this.ensureDayStateForCurrentDate();
      const index = this.taskInstances.indexOf(inst);
      if (index > -1) {
        this.taskInstances.splice(index, 1);
      }
      const dateStr = this.getCurrentDateString();
      const dayState = this.getCurrentDayState();
      const deletedInstances = this.getDeletedInstances(dateStr);
      const isDup = this.isDuplicatedTask(inst);
      if (isDup) {
        deletedInstances.push({
          instanceId: inst.instanceId,
          path: inst.task.path,
          deletionType: "temporary",
          timestamp: Date.now()
        });
        dayState.duplicatedInstances = dayState.duplicatedInstances.filter(
          (dup) => dup.instanceId !== inst.instanceId
        );
      } else {
        if (!inst.task.isRoutine) {
          const p = inst.task.path;
          const isValidPath = typeof p === "string" && p.length > 0 && !/\/undefined\.md$/.test(p);
          if (isValidPath) {
            deletedInstances.push({
              path: p,
              deletionType: "permanent",
              timestamp: Date.now()
            });
          } else {
            deletedInstances.push({
              instanceId: inst.instanceId,
              path: p || "",
              deletionType: "temporary",
              timestamp: Date.now()
            });
          }
        } else {
          deletedInstances.push({
            instanceId: inst.instanceId,
            path: inst.task.path,
            deletionType: "temporary",
            timestamp: Date.now()
          });
        }
      }
      this.saveDeletedInstances(dateStr, deletedInstances);
      await this.persistDayState(dateStr);
      if (!inst.task.isRoutine) {
        const samePathInstances = this.taskInstances.filter(
          (i) => i.task.path === inst.task.path
        );
        if (samePathInstances.length === 0 && inst.task.file) {
          this.tasks = this.tasks.filter((t) => t.path !== inst.task.path);
          await this.app.vault.delete(inst.task.file);
          new import_obsidian11.Notice(`\u300C${inst.task.title}\u300D\u3092\u5B8C\u5168\u306B\u524A\u9664\u3057\u307E\u3057\u305F\u3002`);
        } else {
          new import_obsidian11.Notice(`\u300C${inst.task.title}\u300D\u3092\u672C\u65E5\u306E\u30EA\u30B9\u30C8\u304B\u3089\u524A\u9664\u3057\u307E\u3057\u305F\u3002`);
        }
      } else {
        new import_obsidian11.Notice(`\u300C${inst.task.title}\u300D\u3092\u672C\u65E5\u306E\u30EA\u30B9\u30C8\u304B\u3089\u524A\u9664\u3057\u307E\u3057\u305F\u3002`);
      }
      this.renderTaskList();
    } catch (error) {
      console.error("Failed to delete instance:", error);
      new import_obsidian11.Notice("\u30BF\u30B9\u30AF\u306E\u524A\u9664\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  async resetTaskToIdle(inst) {
    try {
      inst.state = "idle";
      inst.startTime = void 0;
      inst.stopTime = void 0;
      if (inst.instanceId) {
        await this.removeTaskLogForInstanceOnCurrentDate(inst.instanceId);
      }
      this.saveInstanceState(inst);
      await this.saveRunningTasksState();
      this.renderTaskList();
      new import_obsidian11.Notice(`\u300C${inst.task.title}\u300D\u3092\u30A2\u30A4\u30C9\u30EB\u72B6\u614B\u306B\u623B\u3057\u307E\u3057\u305F`);
    } catch (error) {
      console.error("Failed to reset task:", error);
      new import_obsidian11.Notice("\u30BF\u30B9\u30AF\u306E\u30EA\u30BB\u30C3\u30C8\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  async showProjectSettingsModal(inst, tooltip) {
    if (tooltip) {
      tooltip.remove();
    }
    const modal = document.createElement("div");
    modal.className = "task-modal-overlay";
    const modalContent = modal.createEl("div", { cls: "task-modal-content" });
    const modalHeader = modalContent.createEl("div", { cls: "modal-header" });
    modalHeader.createEl("h3", {
      text: `\u300C${inst.task.title}\u300D\u306E\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u8A2D\u5B9A`
    });
    const closeButton = modalHeader.createEl("button", {
      cls: "modal-close-button",
      text: "\xD7"
    });
    const form = modalContent.createEl("form", { cls: "task-form" });
    const projectGroup = form.createEl("div", { cls: "form-group" });
    projectGroup.createEl("label", { text: "\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8:", cls: "form-label" });
    const projectSelect = projectGroup.createEl("select", {
      cls: "form-select"
    });
    const projects = await this.getAvailableProjects();
    const noneOption = projectSelect.createEl("option", {
      value: "",
      text: "\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u306A\u3057"
    });
    projects.forEach((project) => {
      projectSelect.createEl("option", {
        value: project,
        text: project
      });
    });
    if (inst.task.project) {
      projectSelect.value = inst.task.project;
    }
    const buttonGroup = form.createEl("div", { cls: "form-button-group" });
    const cancelButton = buttonGroup.createEl("button", {
      type: "button",
      cls: "form-button cancel",
      text: "\u30AD\u30E3\u30F3\u30BB\u30EB"
    });
    const saveButton = buttonGroup.createEl("button", {
      type: "submit",
      cls: "form-button create",
      text: "\u4FDD\u5B58"
    });
    closeButton.addEventListener("click", () => {
      document.body.removeChild(modal);
    });
    cancelButton.addEventListener("click", () => {
      document.body.removeChild(modal);
    });
    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      const selectedProject = projectSelect.value;
      await this.updateTaskProject(inst, selectedProject);
      document.body.removeChild(modal);
    });
    document.body.appendChild(modal);
  }
  async getAvailableProjects() {
    try {
      const projectFolderPath = this.plugin.pathManager.getProjectFolderPath();
      const projectFolder = this.app.vault.getAbstractFileByPath(projectFolderPath);
      if (!projectFolder || !("children" in projectFolder)) {
        return [];
      }
      const projects = [];
      for (const file of projectFolder.children) {
        if (file instanceof import_obsidian11.TFile && file.extension === "md") {
          projects.push(file.basename);
        }
      }
      return projects;
    } catch (error) {
      console.error("Failed to get projects:", error);
      return [];
    }
  }
  async updateTaskProject(inst, projectName) {
    try {
      const taskFolderPath = this.plugin.pathManager.getTaskFolderPath();
      const filePath = `${taskFolderPath}/${inst.task.title}.md`;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file || !(file instanceof import_obsidian11.TFile)) {
        new import_obsidian11.Notice(`\u30BF\u30B9\u30AF\u30D5\u30A1\u30A4\u30EB\u300C${inst.task.title}.md\u300D\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093`);
        return;
      }
      await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
        if (projectName) {
          frontmatter.project = `[[${projectName}]]`;
        } else {
          delete frontmatter.project;
          delete frontmatter.project_path;
        }
        return frontmatter;
      });
      inst.task.project = projectName || void 0;
      const projectFolderPath = this.plugin.pathManager.getProjectFolderPath();
      inst.task.projectPath = projectName ? `${projectFolderPath}/${projectName}.md` : void 0;
      inst.task.projectTitle = projectName || void 0;
      this.renderTaskList();
      const message = projectName ? `\u300C${inst.task.title}\u300D\u3092${projectName}\u306B\u95A2\u9023\u4ED8\u3051\u307E\u3057\u305F` : `\u300C${inst.task.title}\u300D\u306E\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u95A2\u9023\u4ED8\u3051\u3092\u89E3\u9664\u3057\u307E\u3057\u305F`;
      new import_obsidian11.Notice(message);
    } catch (error) {
      console.error("Failed to update project:", error);
      new import_obsidian11.Notice("\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u306E\u66F4\u65B0\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  moveIdleTasksToCurrentTime() {
    new import_obsidian11.Notice("\u30A2\u30A4\u30C9\u30EB\u30BF\u30B9\u30AF\u79FB\u52D5\u6A5F\u80FD\u306F\u5B9F\u88C5\u4E2D\u3067\u3059");
  }
  async showAddTaskModal() {
    const modal = document.createElement("div");
    modal.className = "task-modal-overlay";
    const modalContent = modal.createEl("div", { cls: "task-modal-content" });
    const modalHeader = modalContent.createEl("div", { cls: "modal-header" });
    modalHeader.createEl("h3", { text: "\u65B0\u3057\u3044\u30BF\u30B9\u30AF\u3092\u8FFD\u52A0" });
    const closeButton = modalHeader.createEl("button", {
      cls: "modal-close-button",
      text: "\xD7"
    });
    const form = modalContent.createEl("form", { cls: "task-form" });
    const nameGroup = form.createEl("div", { cls: "form-group" });
    nameGroup.createEl("label", { text: "\u30BF\u30B9\u30AF\u540D:", cls: "form-label" });
    const nameInput = nameGroup.createEl("input", {
      type: "text",
      cls: "form-input",
      placeholder: "\u30BF\u30B9\u30AF\u540D\u3092\u5165\u529B"
    });
    try {
      const autocomplete = new TaskNameAutocomplete(this.plugin, nameInput, nameGroup, this);
      await autocomplete.initialize();
      this.autocompleteInstances.push({ cleanup: () => {
        if (typeof autocomplete.destroy === "function") {
          autocomplete.destroy();
        }
      } });
      const cleanupAuto = () => {
        if (typeof autocomplete.destroy === "function") {
          autocomplete.destroy();
        }
      };
      modal._cleanupAutocomplete = cleanupAuto;
    } catch (e) {
      console.error("[TaskChute] autocomplete init failed:", e);
    }
    const estimatedMinutes = 30;
    const buttonGroup = form.createEl("div", { cls: "form-button-group" });
    const cancelButton = buttonGroup.createEl("button", {
      type: "button",
      cls: "form-button cancel",
      text: "\u30AD\u30E3\u30F3\u30BB\u30EB"
    });
    const saveButton = buttonGroup.createEl("button", {
      type: "submit",
      cls: "form-button create",
      text: "\u4FDD\u5B58"
    });
    const closeModal = () => {
      var _a;
      try {
        (_a = modal._cleanupAutocomplete) == null ? void 0 : _a.call(modal);
      } catch (_) {
      }
      document.body.removeChild(modal);
    };
    closeButton.addEventListener("click", closeModal);
    cancelButton.addEventListener("click", closeModal);
    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      const taskName = nameInput.value.trim();
      if (!taskName) {
        new import_obsidian11.Notice("\u30BF\u30B9\u30AF\u540D\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044");
        return;
      }
      await this.createNewTask(taskName, estimatedMinutes);
      closeModal();
    });
    document.body.appendChild(modal);
    nameInput.focus();
  }
  async createNewTask(taskName, estimatedMinutes) {
    try {
      const dateStr = this.getCurrentDateString();
      const file = await this.taskCreationService.createTaskFile(taskName, dateStr);
      await this.waitForFrontmatter(file);
      await this.reloadTasksAndRestore({ runBoundaryCheck: true });
    } catch (error) {
      console.error("Failed to create task:", error);
      new import_obsidian11.Notice("\u30BF\u30B9\u30AF\u306E\u4F5C\u6210\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  async waitForFrontmatter(file, timeoutMs = 4e3) {
    const start = Date.now();
    const path = file.path;
    const hasFrontmatter = () => {
      const cache = this.app.metadataCache.getFileCache(file);
      return Boolean(cache == null ? void 0 : cache.frontmatter);
    };
    if (hasFrontmatter()) {
      return;
    }
    while (Date.now() - start < timeoutMs) {
      await new Promise((resolve) => window.setTimeout(resolve, 120));
      if (hasFrontmatter()) {
        return;
      }
    }
  }
  persistSlotAssignment(inst) {
    var _a;
    if ((_a = inst.task) == null ? void 0 : _a.path) {
      if (!this.plugin.settings.slotKeys) {
        this.plugin.settings.slotKeys = {};
      }
      this.plugin.settings.slotKeys[inst.task.path] = inst.slotKey || "none";
      void this.plugin.saveSettings();
    }
    if (inst.instanceId) {
      const dayState = this.getCurrentDayState();
      const key = this.getOrderKey(inst);
      if (key && dayState.orders && dayState.orders[key] != null) {
      }
      if (Array.isArray(dayState.duplicatedInstances)) {
        const dup = dayState.duplicatedInstances.find((d) => d.instanceId === inst.instanceId);
        if (dup) {
          dup.slotKey = inst.slotKey;
        }
      }
    }
  }
  async showTaskMoveDatePicker(inst, button) {
    const modal = document.createElement("div");
    modal.className = "task-modal-overlay";
    const modalContent = modal.createEl("div", { cls: "task-modal-content" });
    modalContent.createEl("h3", { text: "\u30BF\u30B9\u30AF\u3092\u79FB\u52D5" });
    const dateInput = modalContent.createEl("input", {
      type: "date",
      value: this.getCurrentDateString()
    });
    const buttonContainer = modalContent.createEl("div", {
      cls: "modal-button-container"
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "\u30AD\u30E3\u30F3\u30BB\u30EB"
    });
    const moveButton = buttonContainer.createEl("button", {
      text: "\u79FB\u52D5",
      cls: "mod-cta"
    });
    cancelButton.addEventListener("click", () => {
      modal.remove();
    });
    moveButton.addEventListener("click", async () => {
      const newDate = dateInput.value;
      if (newDate) {
        await this.moveTaskToDate(inst, newDate);
        modal.remove();
      }
    });
    document.body.appendChild(modal);
  }
  async moveTaskToDate(inst, dateStr) {
    try {
      const file = this.app.vault.getAbstractFileByPath(inst.task.path);
      if (file instanceof import_obsidian11.TFile) {
        await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
          frontmatter.target_date = dateStr;
          return frontmatter;
        });
      }
      new import_obsidian11.Notice(`\u30BF\u30B9\u30AF\u300C${inst.task.title}\u300D\u3092${dateStr}\u306B\u79FB\u52D5\u3057\u307E\u3057\u305F`);
      await this.reloadTasksAndRestore();
    } catch (error) {
      console.error("Failed to move task:", error);
      new import_obsidian11.Notice("\u30BF\u30B9\u30AF\u306E\u79FB\u52D5\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  async showProjectModal(inst) {
    await this.showUnifiedProjectModal(inst);
  }
  async showUnifiedProjectModal(inst) {
    try {
      const modal = document.createElement("div");
      modal.className = "task-modal-overlay";
      const modalContent = modal.createEl("div", { cls: "task-modal-content" });
      const modalHeader = modalContent.createEl("div", { cls: "modal-header" });
      modalHeader.createEl("h3", {
        text: `\u300C${inst.task.title}\u300D\u306E\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u8A2D\u5B9A`
      });
      const closeButton = modalHeader.createEl("button", {
        cls: "modal-close-button",
        text: "\xD7",
        attr: { title: "\u9589\u3058\u308B" }
      });
      const form = modalContent.createEl("form", { cls: "task-form" });
      let projectFiles = [];
      try {
        projectFiles = await this.getProjectFiles();
      } catch (error) {
        new import_obsidian11.Notice("\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30EA\u30B9\u30C8\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
        modal.remove();
        return;
      }
      if (projectFiles.length === 0) {
        const noProjectGroup = form.createEl("div", { cls: "form-group" });
        noProjectGroup.createEl("p", {
          text: "\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30D5\u30A1\u30A4\u30EB\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002",
          cls: "form-description"
        });
        noProjectGroup.createEl("p", {
          text: "\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30D5\u30A1\u30A4\u30EB\u306B #project \u30BF\u30B0\u3092\u8FFD\u52A0\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
          cls: "form-description"
        });
      } else {
        const projectGroup = form.createEl("div", { cls: "form-group" });
        projectGroup.createEl("label", {
          text: "\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3092\u9078\u629E:",
          cls: "form-label"
        });
        const projectSelect = projectGroup.createEl("select", {
          cls: "form-input"
        });
        if (inst.task.projectPath) {
          const removeProjectOption = projectSelect.createEl("option", {
            value: "",
            text: "\u2796 \u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3092\u5916\u3059"
          });
        } else {
          const emptyOption = projectSelect.createEl("option", {
            value: "",
            text: ""
          });
          emptyOption.selected = true;
        }
        projectFiles.forEach((project) => {
          const option = projectSelect.createEl("option", {
            value: project.path,
            text: project.basename
          });
          if (inst.task.projectPath === project.path) {
            option.selected = true;
          }
        });
        const descGroup = form.createEl("div", { cls: "form-group" });
        if (inst.task.projectPath) {
          descGroup.createEl("p", {
            text: "\u5225\u306E\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3092\u9078\u629E\u3059\u308B\u304B\u3001\u300C\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3092\u5916\u3059\u300D\u3092\u9078\u629E\u3057\u3066\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3092\u89E3\u9664\u3067\u304D\u307E\u3059\u3002",
            cls: "form-description"
          });
        } else {
          descGroup.createEl("p", {
            text: "\u30BF\u30B9\u30AF\u306B\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3092\u8A2D\u5B9A\u3059\u308B\u3068\u3001\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30DA\u30FC\u30B8\u304B\u3089\u95A2\u9023\u30BF\u30B9\u30AF\u3092\u78BA\u8A8D\u3067\u304D\u307E\u3059\u3002",
            cls: "form-description"
          });
        }
        const buttonGroup = form.createEl("div", { cls: "form-button-group" });
        const cancelButton = buttonGroup.createEl("button", {
          type: "button",
          cls: "form-button cancel",
          text: "\u30AD\u30E3\u30F3\u30BB\u30EB"
        });
        const saveButton = buttonGroup.createEl("button", {
          type: "submit",
          cls: "form-button create",
          text: "\u4FDD\u5B58"
        });
        form.addEventListener("submit", async (e) => {
          e.preventDefault();
          const selectedProject = projectSelect.value;
          await this.setProjectForTask(inst.task, selectedProject);
          this.updateProjectDisplay(inst);
          modal.remove();
        });
        cancelButton.addEventListener("click", () => {
          modal.remove();
        });
      }
      closeButton.addEventListener("click", () => {
        modal.remove();
      });
      document.body.appendChild(modal);
    } catch (error) {
      console.error("Failed to show project modal:", error);
      new import_obsidian11.Notice("\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u9078\u629E\u753B\u9762\u306E\u8868\u793A\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  async getProjectFiles() {
    const files = this.app.vault.getMarkdownFiles();
    const projectFiles = [];
    const projectFolderPath = this.plugin.pathManager.getProjectFolderPath();
    for (const file of files) {
      if (file.path.startsWith(projectFolderPath + "/") && file.basename.startsWith("Project - ")) {
        projectFiles.push(file);
        continue;
      }
      if (file.basename.startsWith("Project - ")) {
        projectFiles.push(file);
        continue;
      }
      const content = await this.app.vault.read(file);
      if (content.includes("#project")) {
        projectFiles.push(file);
      }
    }
    return projectFiles;
  }
  async setProjectForTask(task, projectPath) {
    try {
      if (!task.file || !(task.file instanceof import_obsidian11.TFile)) {
        new import_obsidian11.Notice("\u30BF\u30B9\u30AF\u30D5\u30A1\u30A4\u30EB\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093");
        return;
      }
      await this.app.fileManager.processFrontMatter(
        task.file,
        (frontmatter) => {
          if (projectPath) {
            const projectFile = this.app.vault.getAbstractFileByPath(projectPath);
            if (projectFile) {
              frontmatter.project = `[[${projectFile.basename}]]`;
              delete frontmatter.project_path;
            }
          } else {
            delete frontmatter.project;
            delete frontmatter.project_path;
          }
          return frontmatter;
        }
      );
      if (projectPath) {
        const projectFile = this.app.vault.getAbstractFileByPath(projectPath);
        if (projectFile) {
          task.projectPath = projectPath;
          task.projectTitle = projectFile.basename;
        }
      } else {
        task.projectPath = null;
        task.projectTitle = null;
      }
      new import_obsidian11.Notice(`\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u8A2D\u5B9A\u3092\u4FDD\u5B58\u3057\u307E\u3057\u305F`);
    } catch (error) {
      console.error("Failed to set project:", error);
      new import_obsidian11.Notice("\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u8A2D\u5B9A\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  updateProjectDisplay(inst) {
    var _a;
    const taskItem = (_a = this.taskList) == null ? void 0 : _a.querySelector(
      `[data-task-path="${inst.task.path}"]`
    );
    if (taskItem) {
      const projectDisplay = taskItem.querySelector(
        ".taskchute-project-display"
      );
      if (projectDisplay) {
        projectDisplay.empty();
        if (inst.task.projectPath && inst.task.projectTitle) {
          const projectButton = projectDisplay.createEl("span", {
            cls: "taskchute-project-button",
            attr: {
              title: `\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8: ${inst.task.projectTitle}`
            }
          });
          const folderIcon = projectButton.createEl("span", {
            cls: "taskchute-project-icon",
            text: "\u{1F4C1}"
          });
          const projectName = projectButton.createEl("span", {
            cls: "taskchute-project-name",
            text: inst.task.projectTitle.replace(/^Project\s*-\s*/, "")
          });
          projectButton.addEventListener("click", async (e) => {
            e.stopPropagation();
            await this.showUnifiedProjectModal(inst);
          });
          const externalLinkIcon = projectDisplay.createEl("span", {
            cls: "taskchute-external-link",
            text: "\u{1F517}",
            attr: { title: "\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30CE\u30FC\u30C8\u3092\u958B\u304F" }
          });
          externalLinkIcon.addEventListener("click", async (e) => {
            e.stopPropagation();
            await this.openProjectInSplit(inst.task.projectPath);
          });
        } else {
          const projectPlaceholder = projectDisplay.createEl("span", {
            cls: "taskchute-project-placeholder",
            attr: { title: "\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3092\u8A2D\u5B9A" }
          });
          projectPlaceholder.addEventListener("click", async (e) => {
            e.stopPropagation();
            await this.showProjectModal(inst);
          });
        }
      }
    }
  }
  async openProjectInSplit(projectPath) {
    try {
      const file = this.app.vault.getAbstractFileByPath(projectPath);
      if (file instanceof import_obsidian11.TFile) {
        const leaf = this.app.workspace.getLeaf("split");
        await leaf.openFile(file);
      } else {
        new import_obsidian11.Notice(`\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30D5\u30A1\u30A4\u30EB\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093: ${projectPath}`);
      }
    } catch (error) {
      console.error("Failed to open project:", error);
      new import_obsidian11.Notice("\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30D5\u30A1\u30A4\u30EB\u3092\u958B\u3051\u307E\u305B\u3093\u3067\u3057\u305F");
    }
  }
  async hasExecutionHistory(taskPath) {
    return false;
  }
  async handleFileRename(file, oldPath) {
  }
  moveInstanceToSlot(fromSlot, fromIdx, toSlot, toIdx) {
  }
  // State management methods for deletion/hiding
  getDeletedInstances(dateStr) {
    const state = this.dayStateCache.get(dateStr);
    return state ? state.deletedInstances : [];
  }
  saveDeletedInstances(dateStr, instances) {
    const state = this.dayStateCache.get(dateStr) || {
      hiddenRoutines: [],
      deletedInstances: [],
      duplicatedInstances: [],
      orders: {}
    };
    state.deletedInstances = instances.filter((x) => !!x);
    this.dayStateCache.set(dateStr, state);
    void this.persistDayState(dateStr);
  }
  getHiddenRoutines(dateStr) {
    const state = this.dayStateCache.get(dateStr);
    return state ? state.hiddenRoutines : [];
  }
  saveHiddenRoutines(dateStr, routines) {
    const state = this.dayStateCache.get(dateStr) || {
      hiddenRoutines: [],
      deletedInstances: [],
      duplicatedInstances: [],
      orders: {}
    };
    state.hiddenRoutines = (routines || []).filter((x) => !!x);
    this.dayStateCache.set(dateStr, state);
    void this.persistDayState(dateStr);
  }
  isInstanceDeleted(instanceId, taskPath, dateStr) {
    const deletedInstances = this.getDeletedInstances(dateStr);
    return deletedInstances.some((del) => {
      if (instanceId && del.instanceId === instanceId) return true;
      if (del.deletionType === "permanent" && del.path === taskPath) return true;
      return false;
    });
  }
  isInstanceHidden(instanceId, taskPath, dateStr) {
    const hiddenRoutines = this.getHiddenRoutines(dateStr);
    return hiddenRoutines.some((hidden) => {
      if (hidden.instanceId && hidden.instanceId === instanceId) return true;
      if (hidden.instanceId === null && hidden.path && hidden.path === taskPath) return true;
      return false;
    });
  }
};

// src/services/DayStateService.ts
var import_obsidian12 = require("obsidian");
var DAY_STATE_VERSION = "1.0";
function cloneDayState(state) {
  return JSON.parse(JSON.stringify(state));
}
function cloneMonthlyState(state) {
  return JSON.parse(JSON.stringify(state));
}
function createEmptyDayState() {
  return {
    hiddenRoutines: [],
    deletedInstances: [],
    duplicatedInstances: [],
    orders: {}
  };
}
var DayStateService = class {
  constructor(plugin) {
    this.cache = /* @__PURE__ */ new Map();
    this.plugin = plugin;
  }
  getMonthKey(date) {
    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, "0");
    return `${y}-${m}`;
  }
  getDateKey(date) {
    const y = date.getFullYear();
    const m = String(date.getMonth() + 1).padStart(2, "0");
    const d = String(date.getDate()).padStart(2, "0");
    return `${y}-${m}-${d}`;
  }
  getStatePath(monthKey) {
    const base = this.plugin.pathManager.getLogDataPath();
    return `${base}/${monthKey}-state.json`;
  }
  ensureMetadata(state) {
    if (!state.metadata) {
      state.metadata = { version: DAY_STATE_VERSION, lastUpdated: (/* @__PURE__ */ new Date()).toISOString() };
      return;
    }
    if (!state.metadata.version) {
      state.metadata.version = DAY_STATE_VERSION;
    }
    if (!state.metadata.lastUpdated) {
      state.metadata.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
    }
  }
  normalizeMonthlyState(state) {
    const normalized = {
      days: {},
      metadata: {
        version: DAY_STATE_VERSION,
        lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
      }
    };
    if (state && typeof state === "object") {
      if (state.days && typeof state.days === "object") {
        for (const [key, value] of Object.entries(state.days)) {
          normalized.days[key] = this.normalizeDayState(value);
        }
      }
      if (state.metadata) {
        normalized.metadata.version = state.metadata.version || DAY_STATE_VERSION;
        normalized.metadata.lastUpdated = state.metadata.lastUpdated || (/* @__PURE__ */ new Date()).toISOString();
      }
    }
    return normalized;
  }
  normalizeDayState(value) {
    const day = createEmptyDayState();
    if (!value || typeof value !== "object") {
      return day;
    }
    if (Array.isArray(value.hiddenRoutines)) {
      day.hiddenRoutines = value.hiddenRoutines.filter(Boolean);
    }
    if (Array.isArray(value.deletedInstances)) {
      day.deletedInstances = value.deletedInstances.filter(Boolean);
    }
    if (Array.isArray(value.duplicatedInstances)) {
      day.duplicatedInstances = value.duplicatedInstances.filter(Boolean);
    }
    if (value.orders && typeof value.orders === "object") {
      const entries = Object.entries(value.orders).filter(
        ([key, val]) => typeof key === "string" && typeof val === "number"
      );
      day.orders = Object.fromEntries(entries);
    }
    return day;
  }
  async loadMonth(monthKey) {
    if (this.cache.has(monthKey)) {
      return this.cache.get(monthKey);
    }
    const path = this.getStatePath(monthKey);
    const existing = this.plugin.app.vault.getAbstractFileByPath(path);
    let monthly;
    if (existing && existing instanceof import_obsidian12.TFile) {
      try {
        const raw = await this.plugin.app.vault.read(existing);
        const parsed = raw ? JSON.parse(raw) : {};
        monthly = this.normalizeMonthlyState(parsed);
      } catch (error) {
        console.error("[TaskChute] Failed to parse day state file:", error);
        monthly = this.normalizeMonthlyState({});
      }
    } else {
      monthly = this.normalizeMonthlyState({});
      await this.plugin.pathManager.ensureFolderExists(
        this.plugin.pathManager.getLogDataPath()
      );
      await this.plugin.app.vault.create(path, JSON.stringify(monthly, null, 2));
    }
    this.ensureMetadata(monthly);
    this.cache.set(monthKey, monthly);
    return monthly;
  }
  async writeMonth(monthKey, month) {
    const path = this.getStatePath(monthKey);
    const file = this.plugin.app.vault.getAbstractFileByPath(path);
    const payload = JSON.stringify(month, null, 2);
    if (file && file instanceof import_obsidian12.TFile) {
      await this.plugin.app.vault.modify(file, payload);
    } else {
      await this.plugin.pathManager.ensureFolderExists(
        this.plugin.pathManager.getLogDataPath()
      );
      await this.plugin.app.vault.create(path, payload);
    }
    this.cache.set(monthKey, month);
  }
  areDayStatesEqual(a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
  }
  async loadDay(date) {
    const monthKey = this.getMonthKey(date);
    const dateKey = this.getDateKey(date);
    const month = await this.loadMonth(monthKey);
    if (!month.days[dateKey]) {
      month.days[dateKey] = createEmptyDayState();
      month.metadata.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
      await this.writeMonth(monthKey, month);
    }
    return cloneDayState(month.days[dateKey]);
  }
  async saveDay(date, state) {
    var _a;
    const monthKey = this.getMonthKey(date);
    const dateKey = this.getDateKey(date);
    const month = await this.loadMonth(monthKey);
    const existing = (_a = month.days[dateKey]) != null ? _a : createEmptyDayState();
    if (this.areDayStatesEqual(existing, state)) {
      return;
    }
    month.days[dateKey] = cloneDayState(state);
    month.metadata.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
    await this.writeMonth(monthKey, month);
  }
  async updateDay(date, mutator) {
    var _a;
    const monthKey = this.getMonthKey(date);
    const dateKey = this.getDateKey(date);
    const month = await this.loadMonth(monthKey);
    const current = (_a = month.days[dateKey]) != null ? _a : createEmptyDayState();
    const working = cloneDayState(current);
    const result = mutator(working) || working;
    if (!this.areDayStatesEqual(current, result)) {
      month.days[dateKey] = cloneDayState(result);
      month.metadata.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
      await this.writeMonth(monthKey, month);
    }
    return cloneDayState(month.days[dateKey]);
  }
  async mergeDayState(date, partial) {
    await this.updateDay(date, (state) => {
      var _a;
      if (partial.hiddenRoutines) {
        const existing = new Map(
          state.hiddenRoutines.map((item) => {
            var _a2;
            if (typeof item === "string") {
              return [item, item];
            }
            const key = `${item.path || ""}::${(_a2 = item.instanceId) != null ? _a2 : ""}`;
            return [key, item];
          })
        );
        for (const item of partial.hiddenRoutines) {
          if (typeof item === "string") {
            existing.set(item, item);
          } else if (item) {
            const key = `${item.path || ""}::${(_a = item.instanceId) != null ? _a : ""}`;
            existing.set(key, item);
          }
        }
        state.hiddenRoutines = Array.from(existing.values());
      }
      if (partial.deletedInstances) {
        const existing = new Map(
          state.deletedInstances.map((item) => {
            const key = `${item.deletionType || ""}::${item.path || ""}::${item.instanceId || ""}`;
            return [key, item];
          })
        );
        for (const item of partial.deletedInstances) {
          if (!item) continue;
          const key = `${item.deletionType || ""}::${item.path || ""}::${item.instanceId || ""}`;
          existing.set(key, item);
        }
        state.deletedInstances = Array.from(existing.values());
      }
      if (partial.duplicatedInstances) {
        const existing = new Map(
          state.duplicatedInstances.map((item) => [item.instanceId, item])
        );
        for (const item of partial.duplicatedInstances) {
          if (!item || !item.instanceId) continue;
          existing.set(item.instanceId, item);
        }
        state.duplicatedInstances = Array.from(existing.values());
      }
      if (partial.orders) {
        state.orders = {
          ...state.orders,
          ...partial.orders
        };
      }
      return state;
    });
  }
  async clearCache() {
    this.cache.clear();
  }
  cloneDayState(state) {
    return cloneDayState(state);
  }
  cloneMonthlyState(state) {
    return cloneMonthlyState(state);
  }
  getDateFromKey(dateKey) {
    const [y, m, d] = dateKey.split("-").map((value) => parseInt(value, 10));
    return new Date(y, m - 1, d);
  }
};
var DayStateService_default = DayStateService;

// src/main.ts
var VIEW_TYPE_TASKCHUTE = "taskchute-view";
var TaskChuteSettingTab = class extends import_obsidian13.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian13.Setting(containerEl).setName("\u30D1\u30B9\u8A2D\u5B9A").setHeading();
    new import_obsidian13.Setting(containerEl).setName("\u30BF\u30B9\u30AF\u30D5\u30A9\u30EB\u30C0\u30D1\u30B9").setDesc("\u30BF\u30B9\u30AF\u30D5\u30A1\u30A4\u30EB\u3092\u4FDD\u5B58\u3059\u308B\u30D5\u30A9\u30EB\u30C0\u306E\u30D1\u30B9").addText((text) => {
      text.setPlaceholder(PathManager.DEFAULT_PATHS.taskFolder).setValue(this.plugin.settings.taskFolderPath || "").onChange(async (value) => {
        const validation = this.plugin.pathManager.validatePath(value);
        if (validation.valid || value === "") {
          this.plugin.settings.taskFolderPath = value;
          await this.plugin.saveSettings();
        } else {
          new import_obsidian13.Notice(validation.error);
          text.setValue(this.plugin.settings.taskFolderPath || "");
        }
      });
      text.inputEl.addEventListener("blur", async () => {
        if (this.plugin.settings.taskFolderPath || !this.plugin.settings.taskFolderPath) {
          try {
            await this.plugin.pathManager.ensureFolderExists(
              this.plugin.pathManager.getTaskFolderPath()
            );
          } catch (error) {
          }
        }
      });
    });
    new import_obsidian13.Setting(containerEl).setName("\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30D5\u30A9\u30EB\u30C0\u30D1\u30B9").setDesc("\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30D5\u30A1\u30A4\u30EB\u3092\u4FDD\u5B58\u3059\u308B\u30D5\u30A9\u30EB\u30C0\u306E\u30D1\u30B9").addText((text) => {
      text.setPlaceholder(PathManager.DEFAULT_PATHS.projectFolder).setValue(this.plugin.settings.projectFolderPath || "").onChange(async (value) => {
        const validation = this.plugin.pathManager.validatePath(value);
        if (validation.valid || value === "") {
          this.plugin.settings.projectFolderPath = value;
          await this.plugin.saveSettings();
        } else {
          new import_obsidian13.Notice(validation.error);
          text.setValue(this.plugin.settings.projectFolderPath || "");
        }
      });
    });
    new import_obsidian13.Setting(containerEl).setName("\u30ED\u30B0\u30C7\u30FC\u30BF\u30D1\u30B9").setDesc("\u30ED\u30B0\u30C7\u30FC\u30BF\u3092\u4FDD\u5B58\u3059\u308B\u30D5\u30A9\u30EB\u30C0\u306E\u30D1\u30B9").addText((text) => {
      text.setPlaceholder(PathManager.DEFAULT_PATHS.logData).setValue(this.plugin.settings.logDataPath || "").onChange(async (value) => {
        const validation = this.plugin.pathManager.validatePath(value);
        if (validation.valid || value === "") {
          this.plugin.settings.logDataPath = value;
          await this.plugin.saveSettings();
        } else {
          new import_obsidian13.Notice(validation.error);
          text.setValue(this.plugin.settings.logDataPath || "");
        }
      });
    });
    new import_obsidian13.Setting(containerEl).setName("\u30EC\u30D3\u30E5\u30FC\u30C7\u30FC\u30BF\u30D1\u30B9").setDesc("\u30EC\u30D3\u30E5\u30FC\u30C7\u30FC\u30BF\u3092\u4FDD\u5B58\u3059\u308B\u30D5\u30A9\u30EB\u30C0\u306E\u30D1\u30B9").addText((text) => {
      text.setPlaceholder(PathManager.DEFAULT_PATHS.reviewData).setValue(this.plugin.settings.reviewDataPath || "").onChange(async (value) => {
        const validation = this.plugin.pathManager.validatePath(value);
        if (validation.valid || value === "") {
          this.plugin.settings.reviewDataPath = value;
          await this.plugin.saveSettings();
        } else {
          new import_obsidian13.Notice(validation.error);
          text.setValue(this.plugin.settings.reviewDataPath || "");
        }
      });
    });
    new import_obsidian13.Setting(containerEl).setName("\u8996\u899A\u52B9\u679C\u8A2D\u5B9A").setHeading();
    new import_obsidian13.Setting(containerEl).setName("\u52B9\u679C\u97F3\u3092\u6709\u52B9\u5316").setDesc("\u30BF\u30B9\u30AF\u5B8C\u4E86\u6642\u306B\u52B9\u679C\u97F3\u3092\u518D\u751F\u3059\u308B").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableSound).onChange(async (value) => {
        this.plugin.settings.enableSound = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian13.Setting(containerEl).setName("\u82B1\u706B\u30A8\u30D5\u30A7\u30AF\u30C8\u3092\u6709\u52B9\u5316").setDesc("\u30BF\u30B9\u30AF\u5B8C\u4E86\u6642\u306B\u82B1\u706B\u30A8\u30D5\u30A7\u30AF\u30C8\u3092\u8868\u793A\u3059\u308B").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableFireworks).onChange(async (value) => {
        this.plugin.settings.enableFireworks = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian13.Setting(containerEl).setName("\u7D19\u5439\u96EA\u30A8\u30D5\u30A7\u30AF\u30C8\u3092\u6709\u52B9\u5316").setDesc("\u30BF\u30B9\u30AF\u5B8C\u4E86\u6642\u306B\u7D19\u5439\u96EA\u30A8\u30D5\u30A7\u30AF\u30C8\u3092\u8868\u793A\u3059\u308B").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableConfetti).onChange(async (value) => {
        this.plugin.settings.enableConfetti = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
var TaskChutePlusPlugin = class extends import_obsidian13.Plugin {
  // Simple logger/notification wrapper
  _log(level, ...args) {
    var _a;
    try {
      (_a = console[level || "log"]) == null ? void 0 : _a.call(console, ...args);
    } catch (_) {
    }
  }
  _notify(message, timeout) {
    try {
      new import_obsidian13.Notice(message, timeout);
    } catch (_) {
      this._log("warn", "[Notice]", message);
    }
  }
  async onload() {
    const loaded = await this.loadData() || {};
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loaded);
    if (!this.settings.slotKeys) this.settings.slotKeys = {};
    if (typeof this.settings.useOrderBasedSort !== "boolean") {
      this.settings.useOrderBasedSort = true;
    }
    this.pathManager = new PathManager(this);
    this.dayStateService = new DayStateService_default(this);
    this.routineAliasManager = new RoutineAliasManager(this);
    await this.routineAliasManager.loadAliases();
    await this.ensureRequiredFolders();
    try {
      this.addSettingTab(new TaskChuteSettingTab(this.app, this));
    } catch (error) {
      this._log("warn", "Settings tab not available:", error);
    }
    this.registerView(
      VIEW_TYPE_TASKCHUTE,
      (leaf) => new TaskChuteView(leaf, this)
    );
    this.addRibbonIcon("checkmark", "TaskChute\u3092\u958B\u304F", () => {
      this.activateTaskChuteView();
    });
    this.registerCommands();
  }
  async onunload() {
    if (this.globalTimerInterval) {
      clearInterval(this.globalTimerInterval);
      this.globalTimerInterval = null;
    }
    const view = this.getTaskChuteView();
    if (view && view.boundaryCheckTimeout) {
      clearTimeout(view.boundaryCheckTimeout);
      view.boundaryCheckTimeout = null;
    }
    this.app.workspace.getLeavesOfType(VIEW_TYPE_TASKCHUTE).forEach((leaf) => {
      if (leaf.view && leaf.view.onunload) {
        leaf.view.onunload();
      }
    });
    try {
      const today = /* @__PURE__ */ new Date();
      const cutoffDate = new Date(today);
      cutoffDate.setDate(today.getDate() - 30);
      const keysToCheck = Object.keys(localStorage);
      keysToCheck.forEach((key) => {
        const dateMatch = key.match(/taskchute-.*-(\d{4}-\d{2}-\d{2})/);
        if (dateMatch) {
          const keyDate = new Date(dateMatch[1]);
          if (keyDate < cutoffDate) {
            localStorage.removeItem(key);
          }
        }
      });
    } catch (error) {
    }
  }
  registerCommands() {
    this.addCommand({
      id: "open-taskchute-view",
      name: "TaskChute\u3092\u958B\u304F",
      callback: () => {
        this.activateTaskChuteView();
      }
    });
    this.addCommand({
      id: "taskchute-settings",
      name: "TaskChute\u8A2D\u5B9A",
      callback: () => {
        this.showSettingsModal();
      }
    });
    this.addCommand({
      id: "duplicate-selected-task",
      name: "\u9078\u629E\u3055\u308C\u305F\u30BF\u30B9\u30AF\u3092\u8907\u88FD",
      // ホットキーはデフォルトで設定しない
      callback: async () => {
        await this.triggerDuplicateSelectedTask();
      }
    });
    this.addCommand({
      id: "delete-selected-task",
      name: "\u9078\u629E\u3055\u308C\u305F\u30BF\u30B9\u30AF\u3092\u524A\u9664",
      // ホットキーはデフォルトで設定しない
      callback: async () => {
        await this.triggerDeleteSelectedTask();
      }
    });
    this.addCommand({
      id: "reset-selected-task",
      name: "\u9078\u629E\u3055\u308C\u305F\u30BF\u30B9\u30AF\u3092\u672A\u5B9F\u884C\u306B\u623B\u3059",
      callback: async () => {
        await this.triggerResetSelectedTask();
      }
    });
    this.addCommand({
      id: "show-today-tasks",
      name: "\u4ECA\u65E5\u306E\u30BF\u30B9\u30AF\u3092\u8868\u793A",
      description: "Show today's tasks",
      hotkeys: [
        {
          modifiers: ["Alt"],
          key: "t"
        }
      ],
      callback: async () => {
        await this.triggerShowTodayTasks();
      }
    });
    this.addCommand({
      id: "reorganize-idle-tasks",
      name: "\u672A\u5B9F\u884C\u30BF\u30B9\u30AF\u3092\u73FE\u5728\u306E\u6642\u9593\u5E2F\u306B\u6574\u7406",
      callback: () => {
        const view = this.getTaskChuteView();
        if (view) {
          view.reorganizeIdleTasks();
        } else {
          new import_obsidian13.Notice("TaskChute\u30D3\u30E5\u30FC\u304C\u958B\u304B\u308C\u3066\u3044\u307E\u305B\u3093");
        }
      }
    });
  }
  async ensureRequiredFolders() {
    const targets = [
      ["\u30BF\u30B9\u30AF\u30D5\u30A9\u30EB\u30C0", () => this.pathManager.getTaskFolderPath()],
      ["\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30D5\u30A9\u30EB\u30C0", () => this.pathManager.getProjectFolderPath()],
      ["\u30ED\u30B0\u30C7\u30FC\u30BF\u30D5\u30A9\u30EB\u30C0", () => this.pathManager.getLogDataPath()],
      ["\u30EC\u30D3\u30E5\u30FC\u30C7\u30FC\u30BF\u30D5\u30A9\u30EB\u30C0", () => this.pathManager.getReviewDataPath()]
    ];
    for (const [label, getter] of targets) {
      try {
        const path = getter();
        await this.pathManager.ensureFolderExists(path);
      } catch (error) {
        try {
          new import_obsidian13.Notice(`${label}\u306E\u4F5C\u6210\u306B\u5931\u6557\u3057\u307E\u3057\u305F`);
        } catch (_) {
        }
      }
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  getTaskChuteView() {
    const leaf = this.app.workspace.getLeavesOfType(VIEW_TYPE_TASKCHUTE)[0];
    if (!leaf || !leaf.view) return null;
    try {
      const view = leaf.view;
      if (typeof view.getViewType === "function" && view.getViewType() === VIEW_TYPE_TASKCHUTE) {
        return view;
      }
    } catch (_) {
    }
    return null;
  }
  // Ensure we have a fresh (current code) view instance.
  // If missing or missing required methods, detach and reopen.
  async getOrCreateTaskChuteView(requiredMethods = []) {
    let view = this.getTaskChuteView();
    const hasAll = (v) => requiredMethods.every((m) => typeof (v == null ? void 0 : v[m]) === "function");
    if (view && hasAll(view)) return view;
    try {
      this.app.workspace.detachLeavesOfType(VIEW_TYPE_TASKCHUTE);
    } catch (_) {
    }
    await this.activateTaskChuteView();
    await new Promise((r) => setTimeout(r, 50));
    view = this.getTaskChuteView();
    if (view && hasAll(view)) return view;
    return view;
  }
  // Command bridges with back-compat/fallbacks
  async triggerShowTodayTasks() {
    const view = await this.getOrCreateTaskChuteView(["showTodayTasks"]);
    if (view && typeof view.showTodayTasks === "function") {
      view.showTodayTasks();
      return;
    }
    await this.activateTaskChuteView();
  }
  async triggerDuplicateSelectedTask() {
    const view = await this.getOrCreateTaskChuteView(["duplicateSelectedTask", "duplicateInstance"]);
    if (!view) {
      new import_obsidian13.Notice("TaskChute\u30D3\u30E5\u30FC\u304C\u958B\u304B\u308C\u3066\u3044\u307E\u305B\u3093");
      return;
    }
    const v = view;
    if (typeof v.duplicateSelectedTask === "function") {
      await v.duplicateSelectedTask();
      return;
    }
    if (view.selectedTaskInstance && typeof v.duplicateInstance === "function") {
      await v.duplicateInstance(view.selectedTaskInstance);
    } else {
      new import_obsidian13.Notice("\u30BF\u30B9\u30AF\u304C\u9078\u629E\u3055\u308C\u3066\u3044\u307E\u305B\u3093");
    }
  }
  async triggerDeleteSelectedTask() {
    const view = await this.getOrCreateTaskChuteView(["deleteSelectedTask"]);
    if (!view) {
      new import_obsidian13.Notice("TaskChute\u30D3\u30E5\u30FC\u304C\u958B\u304B\u308C\u3066\u3044\u307E\u305B\u3093");
      return;
    }
    const v = view;
    if (typeof v.deleteSelectedTask === "function") {
      v.deleteSelectedTask();
      return;
    }
    if (view.selectedTaskInstance && typeof v.deleteTask === "function") {
      v.deleteTask(view.selectedTaskInstance);
    } else {
      new import_obsidian13.Notice("\u30BF\u30B9\u30AF\u304C\u9078\u629E\u3055\u308C\u3066\u3044\u307E\u305B\u3093");
    }
  }
  async triggerResetSelectedTask() {
    const view = await this.getOrCreateTaskChuteView(["resetSelectedTask", "resetTaskToIdle"]);
    if (!view) {
      new import_obsidian13.Notice("TaskChute\u30D3\u30E5\u30FC\u304C\u958B\u304B\u308C\u3066\u3044\u307E\u305B\u3093");
      return;
    }
    const v = view;
    if (typeof v.resetSelectedTask === "function") {
      await v.resetSelectedTask();
      return;
    }
    if (view.selectedTaskInstance && typeof v.resetTaskToIdle === "function") {
      await v.resetTaskToIdle(view.selectedTaskInstance);
    } else {
      new import_obsidian13.Notice("\u30BF\u30B9\u30AF\u304C\u9078\u629E\u3055\u308C\u3066\u3044\u307E\u305B\u3093");
    }
  }
  async activateTaskChuteView() {
    const { workspace } = this.app;
    const leaf = workspace.getLeaf(true);
    await leaf.setViewState({
      type: VIEW_TYPE_TASKCHUTE,
      active: true
    });
  }
  showSettingsModal() {
    const modal = document.createElement("div");
    modal.className = "task-modal-overlay";
    const modalContent = modal.createEl("div", { cls: "task-modal-content" });
    const modalHeader = modalContent.createEl("div", { cls: "modal-header" });
    modalHeader.createEl("h3", { text: "TaskChute\u8A2D\u5B9A" });
    const closeButton = modalHeader.createEl("button", {
      cls: "modal-close-button",
      text: "\xD7",
      attr: { title: "\u9589\u3058\u308B" }
    });
    const form = modalContent.createEl("form", { cls: "task-form" });
    const pathSection = form.createEl("div", { cls: "settings-section" });
    pathSection.createEl("h4", { text: "\u30D1\u30B9\u8A2D\u5B9A" });
    this.createPathSetting(
      pathSection,
      "\u30BF\u30B9\u30AF\u30D5\u30A9\u30EB\u30C0\u30D1\u30B9",
      "taskFolderPath",
      PathManager.DEFAULT_PATHS.taskFolder
    );
    this.createPathSetting(
      pathSection,
      "\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30D5\u30A9\u30EB\u30C0\u30D1\u30B9",
      "projectFolderPath",
      PathManager.DEFAULT_PATHS.projectFolder
    );
    this.createPathSetting(
      pathSection,
      "\u30ED\u30B0\u30C7\u30FC\u30BF\u30D1\u30B9",
      "logDataPath",
      PathManager.DEFAULT_PATHS.logData
    );
    this.createPathSetting(
      pathSection,
      "\u30EC\u30D3\u30E5\u30FC\u30C7\u30FC\u30BF\u30D1\u30B9",
      "reviewDataPath",
      PathManager.DEFAULT_PATHS.reviewData
    );
    const effectsSection = form.createEl("div", { cls: "settings-section" });
    effectsSection.createEl("h4", { text: "\u8996\u899A\u52B9\u679C\u8A2D\u5B9A" });
    this.createToggleSetting(effectsSection, "\u52B9\u679C\u97F3\u3092\u6709\u52B9\u5316", "enableSound");
    this.createToggleSetting(effectsSection, "\u82B1\u706B\u30A8\u30D5\u30A7\u30AF\u30C8\u3092\u6709\u52B9\u5316", "enableFireworks");
    this.createToggleSetting(effectsSection, "\u7D19\u5439\u96EA\u30A8\u30D5\u30A7\u30AF\u30C8\u3092\u6709\u52B9\u5316", "enableConfetti");
    closeButton.addEventListener("click", () => {
      document.body.removeChild(modal);
    });
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        document.body.removeChild(modal);
      }
    });
    document.body.appendChild(modal);
  }
  createPathSetting(container, label, settingKey, placeholder) {
    const group = container.createEl("div", { cls: "form-group" });
    group.createEl("label", { text: label + ":", cls: "form-label" });
    const input = group.createEl("input", {
      type: "text",
      cls: "form-input",
      attr: { placeholder }
    });
    input.value = this.settings[settingKey] || "";
    input.addEventListener("change", async () => {
      const value = input.value.trim();
      const validation = this.pathManager.validatePath(value);
      if (validation.valid || value === "") {
        this.settings[settingKey] = value;
        await this.saveSettings();
        try {
          if (settingKey === "taskFolderPath") {
            await this.pathManager.ensureFolderExists(this.pathManager.getTaskFolderPath());
          } else if (settingKey === "projectFolderPath") {
            await this.pathManager.ensureFolderExists(this.pathManager.getProjectFolderPath());
          } else if (settingKey === "logDataPath") {
            await this.pathManager.ensureFolderExists(this.pathManager.getLogDataPath());
          } else if (settingKey === "reviewDataPath") {
            await this.pathManager.ensureFolderExists(this.pathManager.getReviewDataPath());
          }
        } catch (error) {
        }
      } else {
        new import_obsidian13.Notice(validation.error);
        input.value = this.settings[settingKey] || "";
      }
    });
  }
  createToggleSetting(container, label, settingKey) {
    const group = container.createEl("div", { cls: "form-group checkbox-group" });
    const checkbox = group.createEl("input", {
      type: "checkbox",
      cls: "form-checkbox"
    });
    group.createEl("label", { text: label, cls: "form-label" });
    checkbox.checked = this.settings[settingKey];
    checkbox.addEventListener("change", async () => {
      this.settings[settingKey] = checkbox.checked;
      await this.saveSettings();
    });
  }
};
