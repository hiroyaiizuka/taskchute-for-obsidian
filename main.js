/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TaskChutePlusPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/managers/PathManager.ts
var import_obsidian = require("obsidian");
var _PathManager = class _PathManager {
  constructor(plugin) {
    this.plugin = plugin;
  }
  getTaskFolderPath() {
    const path = this.plugin.settings.taskFolderPath || _PathManager.DEFAULT_PATHS.taskFolder;
    return (0, import_obsidian.normalizePath)(path);
  }
  getProjectFolderPath() {
    const path = this.plugin.settings.projectFolderPath || _PathManager.DEFAULT_PATHS.projectFolder;
    return (0, import_obsidian.normalizePath)(path);
  }
  getLogDataPath() {
    const path = this.plugin.settings.logDataPath || _PathManager.DEFAULT_PATHS.logData;
    return (0, import_obsidian.normalizePath)(path);
  }
  getReviewDataPath() {
    const path = this.plugin.settings.reviewDataPath || _PathManager.DEFAULT_PATHS.reviewData;
    return (0, import_obsidian.normalizePath)(path);
  }
  getLogYearPath(year) {
    const logPath = this.getLogDataPath();
    return (0, import_obsidian.normalizePath)(`${logPath}/${year}`);
  }
  async ensureYearFolder(year) {
    const yearPath = this.getLogYearPath(year);
    await this.ensureFolderExists(yearPath);
    return yearPath;
  }
  validatePath(path) {
    if (path.startsWith("/") || path.match(/^[A-Za-z]:\\/)) {
      return { valid: false, error: "\u7D76\u5BFE\u30D1\u30B9\u306F\u4F7F\u7528\u3067\u304D\u307E\u305B\u3093" };
    }
    if (path.includes("..")) {
      return { valid: false, error: "\u30D1\u30B9\u306B'..'\u3092\u542B\u3081\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093" };
    }
    if (path.match(/[<>"|?*]/)) {
      return { valid: false, error: "\u30D1\u30B9\u306B\u7279\u6B8A\u6587\u5B57\u3092\u542B\u3081\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093" };
    }
    return { valid: true };
  }
  async ensureFolderExists(path) {
    const folder = this.plugin.app.vault.getAbstractFileByPath(path);
    if (!folder) {
      try {
        await this.plugin.app.vault.createFolder(path);
      } catch (error) {
        if (error.message && error.message.includes("Folder already exists")) {
          return;
        }
        throw error;
      }
    }
  }
};
_PathManager.DEFAULT_PATHS = {
  taskFolder: "TaskChute/Task",
  projectFolder: "TaskChute/Project",
  logData: "TaskChute/Log",
  reviewData: "TaskChute/Review"
};
var PathManager = _PathManager;

// src/settings.ts
var DEFAULT_SETTINGS = {
  taskFolderPath: PathManager.DEFAULT_PATHS.taskFolder,
  projectFolderPath: PathManager.DEFAULT_PATHS.projectFolder,
  logDataPath: PathManager.DEFAULT_PATHS.logData,
  reviewDataPath: PathManager.DEFAULT_PATHS.reviewData,
  enableSound: false,
  enableFireworks: false,
  enableConfetti: false
};

// src/managers/RoutineAliasManager.ts
var import_obsidian2 = require("obsidian");
var RoutineAliasManager = class {
  constructor(plugin) {
    this.aliasCache = null;
    this.plugin = plugin;
  }
  getAliasFilePath() {
    const taskFolderPath = this.plugin.pathManager.getTaskFolderPath();
    return (0, import_obsidian2.normalizePath)(`${taskFolderPath}/routine-aliases.json`);
  }
  async loadAliases() {
    if (this.aliasCache) return this.aliasCache;
    const path = this.getAliasFilePath();
    try {
      const file = this.plugin.app.vault.getAbstractFileByPath(path);
      if (file instanceof import_obsidian2.TFile) {
        const content = await this.plugin.app.vault.read(file);
        this.aliasCache = JSON.parse(content);
      } else {
        this.aliasCache = {};
      }
    } catch (error) {
      if (this.plugin._notify) {
        this.plugin._notify("\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306E\u540D\u524D\u5909\u66F4\u5C65\u6B74\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
      } else {
        new import_obsidian2.Notice("\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306E\u540D\u524D\u5909\u66F4\u5C65\u6B74\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
      }
      this.aliasCache = {};
    }
    return this.aliasCache;
  }
  async saveAliases(aliases) {
    try {
      const path = this.getAliasFilePath();
      const file = this.plugin.app.vault.getAbstractFileByPath(path);
      const content = JSON.stringify(aliases, null, 2);
      if (file instanceof import_obsidian2.TFile) {
        await this.plugin.app.vault.modify(file, content);
      } else {
        await this.plugin.app.vault.create(path, content);
      }
      this.aliasCache = aliases;
    } catch (error) {
      if (this.plugin._notify) {
        this.plugin._notify("\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306E\u540D\u524D\u5909\u66F4\u5C65\u6B74\u306E\u4FDD\u5B58\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
      } else {
        new import_obsidian2.Notice("\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306E\u540D\u524D\u5909\u66F4\u5C65\u6B74\u306E\u4FDD\u5B58\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
      }
    }
  }
  async addAlias(newName, oldName) {
    const aliases = await this.loadAliases();
    if (!aliases[newName]) {
      aliases[newName] = [];
    }
    if (aliases[oldName]) {
      aliases[newName] = [...aliases[oldName], oldName];
      delete aliases[oldName];
    } else {
      aliases[newName].push(oldName);
    }
    aliases[newName] = [...new Set(aliases[newName])];
    await this.saveAliases(aliases);
  }
  getAliases(taskName) {
    var _a;
    return ((_a = this.aliasCache) == null ? void 0 : _a[taskName]) || [];
  }
  getAllPossibleNames(taskName) {
    const names = /* @__PURE__ */ new Set([taskName]);
    const directAliases = this.getAliases(taskName);
    directAliases.forEach((alias) => names.add(alias));
    const currentName = this.findCurrentName(taskName);
    if (currentName) {
      names.add(currentName);
      const currentAliases = this.getAliases(currentName);
      currentAliases.forEach((alias) => names.add(alias));
    }
    return Array.from(names);
  }
  findCurrentName(oldName, visited = /* @__PURE__ */ new Set()) {
    if (!this.aliasCache) return null;
    if (visited.has(oldName)) return null;
    visited.add(oldName);
    for (const [current, aliases] of Object.entries(this.aliasCache)) {
      if (aliases.includes(oldName)) {
        return current;
      }
    }
    return null;
  }
};

// src/views/TaskChuteView.ts
var import_obsidian7 = require("obsidian");

// src/views/LogView.ts
var import_obsidian4 = require("obsidian");

// src/services/HeatmapService.ts
var import_obsidian3 = require("obsidian");
var HeatmapService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async loadYearlyData(year) {
    const yearPath = this.plugin.pathManager.getLogYearPath(year);
    const heatmapPath = (0, import_obsidian3.normalizePath)(`${yearPath}/yearly-heatmap.json`);
    const file = this.plugin.app.vault.getAbstractFileByPath(heatmapPath);
    if (file && file instanceof import_obsidian3.TFile) {
      try {
        const content = await this.plugin.app.vault.read(file);
        const data = JSON.parse(content);
        if (!data || typeof data !== "object" || !data.year || !data.days) {
          throw new Error("Invalid yearly heatmap data");
        }
        return data;
      } catch (_) {
      }
    }
    return await this.generateYearlyData(year);
  }
  async generateYearlyData(year) {
    const yearlyData = {
      year,
      days: {},
      metadata: {
        version: "1.0",
        lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
      }
    };
    try {
      for (let month = 1; month <= 12; month++) {
        const monthString = `${year}-${String(month).padStart(2, "0")}`;
        const logDataPath = this.plugin.pathManager.getLogDataPath();
        const logFilePath = (0, import_obsidian3.normalizePath)(`${logDataPath}/${monthString}-tasks.json`);
        const file2 = this.plugin.app.vault.getAbstractFileByPath(logFilePath);
        if (!file2 || !(file2 instanceof import_obsidian3.TFile)) continue;
        const content2 = await this.plugin.app.vault.read(file2);
        const monthlyLog = JSON.parse(content2);
        if (!monthlyLog || typeof monthlyLog !== "object") continue;
        if (monthlyLog.dailySummary && typeof monthlyLog.dailySummary === "object") {
          for (const [dateString, summary] of Object.entries(monthlyLog.dailySummary)) {
            if (!/^\d{4}-\d{2}-\d{2}$/.test(dateString)) continue;
            if (!dateString.startsWith(`${year}-`)) continue;
            const totalTasks = Number(summary.totalTasks) || 0;
            const completedTasks = Number(summary.completedTasks) || 0;
            const stats = {
              totalTasks,
              completedTasks,
              procrastinatedTasks: Math.max(0, totalTasks - completedTasks),
              completionRate: totalTasks > 0 ? completedTasks / totalTasks : 0
            };
            yearlyData.days[dateString] = stats;
          }
        } else if (monthlyLog.taskExecutions && typeof monthlyLog.taskExecutions === "object") {
          for (const [dateString, dayTasks] of Object.entries(monthlyLog.taskExecutions)) {
            if (!/^\d{4}-\d{2}-\d{2}$/.test(dateString)) continue;
            if (!dateString.startsWith(`${year}-`)) continue;
            if (!Array.isArray(dayTasks)) continue;
            const stats = this.calculateDailyStats(dayTasks);
            yearlyData.days[dateString] = stats;
          }
        }
      }
      const yearPath = await this.plugin.pathManager.ensureYearFolder(String(year));
      const heatmapPath = (0, import_obsidian3.normalizePath)(`${yearPath}/yearly-heatmap.json`);
      const file = this.plugin.app.vault.getAbstractFileByPath(heatmapPath);
      const content = JSON.stringify(yearlyData, null, 2);
      if (file && file instanceof import_obsidian3.TFile) {
        await this.plugin.app.vault.modify(file, content);
      } else {
        await this.plugin.app.vault.create(heatmapPath, content);
      }
    } catch (_) {
    }
    return yearlyData;
  }
  calculateDailyStats(dayTasks) {
    const map = /* @__PURE__ */ new Map();
    for (const task of dayTasks) {
      if (!task || typeof task !== "object") continue;
      const name = task.taskName;
      if (!name || typeof name !== "string") continue;
      const isCompleted = !!task.isCompleted;
      if (!map.has(name)) map.set(name, false);
      if (isCompleted) map.set(name, true);
    }
    const totalTasks = map.size;
    const completedTasks = Array.from(map.values()).filter(Boolean).length;
    return {
      totalTasks,
      completedTasks,
      procrastinatedTasks: Math.max(0, totalTasks - completedTasks),
      completionRate: totalTasks > 0 ? completedTasks / totalTasks : 0
    };
  }
  async updateDailyStats(dateString) {
    var _a;
    try {
      const monthly = await this.loadMonthlyData(dateString);
      const dayTasks = ((_a = monthly.taskExecutions) == null ? void 0 : _a[dateString]) || [];
      const stats = this.calculateDailyStats(dayTasks);
      await this.updateYearlyData(dateString, stats);
      return stats;
    } catch (_) {
      return null;
    }
  }
  async loadMonthlyData(dateString) {
    try {
      const [year, month] = dateString.split("-");
      const monthString = `${year}-${month}`;
      const logDataPath = this.plugin.pathManager.getLogDataPath();
      const logFilePath = (0, import_obsidian3.normalizePath)(`${logDataPath}/${monthString}-tasks.json`);
      const file = this.plugin.app.vault.getAbstractFileByPath(logFilePath);
      if (!file || !(file instanceof import_obsidian3.TFile)) return { taskExecutions: {} };
      const content = await this.plugin.app.vault.read(file);
      return JSON.parse(content);
    } catch (_) {
      return { taskExecutions: {} };
    }
  }
  async updateYearlyData(dateString, stats) {
    try {
      const [year] = dateString.split("-");
      const yearPath = await this.plugin.pathManager.ensureYearFolder(year);
      const heatmapPath = (0, import_obsidian3.normalizePath)(`${yearPath}/yearly-heatmap.json`);
      const file = this.plugin.app.vault.getAbstractFileByPath(heatmapPath);
      let yearly;
      if (file && file instanceof import_obsidian3.TFile) {
        const content = await this.plugin.app.vault.read(file);
        yearly = JSON.parse(content);
      } else {
        yearly = { year: parseInt(year, 10), days: {}, metadata: { version: "1.0" } };
      }
      yearly.days[dateString] = stats;
      if (!yearly.metadata) yearly.metadata = { version: "1.0" };
      yearly.metadata.lastUpdated = (/* @__PURE__ */ new Date()).toISOString();
      const out = JSON.stringify(yearly, null, 2);
      if (file && file instanceof import_obsidian3.TFile) {
        await this.plugin.app.vault.modify(file, out);
      } else {
        await this.plugin.app.vault.create(heatmapPath, out);
      }
    } catch (_) {
    }
  }
};

// src/views/LogView.ts
var LogView = class {
  constructor(plugin, container) {
    this.heatmapData = null;
    this.dataCache = {};
    this.plugin = plugin;
    this.container = container;
    this.currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    this.heatmapService = new HeatmapService(plugin);
  }
  async render() {
    this.container.empty();
    this.createHeader();
    const loadingContainer = this.container.createEl("div", {
      cls: "heatmap-loading",
      text: "\u30C7\u30FC\u30BF\u3092\u8AAD\u307F\u8FBC\u307F\u4E2D..."
    });
    try {
      if (this.currentYear === (/* @__PURE__ */ new Date()).getFullYear()) {
        delete this.dataCache[this.currentYear];
        try {
          const yearPath = this.plugin.pathManager.getLogYearPath(this.currentYear);
          const heatmapFile = this.plugin.app.vault.getAbstractFileByPath(`${yearPath}/yearly-heatmap.json`);
          if (heatmapFile && heatmapFile instanceof import_obsidian4.TFile) {
            await this.plugin.app.vault.delete(heatmapFile);
          }
        } catch (_) {
        }
      }
      this.heatmapData = await this.loadYearlyData(this.currentYear);
      loadingContainer.remove();
      this.renderHeatmap();
    } catch (error) {
      loadingContainer.remove();
      new import_obsidian4.Notice(`${this.currentYear}\u5E74\u306E\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F`);
      this.renderEmptyHeatmap(this.currentYear);
    }
  }
  createHeader() {
    const header = this.container.createEl("div", { cls: "taskchute-log-header" });
    header.createEl("h2", { text: "\u30BF\u30B9\u30AF\u5B9F\u884C\u30ED\u30B0", cls: "log-title" });
    const controls = header.createEl("div", { cls: "log-controls" });
    const yearSelector = controls.createEl("select", { cls: "year-selector" });
    const current = (/* @__PURE__ */ new Date()).getFullYear();
    for (let y = current + 1; y >= 2020; y--) {
      const opt = yearSelector.createEl("option", { value: String(y), text: `${y}\u5E74` });
      if (y === this.currentYear) opt.selected = true;
    }
    const refreshButton = controls.createEl("button", {
      cls: "refresh-button",
      text: "\u{1F504} \u30C7\u30FC\u30BF\u66F4\u65B0",
      attr: { title: "\u30AD\u30E3\u30C3\u30B7\u30E5\u3092\u30AF\u30EA\u30A2\u3057\u3066\u518D\u8A08\u7B97" }
    });
    refreshButton.addEventListener("click", async () => {
      delete this.dataCache[this.currentYear];
      try {
        const yearPath = this.plugin.pathManager.getLogYearPath(this.currentYear);
        const heatmapFile = this.plugin.app.vault.getAbstractFileByPath(`${yearPath}/yearly-heatmap.json`);
        if (heatmapFile && heatmapFile instanceof import_obsidian4.TFile) {
          await this.plugin.app.vault.delete(heatmapFile);
        }
      } catch (_) {
      }
      const container = this.container.querySelector(".heatmap-container");
      if (container) container.remove();
      const loading = this.container.createEl("div", { cls: "heatmap-loading", text: "\u30C7\u30FC\u30BF\u3092\u518D\u8A08\u7B97\u4E2D..." });
      try {
        this.heatmapData = await this.loadYearlyData(this.currentYear);
        loading.remove();
        this.renderHeatmap();
        new import_obsidian4.Notice(`${this.currentYear}\u5E74\u306E\u30C7\u30FC\u30BF\u3092\u66F4\u65B0\u3057\u307E\u3057\u305F`);
      } catch (e) {
        loading.remove();
        new import_obsidian4.Notice(`${this.currentYear}\u5E74\u306E\u30C7\u30FC\u30BF\u66F4\u65B0\u306B\u5931\u6557\u3057\u307E\u3057\u305F`);
        this.renderEmptyHeatmap(this.currentYear);
      }
    });
    yearSelector.addEventListener("change", async (e) => {
      this.currentYear = parseInt(e.target.value, 10);
      const container = this.container.querySelector(".heatmap-container");
      if (container) container.remove();
      const loading = this.container.createEl("div", { cls: "heatmap-loading", text: "\u30C7\u30FC\u30BF\u3092\u8AAD\u307F\u8FBC\u307F\u4E2D..." });
      try {
        this.heatmapData = await this.loadYearlyData(this.currentYear);
        loading.remove();
        this.renderHeatmap();
      } catch (err) {
        loading.remove();
        new import_obsidian4.Notice(`${this.currentYear}\u5E74\u306E\u30C7\u30FC\u30BF\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F`);
        this.renderEmptyHeatmap(this.currentYear);
      }
    });
  }
  async loadYearlyData(year) {
    if (this.dataCache[year]) return this.dataCache[year];
    await this.plugin.pathManager.ensureYearFolder(year);
    const data = await this.heatmapService.loadYearlyData(year);
    this.dataCache[year] = data;
    return data;
  }
  renderHeatmap() {
    if (!this.heatmapData) return;
    const existed = this.container.querySelector(".heatmap-container");
    if (existed) existed.remove();
    const heatmapContainer = this.container.createEl("div", { cls: "heatmap-container" });
    const grid = this.createHeatmapGrid(this.heatmapData.year);
    heatmapContainer.appendChild(grid);
    this.applyDataToGrid(this.heatmapData);
  }
  renderEmptyHeatmap(year) {
    const existed = this.container.querySelector(".heatmap-container");
    if (existed) existed.remove();
    const heatmapContainer = this.container.createEl("div", { cls: "heatmap-container" });
    heatmapContainer.createEl("div", { cls: "heatmap-error", text: `${year}\u5E74\u306E\u30C7\u30FC\u30BF\u306F\u5229\u7528\u3067\u304D\u307E\u305B\u3093` });
    const grid = this.createHeatmapGrid(year);
    heatmapContainer.appendChild(grid);
    const cells = grid.querySelectorAll(".heatmap-cell");
    cells.forEach((cell) => {
      ;
      cell.dataset.level = "0";
      cell.dataset.tooltip = "\u30C7\u30FC\u30BF\u306A\u3057";
    });
  }
  applyDataToGrid(data) {
    if (!data.days) return;
    const entries = Object.entries(data.days);
    const batchSize = 50;
    let currentIndex = 0;
    const processBatch = () => {
      const endIndex = Math.min(currentIndex + batchSize, entries.length);
      for (let i = currentIndex; i < endIndex; i++) {
        const [dateString, stats] = entries[i];
        const cell = this.container.querySelector(`[data-date="${dateString}"]`);
        if (cell) {
          const level = this.calculateLevel(stats);
          cell.dataset.level = String(level);
          cell.dataset.tooltip = this.createTooltipText(dateString, stats);
        }
      }
      currentIndex = endIndex;
      if (currentIndex < entries.length) requestAnimationFrame(processBatch);
    };
    requestAnimationFrame(processBatch);
  }
  calculateLevel(stats) {
    if (!stats || stats.totalTasks === 0) return 0;
    if (stats.procrastinatedTasks === 0) return 4;
    const rate = stats.completionRate;
    if (rate >= 0.8) return 3;
    if (rate >= 0.5) return 2;
    if (rate >= 0.2) return 1;
    return 1;
  }
  createTooltipText(dateString, stats) {
    const date = /* @__PURE__ */ new Date(dateString + "T00:00:00");
    const dateText = date.toLocaleDateString("ja-JP", { year: "numeric", month: "long", day: "numeric", weekday: "long" });
    if (!stats || stats.totalTasks === 0) return `${dateText}
\u30BF\u30B9\u30AF\u306A\u3057`;
    return `${dateText}
\u7DCF\u30BF\u30B9\u30AF: ${stats.totalTasks}
\u5B8C\u4E86: ${stats.completedTasks}
\u5148\u9001\u308A: ${stats.procrastinatedTasks}
\u5B8C\u4E86\u7387: ${Math.round(stats.completionRate * 100)}%`;
  }
  addCellEventListeners(cell, dateString) {
    cell.addEventListener("mouseenter", () => this.showTooltip(cell));
    cell.addEventListener("mouseleave", () => this.hideTooltip());
    cell.addEventListener("click", async (e) => {
      e.stopPropagation();
      await this.navigateToDate(dateString);
    });
  }
  showTooltip(cell) {
    this.hideTooltip();
    const tooltipText = cell.dataset.tooltip;
    if (!tooltipText) return;
    const tooltip = document.createElement("div");
    tooltip.className = "heatmap-tooltip";
    tooltip.textContent = tooltipText;
    const rect = cell.getBoundingClientRect();
    const containerRect = this.container.getBoundingClientRect();
    tooltip.style.position = "absolute";
    tooltip.style.left = `${rect.left - containerRect.left}px`;
    tooltip.style.top = `${rect.bottom - containerRect.top + 5}px`;
    tooltip.style.zIndex = "1000";
    this.container.appendChild(tooltip);
    this.currentTooltip = tooltip;
  }
  hideTooltip() {
    const current = this.currentTooltip;
    if (current) {
      current.remove();
      this.currentTooltip = null;
    }
  }
  async navigateToDate(dateString) {
    try {
      const [year, month, day] = dateString.split("-").map(Number);
      const leaves = this.plugin.app.workspace.getLeavesOfType("taskchute-view");
      let leaf;
      if (leaves.length === 0) {
        leaf = this.plugin.app.workspace.getRightLeaf(false);
        await leaf.setViewState({ type: "taskchute-view", active: true });
        await new Promise((r) => setTimeout(r, 300));
        const newLeaves = this.plugin.app.workspace.getLeavesOfType("taskchute-view");
        if (newLeaves.length > 0) leaf = newLeaves[0];
      } else {
        leaf = leaves[0];
      }
      const view = leaf.view;
      if (!view || typeof view.loadTasks !== "function") return;
      view.currentDate = new Date(year, month - 1, day);
      if (view.updateDateLabel && view.containerEl) {
        const dateLabel = view.containerEl.querySelector(".date-nav-label");
        if (dateLabel) view.updateDateLabel(dateLabel);
      }
      await view.loadTasks();
      this.plugin.app.workspace.setActiveLeaf(leaf);
      const modal = this.container.closest(".taskchute-log-modal-overlay");
      if (modal) modal.remove();
    } catch (_) {
    }
  }
  createHeatmapGrid(year) {
    const gridContainer = document.createElement("div");
    gridContainer.className = "heatmap-grid-container";
    const monthLabels = gridContainer.createEl("div", { cls: "heatmap-months" });
    const weekdayContainer = gridContainer.createEl("div", { cls: "heatmap-weekdays-container" });
    const weekdayLabels = weekdayContainer.createEl("div", { cls: "heatmap-weekdays" });
    const weekdays = ["\u65E5", "\u6708", "\u706B", "\u6C34", "\u6728", "\u91D1", "\u571F"];
    weekdays.forEach((day, idx) => {
      const label = weekdayLabels.createEl("span", { cls: "weekday-label" });
      if (idx === 1 || idx === 3 || idx === 5) label.textContent = day;
    });
    const grid = weekdayContainer.createEl("div", { cls: "heatmap-grid" });
    grid.style.gridTemplateColumns = `repeat(53, 11px)`;
    const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const firstDay = new Date(year, 0, 1);
    const firstSunday = new Date(firstDay);
    firstSunday.setDate(firstSunday.getDate() - firstDay.getDay());
    const currentDate = new Date(firstSunday);
    let weekIndex = 0;
    let lastMonthSeen = -1;
    for (let i = 0; i < 371; i++) {
      const dateStr = this.formatDate(currentDate);
      const isCurrentYear = currentDate.getFullYear() === year;
      const cell = grid.createEl("div", {
        cls: isCurrentYear ? "heatmap-cell" : "heatmap-cell empty",
        attr: { "data-date": dateStr, "data-level": "0" }
      });
      if (isCurrentYear) {
        this.addCellEventListeners(cell, dateStr);
        const cm = currentDate.getMonth();
        if (cm !== lastMonthSeen) {
          const label = monthLabels.createEl("span", { cls: "month-label", text: months[cm] });
          label.style.left = `${weekIndex * 13}px`;
          lastMonthSeen = cm;
        }
      }
      currentDate.setDate(currentDate.getDate() + 1);
      if (i > 0 && (i + 1) % 7 === 0) weekIndex++;
    }
    const legend = gridContainer.createEl("div", { cls: "heatmap-legend" });
    legend.createEl("span", { cls: "legend-label", text: "Less" });
    const legendScale = legend.createEl("div", { cls: "legend-scale" });
    for (let i = 0; i <= 4; i++) legendScale.createEl("div", { cls: "legend-cell", attr: { "data-level": String(i) } });
    legend.createEl("span", { cls: "legend-label", text: "More" });
    return gridContainer;
  }
  formatDate(d) {
    const y = d.getFullYear();
    const m = String(d.getMonth() + 1).padStart(2, "0");
    const day = String(d.getDate()).padStart(2, "0");
    return `${y}-${m}-${day}`;
  }
};

// src/services/ReviewService.ts
var import_obsidian5 = require("obsidian");

// src/utils/reviewTemplate.ts
function buildDefaultReviewTemplate(logDataPath) {
  const LOG_LINE = `const LOG_DATA_PATH = ${JSON.stringify(logDataPath)}`;
  const lines = [];
  lines.push("---");
  lines.push("satisfaction: ");
  lines.push("---");
  lines.push("");
  lines.push("### \u96C6\u4E2D\u30FB\u5143\u6C17\u5EA6\u306E\u63A8\u79FB");
  lines.push("```dataviewjs");
  lines.push("// \u30D7\u30E9\u30B0\u30A4\u30F3\u8A2D\u5B9A\u304B\u3089\u53D7\u3051\u53D6\u3063\u305F\u30ED\u30B0\u30C7\u30FC\u30BF\u30D1\u30B9\uFF08\u30D3\u30EB\u30C9\u6642\u306B\u57CB\u3081\u8FBC\u307F\uFF09");
  lines.push(LOG_LINE);
  lines.push("");
  lines.push("// \u30D5\u30A1\u30A4\u30EB\u540D\u304B\u3089\u65E5\u4ED8\u3092\u53D6\u5F97");
  lines.push('// \u30D5\u30A1\u30A4\u30EB\u540D: "Daily - YYYY-MM-DD"');
  lines.push("const fileName = dv.current().file.name");
  lines.push("");
  lines.push("// \u30B7\u30F3\u30D7\u30EB\u306B\u65E5\u4ED8\u30D1\u30BF\u30FC\u30F3\u3060\u3051\u3092\u63A2\u3059");
  lines.push("const dateMatch = fileName.match(/\\d{4}-\\d{2}-\\d{2}/)");
  lines.push("");
  lines.push("if (!dateMatch) {");
  lines.push("  dv.paragraph('\u274C \u30D5\u30A1\u30A4\u30EB\u540D\u304B\u3089\u65E5\u4ED8\u3092\u53D6\u5F97\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002\u30D5\u30A1\u30A4\u30EB\u540D: ' + fileName)");
  lines.push("  return");
  lines.push("}");
  lines.push("");
  lines.push("const currentDate = dateMatch[0] // YYYY-MM-DD");
  lines.push("const [year, month] = currentDate.split('-')");
  lines.push("const monthString = year + '-' + month");
  lines.push("");
  lines.push("// \u30ED\u30B0\u30D5\u30A1\u30A4\u30EB\u30D1\u30B9");
  lines.push("const logPath = LOG_DATA_PATH + '/' + monthString + '-tasks.json'");
  lines.push("");
  lines.push("try {");
  lines.push("  const logFile = dv.app.vault.getAbstractFileByPath(logPath)");
  lines.push("  const content = logFile ? await dv.app.vault.read(logFile) : null");
  lines.push("  if (!content) throw new Error('Log file not found')");
  lines.push("");
  lines.push("  const monthlyLog = JSON.parse(content)");
  lines.push("  const dayTasks = monthlyLog.taskExecutions?.[currentDate] || []");
  lines.push("");
  lines.push("  // \u6642\u9593\u5E2F\u5225\u306B\u30C7\u30FC\u30BF\u3092\u96C6\u8A08");
  lines.push("  const hourlyData = new Array(24).fill(null).map(() => ({ focus: [], energy: [] }))");
  lines.push("");
  lines.push("  dayTasks.forEach(task => {");
  lines.push("    if (task.startTime && (task.focusLevel > 0 || task.energyLevel > 0)) {");
  lines.push('      // startTime\u306F"HH:MM:SS"\u5F62\u5F0F');
  lines.push("      const hourStr = task.startTime.split(':')[0]");
  lines.push("      const hour = parseInt(hourStr, 10)");
  lines.push("      if (hour >= 0 && hour < 24) {");
  lines.push("        if (task.focusLevel > 0) hourlyData[hour].focus.push(task.focusLevel)");
  lines.push("        if (task.energyLevel > 0) hourlyData[hour].energy.push(task.energyLevel)");
  lines.push("      }");
  lines.push("    }");
  lines.push("  })");
  lines.push("");
  lines.push("  const focusData = hourlyData.map(h => h.focus.length > 0");
  lines.push("    ? Math.round(h.focus.reduce((a,b) => a+b) / h.focus.length * 10) / 10");
  lines.push("    : null)");
  lines.push("");
  lines.push("  const energyData = hourlyData.map(h => h.energy.length > 0");
  lines.push("    ? Math.round(h.energy.reduce((a,b) => a+b) / h.energy.length * 10) / 10");
  lines.push("    : null)");
  lines.push("");
  lines.push("  // Charts\u30D7\u30E9\u30B0\u30A4\u30F3\u306A\u3069\u3067\u89E3\u91C8\u3055\u308C\u308Bchart\u30D6\u30ED\u30C3\u30AF\u3092\u751F\u6210");
  lines.push("  const chartBlock = [");
  lines.push("    '````chart',");
  lines.push("    'type: bar',");
  lines.push("    'labels: [0\u6642, 1\u6642, 2\u6642, 3\u6642, 4\u6642, 5\u6642, 6\u6642, 7\u6642, 8\u6642, 9\u6642, 10\u6642, 11\u6642, 12\u6642, 13\u6642, 14\u6642, 15\u6642, 16\u6642, 17\u6642, 18\u6642, 19\u6642, 20\u6642, 21\u6642, 22\u6642, 23\u6642]',");
  lines.push("    'series:',");
  lines.push("    '  - title: \u96C6\u4E2D\u5EA6',");
  lines.push("    '    data: [' + focusData.map(v => v !== null ? v : 0).join(', ') + ']',");
  lines.push("    '  - title: \u5143\u6C17\u5EA6',");
  lines.push("    '    data: [' + energyData.map(v => v !== null ? v : 0).join(', ') + ']',");
  lines.push("    'tension: 0',");
  lines.push("    'width: 80%',");
  lines.push("    'labelColors: false',");
  lines.push("    'fill: false',");
  lines.push("    'beginAtZero: false',");
  lines.push("    '````',");
  lines.push("  ].join('\\n');");
  lines.push("  dv.paragraph(chartBlock)");
  lines.push("} catch (e) {");
  lines.push("  dv.paragraph('\u274C \u30C7\u30FC\u30BF\u304C\u8AAD\u307F\u8FBC\u3081\u307E\u305B\u3093\u3067\u3057\u305F\u3002TaskChute\u306E\u30ED\u30B0\u30D5\u30A1\u30A4\u30EB\u304C\u5B58\u5728\u3059\u308B\u304B\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002')");
  lines.push("}");
  lines.push("");
  lines.push("```");
  lines.push("");
  lines.push("### \u30B3\u30E1\u30F3\u30C8\u4E00\u89A7");
  lines.push("");
  lines.push("```dataviewjs");
  lines.push("// \u30D7\u30E9\u30B0\u30A4\u30F3\u8A2D\u5B9A\u304B\u3089\u53D7\u3051\u53D6\u3063\u305F\u30ED\u30B0\u30C7\u30FC\u30BF\u30D1\u30B9\uFF08\u30D3\u30EB\u30C9\u6642\u306B\u57CB\u3081\u8FBC\u307F\uFF09");
  lines.push(LOG_LINE);
  lines.push("");
  lines.push("// \u30D5\u30A1\u30A4\u30EB\u540D\u304B\u3089\u65E5\u4ED8\u3092\u53D6\u5F97");
  lines.push('// \u30D5\u30A1\u30A4\u30EB\u540D: "Daily - YYYY-MM-DD"');
  lines.push("const fileName = dv.current().file.name");
  lines.push("const dateMatch = fileName.match(/\\d{4}-\\d{2}-\\d{2}/)");
  lines.push("if (!dateMatch) {");
  lines.push("  dv.paragraph('\u274C \u30D5\u30A1\u30A4\u30EB\u540D\u304B\u3089\u65E5\u4ED8\u3092\u53D6\u5F97\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002\u30D5\u30A1\u30A4\u30EB\u540D: ' + fileName)");
  lines.push("  return");
  lines.push("}");
  lines.push("");
  lines.push("const currentDate = dateMatch[0] // YYYY-MM-DD");
  lines.push("const [year, month] = currentDate.split('-')");
  lines.push("const monthString = year + '-' + month");
  lines.push("");
  lines.push("// \u30ED\u30B0\u30D5\u30A1\u30A4\u30EB\u30D1\u30B9");
  lines.push("const logPath = LOG_DATA_PATH + '/' + monthString + '-tasks.json'");
  lines.push("");
  lines.push("try {");
  lines.push("  const logFile = dv.app.vault.getAbstractFileByPath(logPath)");
  lines.push("  const content = logFile ? await dv.app.vault.read(logFile) : null");
  lines.push("  if (!content) throw new Error('Log file not found')");
  lines.push("");
  lines.push("  const monthlyLog = JSON.parse(content)");
  lines.push("  const dayTasks = monthlyLog.taskExecutions?.[currentDate] || []");
  lines.push("");
  lines.push("  // \u30B3\u30E1\u30F3\u30C8\u304C\u3042\u308B\u3001\u3082\u3057\u304F\u306F\u30EC\u30FC\u30C6\u30A3\u30F3\u30B0\u304C\u3042\u308B\u30BF\u30B9\u30AF\u306E\u307F");
  lines.push("  const tasksWithComments = dayTasks");
  lines.push("    .filter(task => task.executionComment || task.focusLevel > 0 || task.energyLevel > 0)");
  lines.push("    .sort((a, b) => new Date(a.startTime) - new Date(b.startTime))");
  lines.push("");
  lines.push("  if (tasksWithComments.length > 0) {");
  lines.push("    const headers = ['\u30BF\u30B9\u30AF\u540D', '\u5B9F\u884C\u6642\u9593', '\u6240\u8981\u6642\u9593', '\u96C6\u4E2D\u5EA6', '\u5143\u6C17\u5EA6', '\u30B3\u30E1\u30F3\u30C8']");
  lines.push("    const tableData = tasksWithComments.map(task => {");
  lines.push("      const startTimeParts = task.startTime.split(':')");
  lines.push("      const stopTimeParts = task.stopTime.split(':')");
  lines.push("      const startTimeStr = startTimeParts[0] + ':' + startTimeParts[1]");
  lines.push("      const stopTimeStr = stopTimeParts[0] + ':' + stopTimeParts[1]");
  lines.push("      const durationMinutes = Math.round(task.duration / 60)");
  lines.push("      return [");
  lines.push("        task.taskName,");
  lines.push("        startTimeStr + ' - ' + stopTimeStr,");
  lines.push("        durationMinutes + '\u5206',");
  lines.push("        task.focusLevel > 0 ? '\u2B50'.repeat(task.focusLevel) : '-',");
  lines.push("        task.energyLevel > 0 ? '\u2B50'.repeat(task.energyLevel) : '-',");
  lines.push("        task.executionComment || '-'");
  lines.push("      ]");
  lines.push("    })");
  lines.push("    dv.table(headers, tableData)");
  lines.push("  } else {");
  lines.push("    dv.paragraph('\u{1F4DD} \u30B3\u30E1\u30F3\u30C8\u4ED8\u304D\u306E\u30BF\u30B9\u30AF\u306F\u3042\u308A\u307E\u305B\u3093\u3002')");
  lines.push("  }");
  lines.push("} catch (e) {");
  lines.push("  dv.paragraph('\u274C \u30C7\u30FC\u30BF\u304C\u8AAD\u307F\u8FBC\u3081\u307E\u305B\u3093\u3067\u3057\u305F\u3002TaskChute\u306E\u30ED\u30B0\u30D5\u30A1\u30A4\u30EB\u304C\u5B58\u5728\u3059\u308B\u304B\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002')");
  lines.push("}");
  lines.push("");
  lines.push("```");
  lines.push("");
  return lines.join("\n");
}

// src/services/ReviewService.ts
var ReviewService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  getReviewFileName(dateStr) {
    return `Daily - ${dateStr}.md`;
  }
  getReviewFilePath(dateStr) {
    const folder = this.plugin.pathManager.getReviewDataPath();
    const fileName = this.getReviewFileName(dateStr);
    return `${folder}/${fileName}`;
  }
  async ensureReviewFile(dateStr) {
    const reviewFolder = this.plugin.pathManager.getReviewDataPath();
    await this.plugin.pathManager.ensureFolderExists(reviewFolder);
    const reviewPath = this.getReviewFilePath(dateStr);
    const existing = this.plugin.app.vault.getAbstractFileByPath(reviewPath);
    if (existing && existing instanceof import_obsidian5.TFile) return existing;
    const logDataPath = this.plugin.pathManager.getLogDataPath();
    const content = buildDefaultReviewTemplate(logDataPath);
    const file = await this.plugin.app.vault.create(reviewPath, content);
    return file;
  }
  async openInSplit(file, leftLeaf) {
    try {
      const ws = this.plugin.app.workspace;
      const rightLeaf = typeof ws.splitActiveLeaf === "function" ? ws.splitActiveLeaf("vertical") : this.plugin.app.workspace.getLeaf("split");
      await rightLeaf.openFile(file);
      this.plugin.app.workspace.setActiveLeaf(leftLeaf);
    } catch (error) {
      new import_obsidian5.Notice("\u30EC\u30D3\u30E5\u30FC\u306E\u8868\u793A\u306B\u5931\u6557\u3057\u307E\u3057\u305F: " + ((error == null ? void 0 : error.message) || error));
      throw error;
    }
  }
};

// src/styles/full-css.ts
var TASKCHUTE_FULL_CSS = `
.taskchute-container {
    height: 100%;
    min-height: 0;
    display: flex;
    flex-direction: column;
}

/* Log Modal Styles */
.taskchute-log-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.taskchute-log-modal-content {
    background: var(--background-primary);
    border-radius: 8px;
    width: 90%;
    max-width: 1200px;
    height: 80%;
    max-height: 800px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    position: relative;
}

.log-modal-close {
    position: absolute;
    top: 10px;
    right: 10px;
    background: none;
    border: none;
    font-size: 24px;
    cursor: pointer;
    color: var(--text-muted);
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
}

.log-modal-close:hover {
    background: var(--background-modifier-hover);
    color: var(--text-normal);
}

.taskchute-log-header {
    padding: 20px;
    border-bottom: 1px solid var(--background-modifier-border);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.log-title {
    margin: 0;
    font-size: 24px;
}

.log-controls {
    display: flex;
    gap: 10px;
    align-items: center;
}

.year-selector {
    padding: 5px 10px;
    border-radius: 4px;
    border: 1px solid var(--background-modifier-border);
    background: var(--background-secondary);
    color: var(--text-normal);
    font-size: 14px;
}

.refresh-button {
    padding: 5px 12px;
    border-radius: 4px;
    border: 1px solid var(--background-modifier-border);
    background: var(--background-secondary);
    color: var(--text-normal);
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.refresh-button:hover {
    background: var(--background-modifier-hover);
    border-color: var(--text-accent);
}

.heatmap-container {
    flex: 1;
    padding: 20px;
    overflow: auto;
}

.heatmap-grid {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
}

.heatmap-placeholder {
    color: var(--text-muted);
    font-size: 16px;
}

/* Heatmap Grid Styles */
.heatmap-grid-container {
    padding: 20px;
}

.heatmap-months {
    position: relative;
    height: 20px;
    margin-bottom: 8px;
    margin-left: 43px;
}

.month-label {
    font-size: 10px;
    color: var(--text-muted);
    position: absolute;
    top: 0;
    text-align: left;
}

.heatmap-weekdays-container {
    display: flex;
    gap: 10px;
}

.heatmap-weekdays {
    display: grid;
    grid-template-rows: repeat(7, 1fr);
    gap: 2px;
    width: 20px;
}

.weekday-label {
    font-size: 10px;
    color: var(--text-muted);
    height: 11px;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    padding-right: 4px;
}

.heatmap-grid {
    display: grid;
    grid-template-rows: repeat(7, 11px);
    gap: 2px;
    grid-auto-flow: column;
    width: fit-content;
}

.heatmap-cell {
    width: 11px;
    height: 11px;
    background: var(--background-modifier-border);
    border-radius: 2px;
    cursor: pointer;
    position: relative;
}

.heatmap-cell.empty {
    background: transparent;
    cursor: default;
}

.heatmap-cell[data-level="0"] {
    background: #ebedf0;
}

.heatmap-cell[data-level="1"] {
    background: #DEF95D;
}

.heatmap-cell[data-level="2"] {
    background: #B5EE4F;
}

.heatmap-cell[data-level="3"] {
    background: #82D523;
}

.heatmap-cell[data-level="4"] {
    background: #54A923;
}

@keyframes pulse {
    0% {
        box-shadow: 0 0 0 0 rgba(118, 75, 162, 0.7);
    }
    70% {
        box-shadow: 0 0 0 10px rgba(118, 75, 162, 0);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(118, 75, 162, 0);
    }
}

.heatmap-cell:hover {
    outline: 1px solid var(--text-normal);
    outline-offset: -1px;
}

.heatmap-cell.month-start {
    margin-left: 4px;
}

.heatmap-legend {
    display: flex;
    align-items: center;
    gap: 5px;
    margin-top: 10px;
    margin-left: 30px;
    font-size: 12px;
    color: var(--text-muted);
}

.legend-scale {
    display: flex;
    gap: 2px;
}

.legend-cell {
    width: 11px;
    height: 11px;
    border-radius: 2px;
}

/* Loading styles */
.heatmap-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 60px 20px;
    color: var(--text-muted);
    font-size: 14px;
}

/* Error styles */
.heatmap-error {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    color: var(--text-error);
    font-size: 14px;
    background: var(--background-modifier-error);
    border-radius: 4px;
    margin-bottom: 20px;
}

.legend-cell[data-level="0"] {
    background: #ebedf0;
}

.legend-cell[data-level="1"] {
    background: #DEF95D;
}

.legend-cell[data-level="2"] {
    background: #B5EE4F;
}

.legend-cell[data-level="3"] {
    background: #82D523;
}

.legend-cell[data-level="4"] {
    background: #54A923;
}

/* Heatmap Tooltip */
.heatmap-tooltip {
    background: var(--background-secondary);
    border: 1px solid var(--background-modifier-border);
    border-radius: 4px;
    padding: 8px;
    font-size: 12px;
    white-space: pre-line;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    pointer-events: none;
}

/* TASK-012: \u30BF\u30B9\u30AF\u540D\u81EA\u52D5\u88DC\u5B8C\u306E\u30B9\u30BF\u30A4\u30EB */
.task-name-suggestions {
    position: absolute;
    z-index: 1000;
    background: var(--background-primary);
    border: 1px solid var(--background-modifier-border);
    border-radius: 4px;
    max-height: 200px;
    overflow-y: auto;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    margin-top: 2px;
}

.suggestion-item {
    padding: 8px 12px;
    cursor: pointer;
    transition: background-color 0.1s;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.suggestion-item:hover,
.suggestion-item-selected {
    background-color: var(--background-modifier-hover);
}

.suggestion-item-selected {
    background-color: var(--background-modifier-hover);
    font-weight: 500;
}

/* Main Container Layout */
.main-container {
    display: flex;
    position: relative;
    flex: 1;
    min-height: 0;
}

/* Top Bar Container */
.top-bar-container {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
    height: 30px; /* Fixed height matching date navigation */
}

/* Header Divider */
.header-divider {
    width: 1px;
    height: 20px;
    background-color: var(--background-modifier-border);
    margin: 5px 0;
}

/* Header Action Section */
.header-action-section {
    display: flex;
    align-items: center;
    gap: 8px;
}

/* Drawer Toggle Button */
.drawer-toggle {
    background: var(--background-primary);
    border: 1px solid var(--background-modifier-border);
    border-radius: 4px;
    padding: 0 10px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.2s ease;
    height: 100%;
    display: flex;
    align-items: center;
}

.drawer-toggle:hover {
    background: var(--background-modifier-hover);
}

/* Navigation Overlay */
.navigation-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.3);
    z-index: 999;
    transition: opacity 0.3s ease;
}

.navigation-overlay-hidden {
    opacity: 0;
    pointer-events: none;
}

.navigation-overlay-visible {
    opacity: 1;
    pointer-events: auto;
}

/* Navigation Panel */
.navigation-panel {
    position: fixed;
    left: 0;
    top: 0;
    height: 100%;
    width: 250px;
    background: var(--background-primary);
    border-right: 1px solid var(--background-modifier-border);
    box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    transition: transform 0.3s ease;
    overflow-y: auto;
}

.navigation-panel-hidden {
    transform: translateX(-100%);
}

.navigation-panel-visible {
    transform: translateX(0);
}

/* Navigation Header - removed close button */
.navigation-header {
    display: none;
}

/* Navigation Items */
.navigation-nav {
    padding: 20px 0;
}

.navigation-nav-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.navigation-nav-item:hover {
    background: var(--background-modifier-hover);
}

.navigation-nav-item.active {
    background: var(--background-modifier-active);
    font-weight: 500;
}

.navigation-nav-icon {
    margin-right: 10px;
    font-size: 16px;
}

.navigation-nav-label {
    font-size: 13px;
}
.task-list-container {
    flex: 1 1 auto;
    min-height: 0;
    overflow-y: auto;
}

.button-container {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin: 15px 0;
}

.task-button {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    min-width: 70px;
}

.task-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.task-button.start {
    background: var(--interactive-accent);
    color: var(--text-on-accent);
}

.task-button.start:hover:not(:disabled) {
    background: var(--interactive-accent-hover);
}

.task-button.stop {
    background: #e74c3c;
    color: white;
}

.task-button.stop:hover {
    background: #c0392b;
}

.task-button.reset {
    background: var(--background-modifier-border);
    color: var(--text-normal);
}

.task-button.reset:hover {
    background: var(--background-modifier-border-hover);
}

.future-task-button {
    background-color: var(--background-modifier-border) !important;
    color: var(--text-muted) !important;
    cursor: not-allowed !important;
}


.task-list-container {
    margin-top: 10px;
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
}

.task-list-container h5 {
    margin: 0 0 10px 0;
    color: var(--text-muted);
}

.task-list {
    flex: 1 1 auto;
    height: 100%;
    min-height: 0;
    border: 1px solid var(--background-modifier-border);
    border-radius: 4px;
    background: var(--background-primary);
    padding-bottom: 50px;
    display: flex;
    flex-direction: column;
    overflow: auto;
}

.task-item {
    padding: 8px 12px;
    cursor: default;
    border-bottom: 1px solid var(--background-modifier-border);
    transition: background-color 0.2s ease;
}

.task-item:last-child {
    border-bottom: none;
}

.task-item:hover {
    background: var(--background-secondary);
}

.task-item.selected {
    background: var(--interactive-accent);
    color: var(--text-on-accent);
}

.task-item.keyboard-selected {
    background: var(--interactive-accent);
    color: var(--text-on-accent);
    box-shadow: 0 0 0 2px var(--interactive-accent-hover);
}

.task-item.completed {
    cursor: default;
}

/* \u5B8C\u4E86\u6E08\u307F\u30BF\u30B9\u30AF\u306E\u30C9\u30E9\u30C3\u30B0\u30CF\u30F3\u30C9\u30EB\u306F\u8868\u793A\u3059\u308B\u304C\u7121\u52B9\u5316 */
.drag-handle.disabled {
    cursor: default;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease;
}

.task-item:hover .drag-handle.disabled {
    opacity: 0.3;
}

.task-item {
    display: grid;
    grid-template-columns: 20px 40px 1fr 220px 110px 50px 30px 30px 30px;
    gap: 8px;
    align-items: center;
    padding: 2px 10px 2px 15px;
    margin: 2px 0;
}

/* \u30C9\u30E9\u30C3\u30B0\u30CF\u30F3\u30C9\u30EB\u306E\u30B9\u30BF\u30A4\u30EB */
.drag-handle {
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    color: var(--text-muted);
    opacity: 0;
    transition: opacity 0.2s ease, background-color 0.2s ease;
    border-radius: 4px;
}

.task-item:hover .drag-handle {
    opacity: 0.6;
}

.drag-handle:hover {
    opacity: 1 !important;
    color: var(--text-normal);
    background-color: var(--background-modifier-hover);
}

.drag-handle:active {
    cursor: grabbing;
}

.drag-handle svg {
    width: 10px;
    height: 16px;
}

.task-item.dragging {
    opacity: 0.5;
    background: var(--background-modifier-hover);
    transform: scale(0.98);
    transition: all 0.2s ease;
}

.task-item.dragover {
    border-top: 2px solid var(--interactive-accent);
    margin-top: -2px;
}

.task-item.dragover-invalid {
    border-top: 2px solid var(--text-error);
    margin-top: -2px;
    opacity: 0.7;
    cursor: not-allowed;
    background-color: rgba(255, 0, 0, 0.05);
    position: relative;
}

.task-item.dragover-invalid::after {
    content: "\u274C \u3053\u3053\u306B\u306F\u914D\u7F6E\u3067\u304D\u307E\u305B\u3093";
    position: absolute;
    top: -25px;
    left: 50%;
    transform: translateX(-50%);
    background-color: var(--text-error);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    z-index: 1000;
    pointer-events: none;
}

.task-name {
    cursor: pointer;
    font-weight: 500;
    font-size: 13px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    margin-right: -4px; /* \u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3068\u306E\u9593\u9694\u3092\u72ED\u3081\u308B */
}

.task-time-range {
    font-size: 12px;
    color: var(--text-muted);
    font-family: monospace;
    white-space: nowrap;
    text-align: center;
    display: flex;
    justify-content: center;
    align-items: center;
}
.task-duration,
.task-timer-display {
    font-size: 12px;
    color: var(--text-muted);
    text-align: center;
    font-family: monospace;
}

.task-timer-display {
    color: var(--interactive-accent);
    font-weight: bold;
}

.time-slot-header {
    background: var(--background-secondary);
    color: var(--text-muted);
    font-size: 12px;
    font-weight: 600;
    padding: 6px 12px;
    margin: 8px 0 4px 0;
    border-radius: 4px;
    border-left: 3px solid var(--interactive-accent);
}

.time-slot-header.other {
    border-left-color: var(--background-modifier-border);
}

.time-slot-header.dragover {
    background: var(--background-modifier-hover);
    border-left-width: 5px;
    transition: all 0.2s ease;
}

.routine-button {
    background: none;
    border: none;
    font-size: 14px;
    cursor: pointer;
    padding: 2px;
    border-radius: 4px;
    transition: all 0.2s ease;
    opacity: 0.4;
    width: 100%;
    text-align: center;
}

.routine-button:hover {
    opacity: 1;
    background: var(--background-modifier-border);
}

.routine-button.active {
    opacity: 1;
    color: var(--interactive-accent);
}

/* \u30B3\u30E1\u30F3\u30C8\u30DC\u30BF\u30F3\u30B9\u30BF\u30A4\u30EB */
.comment-button {
    font-size: 15px;
    border: none;
    background: none;
    cursor: pointer;
    color: var(--text-muted);
    padding: 2px;
    border-radius: 4px;
    transition: all 0.2s ease;
    opacity: 0;
    width: 100%;
    text-align: center;
    visibility: visible; /* \u30C7\u30D5\u30A9\u30EB\u30C8\u306F\u8868\u793A */
}

.task-item:hover .comment-button:not(.disabled) {
    opacity: 0.6;
}

.comment-button:not(.disabled):hover {
    opacity: 1 !important;
    background: var(--background-modifier-border);
    color: var(--text-normal);
}

/* \u30B3\u30E1\u30F3\u30C8\u30DC\u30BF\u30F3\u306E\u7121\u52B9\u5316\u30B9\u30BF\u30A4\u30EB - \u30B9\u30DA\u30FC\u30B9\u306F\u7DAD\u6301\u3057\u3066\u975E\u8868\u793A */
.comment-button.disabled {
    visibility: hidden;
}

/* \u65E2\u5B58\u30B3\u30E1\u30F3\u30C8\u304C\u3042\u308B\u5834\u5408\u306F\u8868\u793A\u3059\u308B\u304C\u3001\u30AF\u30EA\u30C3\u30AF\u4E0D\u53EF */
.comment-button.disabled.active {
    visibility: visible;
    opacity: 0.6;
    pointer-events: none;
    cursor: not-allowed;
}

.comment-button.active {
    opacity: 0.6;
    color: var(--interactive-accent);
}

.task-item:hover .comment-button.active {
    opacity: 1;
}

/* \u5B8C\u4E86\u6E08\u307F\u3067\u30B3\u30E1\u30F3\u30C8\u672A\u8A18\u5165\u306E\u30BF\u30B9\u30AF - \u901A\u5E38\u6642\u975E\u8868\u793A\u3001\u30DB\u30D0\u30FC\u6642\u8868\u793A\uFF08\u7A7A\u9593\u306F\u4FDD\u6301\uFF09 */
.comment-button.no-comment {
    opacity: 0;
    visibility: hidden;
}

.task-item:hover .comment-button.no-comment {
    opacity: 0.6;
    visibility: visible;
}

/* \u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u8868\u793A\u30B3\u30F3\u30DD\u30FC\u30CD\u30F3\u30C8\u5168\u4F53 */
.taskchute-project-display {
    display: flex;
    align-items: center;
    gap: 4px;
    justify-content: flex-start;
    margin-right: 32px; /* \u6642\u9593\u3068\u306E\u9593\u9694\u3092\u5E83\u3052\u308B */
}

/* \u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30DC\u30BF\u30F3\uFF08\u30D5\u30A9\u30EB\u30C0\u30A2\u30A4\u30B3\u30F3 + \u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u540D\uFF09 */
.taskchute-project-button {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 2px 8px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
    background: var(--background-secondary);
    border: 1px solid var(--background-modifier-border);
    color: var(--text-normal);
    font-size: 13px;
    max-width: 100%;
}

.taskchute-project-button:hover {
    background: var(--background-modifier-hover);
    border-color: var(--interactive-accent);
}

/* \u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u672A\u8A2D\u5B9A\u306E\u5834\u5408 */
.taskchute-project-button.empty {
    color: var(--text-muted);
    border-style: dashed;
}

/* \u30D5\u30A9\u30EB\u30C0\u30A2\u30A4\u30B3\u30F3 */
.taskchute-project-icon {
    font-size: 14px;
    flex-shrink: 0;
}

/* \u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u540D */
.taskchute-project-name {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

/* External Link\u30A2\u30A4\u30B3\u30F3 */
.taskchute-external-link {
    font-size: 14px;
    cursor: pointer;
    padding: 2px 4px;
    border-radius: 4px;
    transition: all 0.2s ease;
    color: var(--text-muted);
}

.taskchute-external-link:hover {
    background: var(--background-modifier-hover);
    color: var(--interactive-accent);
}

/* \u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u672A\u8A2D\u5B9A\u6642\u306E\u30D7\u30EC\u30FC\u30B9\u30DB\u30EB\u30C0\u30FC */
.taskchute-project-placeholder {
    display: inline-flex;
    align-items: center;
    padding: 2px 8px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
    opacity: 0;
    border: 1px dashed var(--background-modifier-border);
    color: var(--text-muted);
    font-size: 13px;
    min-width: 100px;
}

.taskchute-project-placeholder::before {
    content: "\u{1F4C1} \u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3092\u8A2D\u5B9A";
    font-size: 13px;
}

.task-item:hover .taskchute-project-placeholder {
    opacity: 0.6;
}

/* \u30DB\u30D0\u30FC\u6642\u306E\u660E\u308B\u304F\u306A\u308B\u52B9\u679C\u3092\u524A\u9664 */
.taskchute-project-placeholder:hover {
    /* opacity: 1 !important; \u524A\u9664 */
    /* background: var(--background-modifier-hover); \u524A\u9664 */
    /* border-color: var(--interactive-accent); \u524A\u9664 */
    /* color: var(--text-normal); \u524A\u9664 */
}

/* \u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30DC\u30BF\u30F3\u30B9\u30BF\u30A4\u30EB */
.project-button,
.project-placeholder {
    margin-left: 15px;
    margin-right: 4px;
    font-size: 14px;
    border: none;
    background: none;
    padding: 2px 6px;
    border-radius: 4px;
    transition: all 0.2s ease;
    min-width: 26px; /* \u4E00\u5B9A\u306E\u5E45\u3092\u78BA\u4FDD */
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

.project-button {
    cursor: pointer;
    color: var(--text-muted);
    opacity: 0.7;
}

.project-button:hover {
    opacity: 1;
    background: var(--background-modifier-border);
    color: var(--text-normal);
}

.project-placeholder {
    /* \u900F\u660E\u3067\u30B9\u30DA\u30FC\u30B9\u306E\u307F\u78BA\u4FDD */
    opacity: 0;
    pointer-events: none;
}

.task-list-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    gap: 8px;
}

.header-left-section {
    display: flex;
    align-items: center;
    gap: 8px;
}

.header-left-section h5 {
    margin: 0;
    color: var(--text-muted);
}

.header-right-section {
    display: flex;
    align-items: center;
}

/* Grayed out effect for task list */
.task-list-container.grayed-out {
    opacity: 0.6;
    pointer-events: none;
}

.add-task-button {
    margin-left: 0;
    margin-right: 15px;
}

.add-task-button.repositioned {
    margin-left: 0;
    margin-right: 0;
}

.robot-terminal-button {
    background: var(--background-primary);
    border: 1px solid var(--background-modifier-border);
    border-radius: 4px;
    padding: 4px 8px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.2s ease;
    margin-right: 15px;
}

.robot-terminal-button:hover {
    background: var(--background-modifier-hover);
}

/* \u30E2\u30FC\u30C0\u30EB\u30B9\u30BF\u30A4\u30EB */
.task-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
}

.task-modal-content {
    background: var(--background-primary);
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    width: 90%;
    max-width: 500px;
    max-height: 80vh;
    overflow-y: auto;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px 20px 0 20px;
    border-bottom: 1px solid var(--background-modifier-border);
}

.modal-header h3 {
    margin: 0;
    color: var(--text-normal);
}

.modal-close-button {
    background: none;
    border: none;
    font-size: 24px;
    color: var(--text-muted);
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    transition: all 0.2s ease;
}

.modal-close-button:hover {
    background: var(--background-modifier-border);
    color: var(--text-normal);
}

.task-form {
    padding: 20px;
}

.form-group {
    margin-bottom: 15px;
}

.form-label {
    display: block;
    margin-bottom: 5px;
    font-weight: 500;
    color: var(--text-normal);
}

.form-input,
.form-textarea {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid var(--background-modifier-border);
    border-radius: 4px;
    background: var(--background-primary);
    color: var(--text-normal);
    font-family: inherit;
    font-size: 14px;
    box-sizing: border-box;
}

/* \u30BB\u30EC\u30AF\u30C8\u30DC\u30C3\u30AF\u30B9\u306E\u9AD8\u3055\u8ABF\u6574 */
select.form-input {
    min-height: 36px;
    line-height: 1.5;
    padding: 8px 12px;
}

.form-input:focus,
.form-textarea:focus {
    outline: none;
    border-color: var(--interactive-accent);
    box-shadow: 0 0 0 2px rgba(var(--interactive-accent-rgb), 0.2);
}

.form-textarea {
    min-height: 80px;
    resize: vertical;
}

.form-button-group {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
    margin-top: 20px;
}

.form-button {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    min-width: 80px;
}

.form-button.cancel {
    background: var(--background-modifier-border);
    color: var(--text-normal);
}

.form-button.cancel:hover {
    background: var(--background-modifier-border-hover);
}

.form-button.create {
    background: var(--interactive-accent);
    color: var(--text-on-accent);
}

.form-button.create:hover {
    background: var(--interactive-accent-hover);
}

.form-description {
    margin: 0;
    color: var(--text-muted);
    font-size: 13px;
    line-height: 1.4;
}

.task-name.wikilink {
    color: var(--link-color);
    text-decoration: none;
    cursor: pointer;
    font-weight: 500;
    border-radius: 3px;
    padding: 2px 4px;
    transition: background 0.15s;
}
.task-name.wikilink:hover {
    background: var(--background-modifier-hover);
    color: var(--link-color-hover);
}
.play-stop-button {
    font-size: 18px;
    border: none;
    background: none;
    cursor: pointer;
    transition: color 0.2s;
    color: #3498db;
    padding: 2px;
    border-radius: 4px;
    width: 100%;
    text-align: center;
}
.play-stop-button.stop {
    color: #e74c3c;
    font-weight: bold;
    background: var(--background-modifier-border);
}
.task-item.selected {
    background: var(--interactive-accent);
    color: var(--text-on-accent);
    font-weight: bold;
}
.delete-task-button {
    margin-left: 8px;
    font-size: 15px;
    border: none;
    background: none;
    cursor: pointer;
    color: #e74c3c;
    padding: 2px 6px;
    border-radius: 4px;
    transition: background 0.2s;
}
.delete-task-button:hover {
    background: var(--background-modifier-border);
}

/* \u8A2D\u5B9A\u30DC\u30BF\u30F3\u30B9\u30BF\u30A4\u30EB */
.settings-task-button {
    font-size: 15px;
    border: none;
    background: none;
    cursor: pointer;
    color: var(--text-muted);
    padding: 2px;
    margin-right: 10px;
    border-radius: 4px;
    transition: all 0.2s ease;
    opacity: 0.6;
    width: 100%;
    text-align: center;
}

.settings-task-button:hover {
    opacity: 1;
    background: var(--background-modifier-border);
    color: var(--text-normal);
}

/* \u30C4\u30FC\u30EB\u30C1\u30C3\u30D7\u30B9\u30BF\u30A4\u30EB */
.task-settings-tooltip {
    background: var(--background-primary);
    border: 1px solid var(--background-modifier-border);
    border-radius: 6px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    padding: 4px 0;
    min-width: 140px;
    font-size: 13px;
    z-index: 1000;
}

.tooltip-header {
    display: flex;
    justify-content: flex-end;
    padding: 4px 8px 0 8px;
    margin-bottom: 4px;
}

.tooltip-close-button {
    background: none;
    border: none;
    font-size: 16px;
    color: var(--text-muted);
    cursor: pointer;
    padding: 0;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 3px;
    transition: all 0.2s ease;
}

.tooltip-close-button:hover {
    background: var(--background-modifier-border);
    color: var(--text-normal);
}

.tooltip-item {
    padding: 8px 12px;
    cursor: pointer;
    transition: background-color 0.2s ease;
    display: flex;
    align-items: center;
    gap: 8px;
}

.tooltip-item:hover {
    background: var(--background-secondary);
}

.tooltip-item.delete-item:hover {
    background: rgba(231, 76, 60, 0.1);
}

.tooltip-item.project-item {
    color: var(--text-normal);
}

.tooltip-item.project-item:hover {
    background: var(--background-secondary);
}

.tooltip-item.disabled {
    opacity: 0.5;
    color: var(--text-muted);
    cursor: not-allowed;
}

.tooltip-item.disabled:hover {
    background: none;
}

.date-nav-container {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 8px;
    gap: 2px;
    height: 36px;
}

.date-nav-container.compact {
    flex: 1; /* Take remaining space in top-bar-container */
    margin-bottom: 0; /* Remove bottom margin */
    gap: 1px;
    height: 100%; /* Match parent height */
    display: flex;
    align-items: center;
    justify-content: center;
}

.date-nav-arrow {
    background: none;
    border: none;
    font-size: 28px;
    color: #888;
    cursor: pointer;
    padding: 0 8px;
    transition: color 0.2s;
}

.date-nav-container.compact .date-nav-arrow {
    font-size: 20px;
    padding: 0 4px;
}

.date-nav-arrow:hover {
    color: #1976d2;
}

.date-nav-label {
    font-size: 15px;
    font-weight: bold;
    color: #1976d2;
    min-width: 90px;
    text-align: center;
    letter-spacing: 0.5px;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 28px;
    margin-right: 3px;
}

.date-nav-container.compact .date-nav-label {
    font-size: 15px;
    min-width: 90px;
    letter-spacing: 0.5px;
    height: 24px;
}
.calendar-btn {
    background: none;
    border: none;
    font-size: 16px;
    padding: 2px 2px;
    margin: 0 1px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    height: 24px;
    width: 24px;
    border-radius: 6px;
    transition: background 0.2s;
}
.calendar-btn:hover {
    background: var(--background-modifier-border);
}
.date-wikilink {
    color: #1976d2 !important;
    font-weight: bold;
    text-decoration: none;
    display: inline-block;
    text-align: center;
    min-width: 60px;
    padding: 0 1px;
}

/* \u5B8C\u4E86\u6F14\u51FA\u30B9\u30BF\u30A4\u30EB */


@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}



@keyframes bounceIn {
    0% {
        transform: scale(0.3);
        opacity: 0;
    }
    50% {
        transform: scale(1.05);
    }
    70% {
        transform: scale(0.9);
    }
    100% {
        transform: scale(1);
        opacity: 1;
    }
}



@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.05); }
}



.fireworks-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
}

.firework {
    position: absolute;
    width: 8px;
    height: 8px;
    border-radius: 50%;
    animation: fireworkExplosion 2s ease-out forwards;
}

@keyframes fireworkExplosion {
    0% {
        transform: scale(0);
        opacity: 1;
    }
    50% {
        transform: scale(1);
        opacity: 1;
    }
    100% {
        transform: scale(0);
        opacity: 0;
    }
}




/* \u82B1\u706B\u306E\u8FFD\u52A0\u30A8\u30D5\u30A7\u30AF\u30C8 */
.firework::before,
.firework::after {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background: inherit;
    animation: fireworkSparkle 2s ease-out forwards;
}

.firework::before {
    animation-delay: 0.1s;
}

.firework::after {
    animation-delay: 0.2s;
}

@keyframes fireworkSparkle {
    0% {
        transform: scale(0) rotate(0deg);
        opacity: 1;
    }
    100% {
        transform: scale(2) rotate(360deg);
        opacity: 0;
    }
}

/* \u30D1\u30FC\u30C6\u30A3\u30AF\u30EB\u52B9\u679C */
.particle {
    position: absolute;
    width: 4px;
    height: 4px;
    border-radius: 50%;
    animation: particleExplosion 1.5s ease-out forwards;
}

@keyframes particleExplosion {
    0% {
        transform: scale(0) translateX(0);
        opacity: 1;
    }
    50% {
        transform: scale(1) translateX(50px);
        opacity: 1;
    }
    100% {
        transform: scale(0) translateX(100px);
        opacity: 0;
    }
}

/* \u8FFD\u52A0\u306E\u6F14\u51FA\u52B9\u679C */


@keyframes glowPulse {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.8; }
}

/* \u7D71\u8A08\u8868\u793A\u30B9\u30BF\u30A4\u30EB */


.stat-item {
    text-align: center;
    background: rgba(255, 255, 255, 0.1);
    padding: 15px;
    border-radius: 10px;
    backdrop-filter: blur(10px);
}

.stat-number {
    display: block;
    font-size: 24px;
    font-weight: bold;
    color: white;
    margin-bottom: 5px;
}

.stat-label {
    display: block;
    font-size: 14px;
    color: rgba(255, 255, 255, 0.8);
}

/* \u7D19\u5439\u96EA\u30A8\u30D5\u30A7\u30AF\u30C8 */
.confetti-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: hidden;
}

.confetti {
    position: absolute;
    top: -10px;
    border-radius: 2px;
    animation: confettiFall 3s linear forwards;
}

@keyframes confettiFall {
    0% {
        transform: translateY(-10px) rotate(0deg);
        opacity: 1;
    }
    100% {
        transform: translateY(100vh) rotate(720deg);
        opacity: 0;
    }
}

/* \u8FFD\u52A0\u306E\u6F14\u51FA\u52B9\u679C */


@keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
}

/* \u30C1\u30A7\u30C3\u30AF\u30DC\u30C3\u30AF\u30B9\u30B9\u30BF\u30A4\u30EB */
.form-checkbox {
    margin-left: 10px;
    width: 16px;
    height: 16px;
    accent-color: var(--interactive-accent);
}

.form-checkbox:checked {
    background-color: var(--interactive-accent);
    border-color: var(--interactive-accent);
}

/* \u30E9\u30B8\u30AA\u30DC\u30BF\u30F3\u30B0\u30EB\u30FC\u30D7\u30B9\u30BF\u30A4\u30EB */
.radio-group {
    display: flex;
    gap: 20px;
    margin-top: 8px;
}

.radio-group input[type="radio"] {
    margin-right: 8px;
    accent-color: var(--interactive-accent);
}

.radio-group label {
    display: flex;
    align-items: center;
    cursor: pointer;
    font-size: 14px;
    color: var(--text-normal);
}

/* \u30BB\u30EC\u30AF\u30C8\u30DC\u30C3\u30AF\u30B9\u30B9\u30BF\u30A4\u30EB */
.form-input[type="time"],
.form-input[type="select"] {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid var(--background-modifier-border);
    border-radius: 4px;
    background: var(--background-primary);
    color: var(--text-normal);
    font-family: inherit;
    font-size: 14px;
    box-sizing: border-box;
}

.form-input[type="time"]:focus,
.form-input[type="select"]:focus {
    outline: none;
    border-color: var(--interactive-accent);
    box-shadow: 0 0 0 2px rgba(var(--interactive-accent-rgb), 0.2);
}

/* \u30BF\u30B9\u30AF\u5B8C\u4E86\u30B3\u30E1\u30F3\u30C8\u30E2\u30FC\u30C0\u30EB\u306E\u30B9\u30BF\u30A4\u30EB */
.completion-modal {
    max-width: 500px;
    max-height: 80vh;
    overflow-y: auto;
}

.completion-form {
    display: flex;
    flex-direction: column;
    gap: 16px;
}

.completion-time-info {
    background: var(--background-secondary);
    padding: 12px;
    border-radius: 6px;
    border: 1px solid var(--background-modifier-border);
}

.completion-time-info p {
    margin: 4px 0;
    font-size: 14px;
    color: var(--text-normal);
}

.completion-rating-section {
    background: var(--background-secondary);
    padding: 16px;
    border-radius: 6px;
    border: 1px solid var(--background-modifier-border);
}

.completion-rating-section h4 {
    margin: 0 0 16px 0;
    font-size: 16px;
    color: var(--text-normal);
}

.rating-group {
    margin-bottom: 16px;
}

.rating-label {
    display: block;
    margin-bottom: 8px;
    font-size: 14px;
    font-weight: 500;
    color: var(--text-normal);
}

.star-rating {
    display: flex;
    gap: 4px;
    margin-bottom: 8px;
}

.star-rating .star {
    font-size: 20px;
    cursor: pointer;
    transition: all 0.2s ease;
    user-select: none;
    opacity: 0.3;
}

.star-rating .star:hover {
    transform: scale(1.2);
}

.energy-select {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid var(--background-modifier-border);
    border-radius: 4px;
    background: var(--background-primary);
    color: var(--text-normal);
    font-family: inherit;
    font-size: 14px;
    box-sizing: border-box;
}

.energy-select:focus {
    outline: none;
    border-color: var(--interactive-accent);
    box-shadow: 0 0 0 2px rgba(var(--interactive-accent-rgb), 0.2);
}

.completion-comment {
    width: 100%;
    min-height: 100px;
    padding: 12px;
    border: 1px solid var(--background-modifier-border);
    border-radius: 6px;
    background: var(--background-primary);
    color: var(--text-normal);
    font-family: inherit;
    font-size: 14px;
    resize: vertical;
    box-sizing: border-box;
}

/* \u5165\u529B\u6642\u306E\u30C6\u30AD\u30B9\u30C8\u8272\u3092\u660E\u308B\u304F\u3059\u308B */
.completion-comment:not(:placeholder-shown) {
    color: rgba(255, 255, 255, 0.9);
}

.completion-comment:focus {
    outline: none;
    border-color: var(--interactive-accent);
    box-shadow: 0 0 0 2px rgba(var(--interactive-accent-rgb), 0.2);
}

.completion-comment::placeholder {
    color: var(--text-faint);
    opacity: 0.6;
    font-style: italic;
}

.tag-selection {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 8px;
}

.tag-option {
    padding: 6px 12px;
    background: var(--background-modifier-border);
    color: var(--text-muted);
    border-radius: 16px;
    cursor: pointer;
    font-size: 12px;
    transition: all 0.2s ease;
    user-select: none;
}

.tag-option:hover {
    background: var(--background-modifier-border-hover);
    color: var(--text-normal);
}

.tag-option.selected {
    background: var(--interactive-accent);
    color: var(--text-on-accent);
}

.form-button-group {
    display: flex;
    gap: 12px;
    justify-content: flex-end;
    margin-top: 8px;
}

.form-button {
    padding: 10px 20px;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    min-width: 80px;
}

.form-button.primary {
    background: var(--interactive-accent);
    color: var(--text-on-accent);
}

.form-button.primary:hover {
    background: var(--interactive-accent-hover);
}

.form-button.secondary {
    background: var(--background-modifier-border);
    color: var(--text-normal);
}

.form-button.secondary:hover {
    background: var(--background-modifier-border-hover);
}

/* \u30EC\u30B9\u30DD\u30F3\u30B7\u30D6\u5BFE\u5FDC - \u30B3\u30F3\u30C6\u30CA\u30D9\u30FC\u30B9\u306E\u8ABF\u6574 */
/* \u4E2D\u9593\u306E\u5E45\uFF08800px\u4EE5\u4E0B\u76F8\u5F53\uFF09 */
.taskchute-narrow .task-item {
    /* \u30B0\u30EA\u30C3\u30C9\u30EC\u30A4\u30A2\u30A6\u30C8\u3092\u8ABF\u6574 - \u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3068\u6642\u9593\u3092\u7E2E\u5C0F */
    grid-template-columns: 20px 40px minmax(150px, 1fr) 120px 80px 40px 30px 30px 30px;
    gap: 4px;
}

.taskchute-narrow .task-name {
    min-width: 150px;
}

.taskchute-narrow .taskchute-project-display {
    max-width: 120px;
    margin-right: 4px;
}

.taskchute-narrow .taskchute-project-name {
    max-width: 100px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.taskchute-narrow .task-time-range {
    font-size: 11px;
}

.taskchute-narrow .routine-button,
.taskchute-narrow .comment-button {
    font-size: 13px;
}

/* \u3055\u3089\u306B\u72ED\u3044\u5E45\uFF08600px\u4EE5\u4E0B\u76F8\u5F53\uFF09 */
.taskchute-very-narrow .task-item {
    /* \u30BF\u30B9\u30AF\u540D\u3092\u6700\u512A\u5148\u306B\u3057\u3001\u5FC5\u8981\u306A\u30DC\u30BF\u30F3\u306E\u307F\u8868\u793A */
    grid-template-columns: 20px 40px 1fr 30px 30px;
    gap: 2px;
}

/* \u8868\u793A\u3059\u308B\u8981\u7D20\u3092\u9650\u5B9A */
.taskchute-very-narrow .task-item > *:nth-child(n+6) {
    display: none;
}

/* \u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3001\u6642\u9593\u8868\u793A\u3001\u5B9F\u884C\u6642\u9593\u3092\u975E\u8868\u793A */
.taskchute-very-narrow .taskchute-project-display,
.taskchute-very-narrow .task-time-range,
.taskchute-very-narrow .task-duration {
    display: none;
}

/* \u65E5\u8DE8\u304E\u30BF\u30B9\u30AF\u306E\u30B9\u30BF\u30A4\u30EB */
.task-duration.cross-day {
    color: var(--text-accent);
    font-weight: 500;
    position: relative;
}

.task-duration.cross-day::after {
    content: "\u{1F319}";
    font-size: 0.8em;
    margin-left: 4px;
    opacity: 0.7;
}

/* \u30BF\u30B9\u30AF\u540D\u3092\u6700\u5927\u9650\u8868\u793A */
.taskchute-very-narrow .task-name {
    min-width: 80px;
}

/* \u30EB\u30FC\u30C1\u30F3\u30DC\u30BF\u30F3\u3068\u8A2D\u5B9A\u30DC\u30BF\u30F3\u306E\u307F\u8868\u793A */
.taskchute-very-narrow .task-item > *:nth-child(7),  /* \u30EB\u30FC\u30C1\u30F3\u30DC\u30BF\u30F3 */
.taskchute-very-narrow .task-item > *:nth-child(9) {  /* \u8A2D\u5B9A\u30DC\u30BF\u30F3 */
    display: flex;
}

/* \u30EB\u30FC\u30C1\u30F3\u8A2D\u5B9A\u30E2\u30FC\u30C0\u30EB\u306E\u65B0\u3057\u3044\u30B9\u30BF\u30A4\u30EB */
.checkbox-group {
    display: flex;
    gap: 20px;
    margin-bottom: 10px;
}

.checkbox-label {
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    user-select: none;
}

.checkbox-label input[type="checkbox"] {
    cursor: pointer;
    margin: 0;
}

.weekday-checkboxes {
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    padding: 10px 0;
}

.weekday-checkbox-label {
    display: flex;
    align-items: center;
    gap: 5px;
    cursor: pointer;
    user-select: none;
    padding: 5px 10px;
    border: 1px solid var(--background-modifier-border);
    border-radius: 4px;
    transition: all 0.2s ease;
}

.weekday-checkbox-label:hover {
    background-color: var(--background-modifier-hover);
}

.weekday-checkbox-label input[type="checkbox"] {
    cursor: pointer;
    margin: 0;
}

.weekday-checkbox-label input[type="checkbox"]:checked + span {
    font-weight: bold;
    color: var(--text-accent);
}

/* \u66DC\u65E5\u9078\u629E\u30B0\u30EB\u30FC\u30D7\u5168\u4F53\u306E\u30B9\u30BF\u30A4\u30EB */
#edit-weekday-group {
    transition: all 0.3s ease;
    overflow: hidden;
}

#edit-weekday-group[style*="display: none"] {
    max-height: 0;
    opacity: 0;
}

#edit-weekday-group[style*="display: block"] {
    max-height: 200px;
    opacity: 1;
}

/* \u30BF\u30B9\u30AF\u540D\u691C\u8A3C\u30B9\u30BF\u30A4\u30EB */
.form-input.error {
    border-color: #e74c3c;
    background-color: #fee;
}

.task-name-warning {
    color: #e74c3c;
    font-size: 12px;
    margin-top: 4px;
    padding: 4px 8px;
    background-color: #fee;
    border-radius: 4px;
}

.task-name-warning.hidden {
    display: none;
}

.task-name-warning.highlight {
    animation: flash 0.3s ease-in-out;
}

@keyframes flash {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

.form-button.disabled {
    background-color: #ccc;
    cursor: not-allowed;
    opacity: 0.6;
}

/* Phase 1: \u6700\u4E0B\u90E8\u3078\u306E\u30C9\u30ED\u30C3\u30D7\u30A4\u30F3\u30B8\u30B1\u30FC\u30BF\u30FC */
.task-item.dragover-bottom {
    border-bottom: 2px solid var(--interactive-accent);
    margin-bottom: -2px;
}

.task-list.dragover-bottom::after {
    content: '';
    display: block;
    height: 2px;
    background-color: var(--interactive-accent);
    margin-top: 4px;
}
`;

// src/views/TaskChuteView.helpers.ts
async function loadTasksRefactored() {
  var _a;
  this.tasks = [];
  this.taskInstances = [];
  try {
    const dateString = this.getCurrentDateString();
    const todayExecutions = await loadTodayExecutions.call(this, dateString);
    const taskFolderPath = this.plugin.pathManager.getTaskFolderPath();
    const taskFolder = this.app.vault.getAbstractFileByPath(taskFolderPath);
    if (!taskFolder) {
      this.renderTaskList();
      return;
    }
    const taskFiles = taskFolder.children.filter(
      (file) => file.extension === "md"
    );
    const processedTaskNames = /* @__PURE__ */ new Set();
    const processedFilePaths = /* @__PURE__ */ new Set();
    for (const exec of todayExecutions) {
      if (!processedTaskNames.has(exec.taskTitle)) {
        processedTaskNames.add(exec.taskTitle);
        const taskFile = taskFiles.find((f) => f.basename === exec.taskTitle);
        if (taskFile) {
          processedFilePaths.add(taskFile.path);
        }
        const taskExecutions = todayExecutions.filter(
          (e) => e.taskTitle === exec.taskTitle
        );
        await createTaskFromExecutions.call(this, taskExecutions, taskFile, dateString);
      }
    }
    for (const file of taskFiles) {
      if (processedFilePaths.has(file.path)) continue;
      const content = await this.app.vault.read(file);
      const metadata = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if (!content.includes("#task") && !(metadata == null ? void 0 : metadata.estimatedMinutes)) {
        continue;
      }
      const isRoutine = (metadata == null ? void 0 : metadata.isRoutine) === true || content.includes("#routine");
      if (isRoutine) {
        if (shouldShowRoutineTask.call(this, metadata, this.currentDate, dateString)) {
          await createRoutineTask.call(this, file, content, metadata, dateString);
        }
      } else {
        const shouldShow = await shouldShowNonRoutineTask.call(this, file, metadata, dateString);
        if (shouldShow) {
          await createNonRoutineTask.call(this, file, content, metadata, dateString);
        }
      }
    }
    this.renderTaskList();
  } catch (error) {
    console.error("Failed to load tasks:", error);
    new this.app.constructor.Notice("\u30BF\u30B9\u30AF\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
  }
}
async function loadTodayExecutions(dateString) {
  var _a;
  try {
    const logDataPath = this.plugin.pathManager.getLogDataPath();
    const [year, month] = dateString.split("-");
    const monthString = `${year}-${month}`;
    const logPath = `${logDataPath}/${monthString}-tasks.json`;
    const logFile = this.app.vault.getAbstractFileByPath(logPath);
    if (!logFile) {
      return [];
    }
    const content = await this.app.vault.read(logFile);
    const monthlyLog = JSON.parse(content);
    const dayExecutions = ((_a = monthlyLog.taskExecutions) == null ? void 0 : _a[dateString]) || [];
    return dayExecutions.map((exec) => ({
      taskTitle: exec.taskTitle || exec.taskName,
      taskPath: exec.taskPath || "",
      startTime: exec.startTime,
      stopTime: exec.stopTime,
      slotKey: exec.slotKey || calculateSlotKeyFromTime(exec.startTime),
      instanceId: exec.instanceId
    }));
  } catch (error) {
    console.error("Failed to load today executions:", error);
    return [];
  }
}
function calculateSlotKeyFromTime(timeStr) {
  if (!timeStr) return "none";
  const [hourStr] = timeStr.split(":");
  const hour = parseInt(hourStr, 10);
  if (hour >= 0 && hour < 8) return "0:00-8:00";
  if (hour >= 8 && hour < 12) return "8:00-12:00";
  if (hour >= 12 && hour < 16) return "12:00-16:00";
  if (hour >= 16 && hour < 24) return "16:00-0:00";
  return "none";
}
async function createTaskFromExecutions(executions, file, dateString) {
  var _a;
  const metadata = file ? (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter : null;
  let projectPath = null;
  let projectTitle = null;
  if (metadata == null ? void 0 : metadata.project_path) {
    projectPath = metadata.project_path;
    projectTitle = extractProjectTitle(metadata.project);
  } else if (metadata == null ? void 0 : metadata.project) {
    projectTitle = extractProjectTitle(metadata.project);
    if (projectTitle) {
      const allFiles = this.app.vault.getMarkdownFiles();
      const projectFile = allFiles.find((f) => f.basename === projectTitle);
      if (projectFile) {
        projectPath = projectFile.path;
      }
    }
  }
  const taskData = {
    file: file || null,
    frontmatter: metadata || {},
    path: (file == null ? void 0 : file.path) || `TaskChute/Task/${executions[0].taskTitle}.md`,
    name: executions[0].taskTitle,
    title: executions[0].taskTitle,
    project: metadata == null ? void 0 : metadata.project,
    projectPath,
    projectTitle,
    isRoutine: (metadata == null ? void 0 : metadata.isRoutine) === true || false,
    routineType: metadata == null ? void 0 : metadata.routine_type,
    scheduledTime: metadata == null ? void 0 : metadata.\u958B\u59CB\u6642\u523B,
    isVirtual: !file
  };
  this.tasks.push(taskData);
  for (const exec of executions) {
    const instance = {
      task: taskData,
      instanceId: exec.instanceId || this.generateInstanceId(taskData.path),
      state: "done",
      slotKey: exec.slotKey,
      date: dateString,
      startTime: parseTimeString(exec.startTime, dateString),
      stopTime: parseTimeString(exec.stopTime, dateString),
      executedTitle: exec.taskTitle
    };
    const isDeleted = isInstanceDeleted.call(this, instance.instanceId, taskData.path, dateString);
    const isHidden = isInstanceHidden.call(this, instance.instanceId, taskData.path, dateString);
    if (!isDeleted && !isHidden) {
      this.taskInstances.push(instance);
    }
  }
}
async function createNonRoutineTask(file, content, metadata, dateString) {
  let projectPath = null;
  let projectTitle = null;
  if (metadata == null ? void 0 : metadata.project_path) {
    projectPath = metadata.project_path;
    projectTitle = extractProjectTitle(metadata.project);
  } else if (metadata == null ? void 0 : metadata.project) {
    projectTitle = extractProjectTitle(metadata.project);
    if (projectTitle) {
      const allFiles = this.app.vault.getMarkdownFiles();
      const projectFile = allFiles.find((f) => f.basename === projectTitle);
      if (projectFile) {
        projectPath = projectFile.path;
      }
    }
  }
  const taskData = {
    file,
    frontmatter: metadata || {},
    path: file.path,
    name: file.basename,
    title: file.basename,
    project: metadata == null ? void 0 : metadata.project,
    projectPath,
    projectTitle,
    isRoutine: false,
    scheduledTime: metadata == null ? void 0 : metadata.\u958B\u59CB\u6642\u523B
  };
  this.tasks.push(taskData);
  const instance = {
    task: taskData,
    instanceId: this.generateInstanceId(taskData.path),
    state: "idle",
    slotKey: getScheduledSlotKey(metadata == null ? void 0 : metadata.\u958B\u59CB\u6642\u523B) || "none",
    date: dateString
  };
  const deletedKey = `taskchute-deleted-instances-${dateString}`;
  const deletedInstances = JSON.parse(localStorage.getItem(deletedKey) || "[]");
  const isDeleted = deletedInstances.some(
    (d) => d.path === file.path
  );
  if (!isDeleted) {
    this.taskInstances.push(instance);
  }
}
async function createRoutineTask(file, content, metadata, dateString) {
  let projectPath = null;
  let projectTitle = null;
  if (metadata == null ? void 0 : metadata.project_path) {
    projectPath = metadata.project_path;
    projectTitle = extractProjectTitle(metadata.project);
  } else if (metadata == null ? void 0 : metadata.project) {
    projectTitle = extractProjectTitle(metadata.project);
    if (projectTitle) {
      const allFiles = this.app.vault.getMarkdownFiles();
      const projectFile = allFiles.find((f) => f.basename === projectTitle);
      if (projectFile) {
        projectPath = projectFile.path;
      }
    }
  }
  const taskData = {
    file,
    frontmatter: metadata || {},
    path: file.path,
    name: file.basename,
    title: file.basename,
    project: metadata == null ? void 0 : metadata.project,
    projectPath,
    projectTitle,
    isRoutine: true,
    routineType: (metadata == null ? void 0 : metadata.routine_type) || "daily",
    scheduledTime: metadata == null ? void 0 : metadata.\u958B\u59CB\u6642\u523B,
    weekday: metadata == null ? void 0 : metadata.weekday,
    weekdays: metadata == null ? void 0 : metadata.weekdays,
    monthlyWeek: metadata == null ? void 0 : metadata.monthly_week,
    monthlyWeekday: metadata == null ? void 0 : metadata.monthly_weekday
  };
  this.tasks.push(taskData);
  const instance = {
    task: taskData,
    instanceId: this.generateInstanceId(taskData.path),
    state: "idle",
    slotKey: getScheduledSlotKey(metadata == null ? void 0 : metadata.\u958B\u59CB\u6642\u523B) || "none",
    date: dateString
  };
  const hiddenKey = `taskchute-hidden-routines-${dateString}`;
  const hiddenRoutines = JSON.parse(localStorage.getItem(hiddenKey) || "[]");
  const isHidden = hiddenRoutines.some(
    (h) => typeof h === "string" ? h === file.path : h.path === file.path
  );
  const deletedKey = `taskchute-deleted-instances-${dateString}`;
  const deletedInstances = JSON.parse(localStorage.getItem(deletedKey) || "[]");
  const isDeleted = deletedInstances.some(
    (d) => d.path === file.path && (!d.instanceId || d.instanceId === instance.instanceId)
  );
  if (!isHidden && !isDeleted) {
    this.taskInstances.push(instance);
  }
}
function shouldShowRoutineTask(metadata, date, dateString) {
  if (!metadata) return false;
  const hasMovedTargetDate = metadata.target_date && metadata.target_date !== metadata.routine_start;
  if (hasMovedTargetDate) {
    return dateString === metadata.target_date;
  }
  const routineType = metadata.routine_type || "daily";
  const dayOfWeek = date.getDay();
  switch (routineType) {
    case "daily":
      return true;
    case "weekdays":
      return dayOfWeek >= 1 && dayOfWeek <= 5;
    // Monday to Friday
    case "weekends":
      return dayOfWeek === 0 || dayOfWeek === 6;
    // Saturday and Sunday
    case "weekly":
    case "custom":
      if (metadata.weekday !== void 0) {
        return dayOfWeek === metadata.weekday;
      }
      if (metadata.weekdays && Array.isArray(metadata.weekdays)) {
        return metadata.weekdays.includes(dayOfWeek);
      }
      return false;
    case "monthly":
      if (metadata.monthly_week !== void 0 && metadata.monthly_weekday !== void 0) {
        if (dayOfWeek !== metadata.monthly_weekday) {
          return false;
        }
        if (metadata.monthly_week === "last") {
          const nextWeek = new Date(date);
          nextWeek.setDate(date.getDate() + 7);
          return nextWeek.getMonth() !== date.getMonth();
        }
        const weekOfMonth = Math.floor((date.getDate() - 1) / 7) + 1;
        return weekOfMonth === metadata.monthly_week;
      }
      return false;
    default:
      return true;
  }
}
function extractProjectTitle(projectField) {
  if (!projectField) return void 0;
  const match = projectField.match(/\[\[([^\]]+)\]\]/);
  if (match) {
    return match[1];
  }
  return projectField;
}
function parseTimeString(timeStr, dateStr) {
  if (!timeStr) return void 0;
  const [hours, minutes, seconds] = timeStr.split(":").map(Number);
  const [year, month, day] = dateStr.split("-").map(Number);
  return new Date(year, month - 1, day, hours, minutes, seconds || 0);
}
function getScheduledSlotKey(scheduledTime) {
  if (!scheduledTime) return void 0;
  const [hourStr] = scheduledTime.split(":");
  const hour = parseInt(hourStr, 10);
  if (hour >= 0 && hour < 8) return "0:00-8:00";
  if (hour >= 8 && hour < 12) return "8:00-12:00";
  if (hour >= 12 && hour < 16) return "12:00-16:00";
  if (hour >= 16 && hour < 24) return "16:00-0:00";
  return void 0;
}
function isInstanceDeleted(instanceId, path, dateString) {
  const deletedKey = `taskchute-deleted-instances-${dateString}`;
  const deletedInstances = JSON.parse(localStorage.getItem(deletedKey) || "[]");
  return deletedInstances.some(
    (d) => d.instanceId === instanceId || d.path === path && !d.instanceId
  );
}
function isInstanceHidden(instanceId, path, dateString) {
  const hiddenKey = `taskchute-hidden-routines-${dateString}`;
  const hiddenRoutines = JSON.parse(localStorage.getItem(hiddenKey) || "[]");
  return hiddenRoutines.some(
    (h) => typeof h === "string" ? h === path : h.instanceId === instanceId || h.path === path
  );
}
async function shouldShowNonRoutineTask(file, metadata, dateString) {
  const deletedKey = `taskchute-deleted-instances-${dateString}`;
  const deletedInstances = JSON.parse(localStorage.getItem(deletedKey) || "[]");
  const isDeleted = deletedInstances.some(
    (d) => d.path === file.path
  );
  if (isDeleted) {
    return false;
  }
  if (metadata == null ? void 0 : metadata.target_date) {
    const shouldShow = metadata.target_date === dateString;
    return shouldShow;
  }
  try {
    const stats = await this.app.vault.adapter.stat(file.path);
    if (!stats) {
      return false;
    }
    const fileCreationDate = new Date(stats.ctime || stats.mtime);
    const year = fileCreationDate.getFullYear();
    const month = (fileCreationDate.getMonth() + 1).toString().padStart(2, "0");
    const day = fileCreationDate.getDate().toString().padStart(2, "0");
    const fileCreationDateString = `${year}-${month}-${day}`;
    if (dateString === fileCreationDateString) {
      return true;
    }
  } catch (error) {
    return false;
  }
  return false;
}

// src/managers/ProjectNoteSyncManager.ts
var import_obsidian6 = require("obsidian");
var ProjectNoteSyncManager = class {
  constructor(app, pathManager) {
    this.app = app;
    this.pathManager = pathManager;
  }
  // プロジェクトノートパスを取得
  async getProjectNotePath(inst) {
    var _a, _b;
    if (!((_a = inst == null ? void 0 : inst.task) == null ? void 0 : _a.projectPath) && !((_b = inst == null ? void 0 : inst.task) == null ? void 0 : _b.projectTitle)) return null;
    if (inst.task.projectPath) {
      return inst.task.projectPath;
    }
    const projectFolderPath = this.pathManager.getProjectFolderPath();
    const projectPath = `${projectFolderPath}/${inst.task.projectTitle}.md`;
    const file = this.app.vault.getAbstractFileByPath(projectPath);
    return file ? projectPath : null;
  }
  // ログセクションを検出または作成
  async ensureLogSection(content) {
    const logSectionRegex = /^#{1,2}\s+(ログ|log|Log|LOG)\s*$/im;
    const match = content.match(logSectionRegex);
    if (match && typeof match.index === "number") {
      return {
        exists: true,
        position: match.index + match[0].length,
        content
      };
    }
    const newContent = content.trimEnd() + "\n\n## \u30ED\u30B0\n";
    return {
      exists: false,
      position: newContent.length,
      content: newContent
    };
  }
  // コメントエントリをフォーマット
  formatCommentEntry(inst, completionData, dateString) {
    const wikilink = `[[${dateString}]]`;
    const comment = completionData.executionComment || "";
    const formattedComment = comment.split("\n").map((line) => `    - ${line}`).join("\n");
    return {
      date: dateString,
      entry: `- ${wikilink}
${formattedComment}`,
      instanceId: inst.instanceId
    };
  }
  // 既存ログをパースして構造化
  parseExistingLogs(content, logSectionPosition) {
    const lines = content.substring(logSectionPosition).split("\n");
    const logs = [];
    let currentDate = null;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const dateMatch = line.match(/^-\s+\[\[(\d{4}-\d{2}-\d{2})\]\]/);
      if (dateMatch) {
        currentDate = dateMatch[1];
        logs.push({ date: currentDate, lineIndex: i, entries: [] });
        continue;
      }
      if (currentDate && line.match(/^(\t|    )-\s+/)) {
        const log = logs[logs.length - 1];
        log.entries.push({ lineIndex: i, content: line });
      }
    }
    return logs;
  }
  // 既存日付の末尾の次の位置を求める
  findInsertPosition(content, existingDateLog, sectionPos) {
    const logContent = content.substring(sectionPos);
    const logLines = logContent.split("\n");
    const lastEntryLine = existingDateLog.lineIndex + existingDateLog.entries.length + 1;
    let relativePosition = 0;
    for (let i = 0; i < lastEntryLine && i < logLines.length; i++) {
      relativePosition += logLines[i].length + 1;
    }
    return sectionPos + relativePosition;
  }
  // 日付の挿入位置を検出（降順）
  findDateInsertPosition(content, logs, newDate, sectionPos) {
    if (logs.length === 0) return sectionPos + 1;
    for (let i = 0; i < logs.length; i++) {
      if (newDate > logs[i].date) {
        const logContent = content.substring(sectionPos);
        const logLines = logContent.split("\n");
        let relativePosition = 0;
        for (let j = 0; j < logs[i].lineIndex && j < logLines.length; j++) {
          relativePosition += logLines[j].length + 1;
        }
        return sectionPos + relativePosition;
      }
    }
    const lastLog = logs[logs.length - 1];
    return this.findInsertPosition(content, lastLog, sectionPos);
  }
  insertAtPosition(content, text, position) {
    return content.substring(0, position) + text + "\n" + content.substring(position);
  }
  formatDateString(date) {
    const y = date.getFullYear();
    const m = (date.getMonth() + 1).toString().padStart(2, "0");
    const d = date.getDate().toString().padStart(2, "0");
    return `${y}-${m}-${d}`;
  }
  // プロジェクトノートを更新
  async updateProjectNote(projectPath, inst, completionData) {
    const file = this.app.vault.getAbstractFileByPath(projectPath);
    if (!file || !(file instanceof import_obsidian6.TFile)) {
      throw new Error(`\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30CE\u30FC\u30C8\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093: ${projectPath}`);
    }
    let content = await this.app.vault.read(file);
    const sectionResult = await this.ensureLogSection(content);
    content = sectionResult.content;
    const taskDate = inst.startTime ? new Date(inst.startTime) : /* @__PURE__ */ new Date();
    const dateString = this.formatDateString(taskDate);
    const entry = this.formatCommentEntry(inst, completionData, dateString);
    const logs = this.parseExistingLogs(content, sectionResult.position);
    const existingDateLog = logs.find((l) => l.date === dateString);
    if (existingDateLog) {
      const insertPos = this.findInsertPosition(content, existingDateLog, sectionResult.position);
      const commentOnly = entry.entry.split("\n").slice(1).join("\n");
      content = this.insertAtPosition(content, commentOnly, insertPos);
    } else {
      const insertPos = this.findDateInsertPosition(content, logs, dateString, sectionResult.position);
      const entryWithSpacing = logs.length > 0 ? `${entry.entry}
` : entry.entry;
      content = this.insertAtPosition(content, entryWithSpacing, insertPos);
    }
    await this.app.vault.modify(file, content);
    return true;
  }
};

// src/views/TaskChuteView.ts
var NavigationStateManager = class {
  constructor() {
    this.selectedSection = null;
    this.isOpen = false;
  }
};
var TaskChuteView = class extends import_obsidian7.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.tasks = [];
    this.taskInstances = [];
    this.currentInstance = null;
    this.globalTimerInterval = null;
    this.logView = null;
    this.selectedTaskInstance = null;
    this.autocompleteInstances = [];
    // Boundary Check (idle-task-auto-move feature)
    this.boundaryCheckTimeout = null;
    // Debounce Timer
    this.renderDebounceTimer = null;
    // Task Name Validator
    this.TaskNameValidator = {
      INVALID_CHARS_PATTERN: /[:|\/\\#^]/g,
      validate(taskName) {
        const invalidChars = taskName.match(this.INVALID_CHARS_PATTERN);
        return {
          isValid: !invalidChars,
          invalidChars: invalidChars ? [...new Set(invalidChars)] : []
        };
      },
      getErrorMessage(invalidChars) {
        return `\u4F7F\u7528\u3067\u304D\u306A\u3044\u6587\u5B57\u304C\u542B\u307E\u308C\u3066\u3044\u307E\u3059: ${invalidChars.join(", ")}`;
      }
    };
    this.plugin = plugin;
    const today = /* @__PURE__ */ new Date();
    this.currentDate = new Date(
      today.getFullYear(),
      today.getMonth(),
      today.getDate()
    );
    this.useOrderBasedSort = localStorage.getItem("taskchute-use-order-sort") !== "false";
    this.navigationState = new NavigationStateManager();
  }
  getViewType() {
    return "taskchute-view";
  }
  getDisplayText() {
    return "TaskChute";
  }
  getIcon() {
    return "checkmark";
  }
  // ===========================================
  // Core Lifecycle Methods
  // ===========================================
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    this.scheduleBoundaryCheck();
    await this.setupUI(container);
    await this.loadTasks();
    await this.restoreRunningTaskState();
    this.applyStyles();
    this.setupResizeObserver();
    this.initializeNavigationEventListeners();
    this.setupEventListeners();
  }
  async onClose() {
    this.cleanupAutocompleteInstances();
    this.cleanupTimers();
  }
  // ===========================================
  // UI Setup Methods
  // ===========================================
  async setupUI(container) {
    const topBarContainer = container.createEl("div", {
      cls: "top-bar-container"
    });
    this.createDrawerToggle(topBarContainer);
    this.createDateNavigation(topBarContainer);
    this.createActionButtons(topBarContainer);
    const mainContainer = container.createEl("div", {
      cls: "taskchute-container"
    });
    const contentContainer = mainContainer.createEl("div", {
      cls: "main-container"
    });
    this.createNavigationUI(contentContainer);
    const taskListContainer = contentContainer.createEl("div", {
      cls: "task-list-container"
    });
    this.taskList = taskListContainer.createEl("div", { cls: "task-list" });
  }
  createDrawerToggle(topBarContainer) {
    const drawerToggle = topBarContainer.createEl("button", {
      cls: "drawer-toggle",
      attr: { title: "\u30CA\u30D3\u30B2\u30FC\u30B7\u30E7\u30F3\u3092\u958B\u304F" }
    });
    drawerToggle.createEl("span", {
      cls: "drawer-toggle-icon",
      text: "\u2630"
    });
  }
  createDateNavigation(topBarContainer) {
    const navContainer = topBarContainer.createEl("div", {
      cls: "date-nav-container compact"
    });
    const leftBtn = navContainer.createEl("button", {
      cls: "date-nav-arrow",
      text: "<"
    });
    const calendarBtn = navContainer.createEl("button", {
      cls: "calendar-btn",
      text: "\u{1F5D3}\uFE0F",
      attr: { title: "\u30AB\u30EC\u30F3\u30C0\u30FC\u3092\u958B\u304F" },
      style: "font-size:18px;padding:0 6px;background:none;border:none;cursor:pointer;"
    });
    const dateLabel = navContainer.createEl("span", { cls: "date-nav-label" });
    const rightBtn = navContainer.createEl("button", {
      cls: "date-nav-arrow",
      text: ">"
    });
    this.updateDateLabel(dateLabel);
    leftBtn.addEventListener("click", async () => {
      this.currentDate.setDate(this.currentDate.getDate() - 1);
      this.updateDateLabel(dateLabel);
      await this.loadTasks();
      await this.restoreRunningTaskState();
    });
    rightBtn.addEventListener("click", async () => {
      this.currentDate.setDate(this.currentDate.getDate() + 1);
      this.updateDateLabel(dateLabel);
      await this.loadTasks();
      await this.restoreRunningTaskState();
    });
    this.setupCalendarButton(calendarBtn, dateLabel);
    topBarContainer.createEl("div", {
      cls: "header-divider"
    });
  }
  createActionButtons(topBarContainer) {
    const actionSection = topBarContainer.createEl("div", {
      cls: "header-action-section"
    });
    const addTaskButton = actionSection.createEl("button", {
      cls: "add-task-button repositioned",
      text: "+",
      attr: { title: "\u65B0\u3057\u3044\u30BF\u30B9\u30AF\u3092\u8FFD\u52A0" }
    });
    const robotButton = actionSection.createEl("button", {
      cls: "robot-terminal-button",
      text: "\u{1F916}",
      attr: { title: "\u30BF\u30FC\u30DF\u30CA\u30EB\u3092\u958B\u304F" }
    });
    addTaskButton.addEventListener("click", () => this.showAddTaskModal());
    robotButton.addEventListener("click", async () => {
      try {
        await this.app.commands.executeCommandById(
          "terminal:open-terminal.integrated.root"
        );
      } catch (error) {
        new import_obsidian7.Notice("\u30BF\u30FC\u30DF\u30CA\u30EB\u3092\u958B\u3051\u307E\u305B\u3093\u3067\u3057\u305F: " + error.message);
      }
    });
  }
  createNavigationUI(contentContainer) {
    this.navigationOverlay = contentContainer.createEl("div", {
      cls: "navigation-overlay navigation-overlay-hidden"
    });
    this.navigationPanel = contentContainer.createEl("div", {
      cls: "navigation-panel navigation-panel-hidden"
    });
    const navMenu = this.navigationPanel.createEl("nav", {
      cls: "navigation-nav"
    });
    const navigationItems = [
      { key: "routine", label: "\u30EB\u30FC\u30C1\u30F3", icon: "\u{1F504}" },
      { key: "review", label: "\u30EC\u30D3\u30E5\u30FC", icon: "\u{1F4CB}" },
      { key: "log", label: "\u30ED\u30B0", icon: "\u{1F4CA}" },
      { key: "project", label: "\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8", icon: "\u{1F4C1}" }
    ];
    navigationItems.forEach((item) => {
      const navItem = navMenu.createEl("div", {
        cls: "navigation-nav-item",
        attr: { "data-section": item.key }
      });
      navItem.createEl("span", {
        cls: "navigation-nav-icon",
        text: item.icon
      });
      navItem.createEl("span", {
        cls: "navigation-nav-label",
        text: item.label
      });
      navItem.addEventListener("click", () => {
        this.handleNavigationItemClick(item.key);
      });
    });
  }
  // ===========================================
  // Date Management Methods
  // ===========================================
  updateDateLabel(label) {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const current = new Date(this.currentDate);
    current.setHours(0, 0, 0, 0);
    const isToday = current.getTime() === today.getTime();
    const dayName = current.toLocaleDateString("ja-JP", { weekday: "short" });
    const dateStr = `${this.currentDate.getMonth() + 1}/${this.currentDate.getDate()}`;
    label.textContent = isToday ? `\u4ECA\u65E5 (${dateStr} ${dayName})` : `${dateStr} ${dayName}`;
  }
  getCurrentDateString() {
    const y = this.currentDate.getFullYear();
    const m = (this.currentDate.getMonth() + 1).toString().padStart(2, "0");
    const d = this.currentDate.getDate().toString().padStart(2, "0");
    return `${y}-${m}-${d}`;
  }
  setupCalendarButton(calendarBtn, dateLabel) {
    calendarBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      const oldInput = document.getElementById("calendar-date-input");
      if (oldInput) oldInput.remove();
      const input = document.createElement("input");
      input.type = "date";
      input.id = "calendar-date-input";
      input.classList.add("taskchute-input-absolute");
      input.style.left = `${calendarBtn.getBoundingClientRect().left}px`;
      input.style.top = `${calendarBtn.getBoundingClientRect().top - 900}px`;
      input.style.zIndex = "10000";
      const y = this.currentDate.getFullYear();
      const m = (this.currentDate.getMonth() + 1).toString().padStart(2, "0");
      const d = this.currentDate.getDate().toString().padStart(2, "0");
      input.value = `${y}-${m}-${d}`;
      document.body.appendChild(input);
      setTimeout(() => {
        try {
          input.focus();
          input.click();
          if (input.showPicker && typeof input.showPicker === "function") {
            input.showPicker();
          } else {
            const mouseEvent = new MouseEvent("mousedown", {
              view: window,
              bubbles: true,
              cancelable: true
            });
            input.dispatchEvent(mouseEvent);
          }
        } catch (e2) {
        }
      }, 50);
      input.addEventListener("change", async () => {
        const [yy, mm, dd] = input.value.split("-").map(Number);
        this.currentDate = new Date(yy, mm - 1, dd);
        this.updateDateLabel(dateLabel);
        await this.loadTasks();
        await this.restoreRunningTaskState();
        input.remove();
      });
      input.addEventListener("blur", () => input.remove());
    });
  }
  // ===========================================
  // Task Loading and Rendering Methods
  // ===========================================
  async loadTasks() {
    await loadTasksRefactored.call(this);
  }
  async processTaskFile(file) {
    var _a;
    try {
      const content = await this.app.vault.read(file);
      const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      if (!content.includes("#task") && !(frontmatter == null ? void 0 : frontmatter.estimatedMinutes)) {
        return;
      }
      const taskData = {
        file,
        frontmatter: frontmatter || {},
        path: file.path,
        name: file.basename,
        project: frontmatter == null ? void 0 : frontmatter.project,
        isRoutine: (frontmatter == null ? void 0 : frontmatter.isRoutine) || content.includes("#routine"),
        routine_type: frontmatter == null ? void 0 : frontmatter.routine_type,
        routine_start: frontmatter == null ? void 0 : frontmatter.routine_start,
        routine_end: frontmatter == null ? void 0 : frontmatter.routine_end,
        routine_week: frontmatter == null ? void 0 : frontmatter.routine_week,
        routine_day: frontmatter == null ? void 0 : frontmatter.routine_day,
        flexible_schedule: frontmatter == null ? void 0 : frontmatter.flexible_schedule
      };
      this.tasks.push(taskData);
    } catch (error) {
      console.error(`Failed to process task file ${file.path}:`, error);
    }
  }
  async loadTaskInstances() {
    const dateStr = this.getCurrentDateString();
    for (const task of this.tasks) {
      if (!this.shouldShowTaskForDate(task, this.currentDate)) {
        continue;
      }
      const instance = {
        task,
        instanceId: this.generateInstanceId(task, dateStr),
        state: "idle",
        slotKey: this.getTaskSlotKey(task),
        date: dateStr
      };
      if (this.isInstanceDeleted(instance.instanceId, task.path, dateStr) || this.isInstanceHidden(instance.instanceId, task.path, dateStr)) {
        continue;
      }
      this.loadInstanceState(instance, dateStr);
      this.taskInstances.push(instance);
    }
  }
  shouldShowTaskForDate(task, date) {
    if (!task.isRoutine) {
      return true;
    }
    const dayOfWeek = date.getDay();
    switch (task.routine_type) {
      case "daily":
        return true;
      case "weekdays":
        return dayOfWeek >= 1 && dayOfWeek <= 5;
      // Monday to Friday
      case "weekends":
        return dayOfWeek === 0 || dayOfWeek === 6;
      // Saturday and Sunday
      case "weekly":
        return true;
      // Simplified for now
      case "monthly":
        return true;
      // Simplified for now
      default:
        return true;
    }
  }
  generateInstanceId(task, dateStr) {
    return `${task.path}_${dateStr}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  getTaskSlotKey(task) {
    const storedSlot = localStorage.getItem(`taskchute-slotkey-${task.path}`);
    if (storedSlot) {
      return storedSlot;
    }
    return "none";
  }
  loadInstanceState(instance, dateStr) {
    const stateKey = `taskchute-instance-state-${instance.instanceId}`;
    const savedState = localStorage.getItem(stateKey);
    if (savedState) {
      try {
        const parsed = JSON.parse(savedState);
        instance.state = parsed.state || "idle";
        instance.startTime = parsed.startTime ? new Date(parsed.startTime) : void 0;
        instance.stopTime = parsed.stopTime ? new Date(parsed.stopTime) : void 0;
        instance.pausedDuration = parsed.pausedDuration || 0;
        instance.actualMinutes = parsed.actualMinutes;
        instance.comment = parsed.comment;
        instance.focusLevel = parsed.focusLevel;
        instance.energyLevel = parsed.energyLevel;
      } catch (error) {
        console.error("Failed to parse instance state:", error);
      }
    }
  }
  // ===========================================
  // Task Rendering Methods
  // ===========================================
  renderTaskList() {
    const scrollTop = this.taskList.scrollTop;
    const scrollLeft = this.taskList.scrollLeft;
    this.applyResponsiveClasses();
    this.sortTaskInstancesByTimeOrder();
    this.taskList.empty();
    const timeSlots = {};
    this.getTimeSlotKeys().forEach((slot) => {
      timeSlots[slot] = [];
    });
    let noTimeInstances = [];
    this.taskInstances.forEach((inst) => {
      if (inst.slotKey && inst.slotKey !== "none") {
        if (!timeSlots[inst.slotKey]) {
          timeSlots[inst.slotKey] = [];
        }
        timeSlots[inst.slotKey].push(inst);
      } else {
        noTimeInstances.push(inst);
      }
    });
    this.renderNoTimeGroup(noTimeInstances);
    this.getTimeSlotKeys().forEach((slot) => {
      const instancesInSlot = timeSlots[slot];
      this.renderTimeSlotGroup(slot, instancesInSlot);
    });
    this.taskList.scrollTop = scrollTop;
    this.taskList.scrollLeft = scrollLeft;
    this.updateTotalTasksCount();
  }
  renderNoTimeGroup(instances) {
    const noTimeHeader = this.taskList.createEl("div", {
      cls: "time-slot-header other",
      text: "\u6642\u9593\u6307\u5B9A\u306A\u3057"
    });
    this.setupTimeSlotDragHandlers(noTimeHeader, "none");
    const sortedInstances = this.sortByOrder(instances);
    sortedInstances.forEach((inst, idx) => {
      this.createTaskInstanceItem(inst, "none", idx);
    });
  }
  renderTimeSlotGroup(slot, instances) {
    const timeSlotHeader = this.taskList.createEl("div", {
      cls: "time-slot-header",
      text: slot
    });
    this.setupTimeSlotDragHandlers(timeSlotHeader, slot);
    const sortedInstances = this.sortByOrder(instances);
    sortedInstances.forEach((inst, idx) => {
      this.createTaskInstanceItem(inst, slot, idx);
    });
  }
  createTaskInstanceItem(inst, slot, idx) {
    const taskItem = this.taskList.createEl("div", { cls: "task-item" });
    if (inst.task.path) {
      taskItem.setAttribute("data-task-path", inst.task.path);
    }
    taskItem.setAttribute("data-slot", slot || "none");
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const viewDate = new Date(this.currentDate);
    viewDate.setHours(0, 0, 0, 0);
    const isFutureTask = viewDate > today;
    if (inst.state === "done") {
      taskItem.classList.add("completed");
    }
    this.createDragHandle(taskItem, inst, slot, idx);
    this.createPlayStopButton(taskItem, inst, isFutureTask);
    this.createTaskName(taskItem, inst);
    this.createProjectDisplay(taskItem, inst);
    this.createTimeRangeDisplay(taskItem, inst);
    this.createDurationTimerDisplay(taskItem, inst);
    this.createCommentButton(taskItem, inst);
    this.createRoutineButton(taskItem, inst);
    this.createSettingsButton(taskItem, inst);
    this.setupTaskItemEventListeners(taskItem, inst);
  }
  createDragHandle(taskItem, inst, slot, idx) {
    const isDraggable = inst.state !== "done";
    const dragHandle = taskItem.createEl("div", {
      cls: "drag-handle",
      attr: isDraggable ? { draggable: "true", title: "\u30C9\u30E9\u30C3\u30B0\u3057\u3066\u79FB\u52D5" } : { title: "\u5B8C\u4E86\u6E08\u307F\u30BF\u30B9\u30AF" }
    });
    if (!isDraggable) {
      dragHandle.classList.add("disabled");
    }
    const svg = dragHandle.createSvg("svg", {
      attr: {
        width: "10",
        height: "16",
        viewBox: "0 0 10 16",
        fill: "currentColor"
      }
    });
    svg.createSvg("circle", { attr: { cx: "2", cy: "2", r: "1.5" } });
    svg.createSvg("circle", { attr: { cx: "8", cy: "2", r: "1.5" } });
    svg.createSvg("circle", { attr: { cx: "2", cy: "8", r: "1.5" } });
    svg.createSvg("circle", { attr: { cx: "8", cy: "8", r: "1.5" } });
    svg.createSvg("circle", { attr: { cx: "2", cy: "14", r: "1.5" } });
    svg.createSvg("circle", { attr: { cx: "8", cy: "14", r: "1.5" } });
    if (isDraggable) {
      this.setupDragEvents(dragHandle, taskItem, slot, idx);
    }
    dragHandle.addEventListener("click", (e) => {
      e.stopPropagation();
      this.selectTaskForKeyboard(inst, taskItem);
    });
  }
  createPlayStopButton(taskItem, inst, isFutureTask) {
    let btnCls = "play-stop-button";
    let btnText = "\u25B6\uFE0F";
    let btnTitle = "\u30B9\u30BF\u30FC\u30C8";
    if (isFutureTask) {
      btnCls += " future-task-button";
      btnText = "\u2014";
      btnTitle = "\u672A\u6765\u306E\u30BF\u30B9\u30AF\u306F\u5B9F\u884C\u3067\u304D\u307E\u305B\u3093";
    } else if (inst.state === "running") {
      btnCls += " stop";
      btnText = "\u23F9";
      btnTitle = "\u30B9\u30C8\u30C3\u30D7";
    } else if (inst.state === "done") {
      btnText = "\u2611\uFE0F";
      btnTitle = "\u5B8C\u4E86\u30BF\u30B9\u30AF\u3092\u518D\u8A08\u6E2C";
    }
    const playButton = taskItem.createEl("button", {
      cls: btnCls,
      text: btnText,
      attr: { title: btnTitle }
    });
    if (isFutureTask) {
      playButton.disabled = true;
    }
    playButton.addEventListener("click", async (e) => {
      e.stopPropagation();
      if (isFutureTask) {
        new import_obsidian7.Notice("\u672A\u6765\u306E\u30BF\u30B9\u30AF\u306F\u5B9F\u884C\u3067\u304D\u307E\u305B\u3093\u3002", 2e3);
        return;
      }
      if (inst.state === "running") {
        await this.stopInstance(inst);
      } else if (inst.state === "idle") {
        await this.startInstance(inst);
      } else if (inst.state === "done") {
        await this.duplicateAndStartInstance(inst);
      }
    });
  }
  createTaskName(taskItem, inst) {
    const taskName = taskItem.createEl("span", {
      cls: "task-name",
      text: inst.task.name
    });
    taskName.style.color = "var(--text-accent)";
    taskName.addEventListener("click", async (e) => {
      e.stopPropagation();
      try {
        await this.app.workspace.openLinkText(inst.task.path, "", false);
      } catch (error) {
        new import_obsidian7.Notice("\u30BF\u30B9\u30AF\u30D5\u30A1\u30A4\u30EB\u3092\u958B\u3051\u307E\u305B\u3093\u3067\u3057\u305F");
      }
    });
  }
  createProjectDisplay(taskItem, inst) {
    const projectDisplay = taskItem.createEl("span", {
      cls: "taskchute-project-display"
    });
    if (inst.task.projectPath && inst.task.projectTitle) {
      const projectButton = projectDisplay.createEl("span", {
        cls: "taskchute-project-button",
        attr: {
          title: `\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8: ${inst.task.projectTitle}`
        }
      });
      const folderIcon = projectButton.createEl("span", {
        cls: "taskchute-project-icon",
        text: "\u{1F4C1}"
      });
      const projectName = projectButton.createEl("span", {
        cls: "taskchute-project-name",
        text: inst.task.projectTitle.replace(/^Project\s*-\s*/, "")
      });
      projectButton.addEventListener("click", async (e) => {
        e.stopPropagation();
        await this.showUnifiedProjectModal(inst);
      });
      const externalLinkIcon = projectDisplay.createEl("span", {
        cls: "taskchute-external-link",
        text: "\u{1F517}",
        attr: { title: "\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30CE\u30FC\u30C8\u3092\u958B\u304F" }
      });
      externalLinkIcon.addEventListener("click", async (e) => {
        e.stopPropagation();
        await this.openProjectInSplit(inst.task.projectPath);
      });
    } else {
      const projectPlaceholder = projectDisplay.createEl("span", {
        cls: "taskchute-project-placeholder",
        attr: { title: "\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3092\u8A2D\u5B9A" }
      });
      projectPlaceholder.addEventListener("click", async (e) => {
        e.stopPropagation();
        await this.showProjectModal(inst);
      });
    }
  }
  createTimeRangeDisplay(taskItem, inst) {
    const timeRangeEl = taskItem.createEl("span", {
      cls: "task-time-range"
    });
    const formatTime = (date) => date ? date.toLocaleTimeString("ja-JP", {
      hour: "2-digit",
      minute: "2-digit"
    }) : "";
    if (inst.state === "running" && inst.startTime) {
      timeRangeEl.textContent = `${formatTime(inst.startTime)} \u2192`;
    } else if (inst.state === "done" && inst.startTime && inst.stopTime) {
      timeRangeEl.textContent = `${formatTime(inst.startTime)} \u2192 ${formatTime(inst.stopTime)}`;
    } else {
      timeRangeEl.textContent = "";
    }
  }
  createDurationTimerDisplay(taskItem, inst) {
    if (inst.state === "done" && inst.startTime && inst.stopTime) {
      const durationEl = taskItem.createEl("span", {
        cls: "task-duration"
      });
      const duration = this.calculateCrossDayDuration(inst.startTime, inst.stopTime);
      const hours = Math.floor(duration / 36e5);
      const minutes = Math.floor(duration % 36e5 / 6e4) % 60;
      const durationStr = `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}`;
      durationEl.textContent = durationStr;
      if (inst.startTime.getDate() !== inst.stopTime.getDate()) {
        durationEl.setAttribute("title", "\u65E5\u3092\u8DE8\u3044\u3060\u30BF\u30B9\u30AF");
      }
    } else if (inst.state === "running") {
      const timerEl = taskItem.createEl("span", {
        cls: "task-timer-display"
      });
      this.updateTimerDisplay(timerEl, inst);
    } else {
      taskItem.createEl("span", {
        cls: "task-duration-placeholder"
      });
    }
  }
  createCommentButton(taskItem, inst) {
    const commentButton = taskItem.createEl("button", {
      cls: "comment-button",
      text: "\u{1F4AC}",
      attr: {
        "data-task-state": inst.state
      }
    });
    if (inst.state !== "done") {
      commentButton.classList.add("disabled");
      commentButton.setAttribute("disabled", "true");
    }
    commentButton.addEventListener("click", async (e) => {
      e.stopPropagation();
      if (inst.state !== "done") {
        return;
      }
      await this.showTaskCompletionModal(inst);
    });
    this.hasCommentData(inst).then((hasComment) => {
      if (hasComment) {
        commentButton.classList.add("active");
      } else {
        commentButton.classList.remove("active");
        if (inst.state === "done") {
          commentButton.classList.add("no-comment");
        }
      }
    });
  }
  createRoutineButton(taskItem, inst) {
    const routineButton = taskItem.createEl("button", {
      cls: `routine-button ${inst.task.isRoutine ? "active" : ""}`,
      text: "\u{1F504}",
      attr: {
        title: inst.task.isRoutine ? `\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF` : "\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306B\u8A2D\u5B9A"
      }
    });
    routineButton.addEventListener("click", (e) => {
      e.stopPropagation();
      if (inst.task.isRoutine) {
        this.showRoutineEditModal(inst.task, routineButton);
      } else {
        this.toggleRoutine(inst.task, routineButton);
      }
    });
  }
  createSettingsButton(taskItem, inst) {
    const settingsButton = taskItem.createEl("button", {
      cls: "settings-task-button",
      text: "\u2699\uFE0F",
      attr: { title: "\u30BF\u30B9\u30AF\u8A2D\u5B9A" }
    });
    settingsButton.addEventListener("click", (e) => {
      e.stopPropagation();
      this.showTaskSettingsTooltip(inst, settingsButton);
    });
  }
  // ===========================================
  // Missing Method Placeholders
  // ===========================================
  async duplicateAndStartInstance(inst) {
    await this.duplicateInstance(inst);
  }
  async duplicateInstance(inst) {
    try {
      const newInstance = {
        ...inst,
        instanceId: this.generateInstanceId(inst.task.path),
        state: "idle",
        startTime: void 0,
        stopTime: void 0
      };
      this.taskInstances.push(newInstance);
      this.saveInstanceState(newInstance);
      this.renderTaskList();
      new import_obsidian7.Notice(`\u300C${inst.task.title}\u300D\u3092\u8907\u88FD\u3057\u307E\u3057\u305F`);
    } catch (error) {
      console.error("Failed to duplicate instance:", error);
      new import_obsidian7.Notice("\u30BF\u30B9\u30AF\u306E\u8907\u88FD\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  async showTaskCompletionModal(inst) {
    const existingComment = await this.getExistingTaskComment(inst);
    const modal = document.createElement("div");
    modal.className = "taskchute-comment-modal";
    const modalContent = modal.createEl("div", {
      cls: "taskchute-comment-content"
    });
    const header = modalContent.createEl("div", { cls: "taskchute-modal-header" });
    const headerText = existingComment ? `\u270F\uFE0F \u300C${inst.task.title}\u300D\u306E\u30B3\u30E1\u30F3\u30C8\u3092\u7DE8\u96C6` : `\u{1F389} \u304A\u75B2\u308C\u69D8\u3067\u3057\u305F\uFF01\u300C${inst.task.title}\u300D\u304C\u5B8C\u4E86\u3057\u307E\u3057\u305F`;
    header.createEl("h2", { text: headerText });
    if (inst.state === "done" && inst.actualTime) {
      const timeInfo = modalContent.createEl("div", { cls: "taskchute-time-info" });
      const duration = this.formatTime(inst.actualTime);
      const startTime = inst.startTime ? new Date(inst.startTime).toLocaleTimeString("ja-JP", { hour: "2-digit", minute: "2-digit" }) : "";
      const endTime = inst.stopTime ? new Date(inst.stopTime).toLocaleTimeString("ja-JP", { hour: "2-digit", minute: "2-digit" }) : "";
      timeInfo.createEl("div", {
        text: `\u5B9F\u884C\u6642\u9593: ${duration}`,
        cls: "time-duration"
      });
      if (startTime && endTime) {
        timeInfo.createEl("div", {
          text: `\u958B\u59CB: ${startTime} \u7D42\u4E86: ${endTime}`,
          cls: "time-range"
        });
      }
    }
    const ratingSection = modalContent.createEl("div", { cls: "taskchute-rating-section" });
    ratingSection.createEl("h3", { text: "\u4ECA\u56DE\u306E\u30BF\u30B9\u30AF\u306F\u3044\u304B\u304C\u3067\u3057\u305F\u304B\uFF1F" });
    const focusGroup = ratingSection.createEl("div", { cls: "rating-group" });
    focusGroup.createEl("label", { text: "\u96C6\u4E2D\u5EA6:", cls: "rating-label" });
    const initialFocusRating = (existingComment == null ? void 0 : existingComment.focusLevel) || 0;
    const focusRating = focusGroup.createEl("div", {
      cls: "star-rating",
      attr: { "data-rating": initialFocusRating.toString() }
    });
    for (let i = 1; i <= 5; i++) {
      const star = focusRating.createEl("span", {
        cls: `star ${i <= initialFocusRating ? "taskchute-star-filled" : "taskchute-star-empty"}`,
        text: "\u2B50"
      });
      star.addEventListener("click", () => {
        this.setRating(focusRating, i);
      });
      star.addEventListener("mouseenter", () => {
        this.highlightRating(focusRating, i);
      });
      star.addEventListener("mouseleave", () => {
        this.resetRatingHighlight(focusRating);
      });
    }
    this.updateRatingDisplay(focusRating, initialFocusRating);
    const energyGroup = ratingSection.createEl("div", { cls: "rating-group" });
    energyGroup.createEl("label", { text: "\u5143\u6C17\u5EA6:", cls: "rating-label" });
    const initialEnergyRating = (existingComment == null ? void 0 : existingComment.energyLevel) || 0;
    const energyRating = energyGroup.createEl("div", {
      cls: "star-rating",
      attr: { "data-rating": initialEnergyRating.toString() }
    });
    for (let i = 1; i <= 5; i++) {
      const star = energyRating.createEl("span", {
        cls: `star ${i <= initialEnergyRating ? "taskchute-star-filled" : "taskchute-star-empty"}`,
        text: "\u2B50"
      });
      star.addEventListener("click", () => {
        this.setRating(energyRating, i);
      });
      star.addEventListener("mouseenter", () => {
        this.highlightRating(energyRating, i);
      });
      star.addEventListener("mouseleave", () => {
        this.resetRatingHighlight(energyRating);
      });
    }
    this.updateRatingDisplay(energyRating, initialEnergyRating);
    const commentSection = modalContent.createEl("div", { cls: "taskchute-comment-section" });
    commentSection.createEl("label", { text: "\u611F\u60F3\u30FB\u5B66\u3073\u30FB\u6B21\u56DE\u3078\u306E\u6539\u5584\u70B9:", cls: "comment-label" });
    const commentInput = commentSection.createEl("textarea", {
      cls: "taskchute-comment-textarea",
      placeholder: "\u4ECA\u56DE\u306E\u30BF\u30B9\u30AF\u3067\u611F\u3058\u305F\u3053\u3068\u3001\u5B66\u3093\u3060\u3053\u3068\u3001\u6B21\u56DE\u3078\u306E\u6539\u5584\u70B9\u306A\u3069\u3092\u81EA\u7531\u306B\u304A\u66F8\u304D\u304F\u3060\u3055\u3044..."
    });
    if (existingComment == null ? void 0 : existingComment.executionComment) {
      commentInput.value = existingComment.executionComment;
    }
    const buttonGroup = modalContent.createEl("div", { cls: "taskchute-comment-actions" });
    const cancelButton = buttonGroup.createEl("button", {
      type: "button",
      cls: "taskchute-button-cancel",
      text: "\u30AD\u30E3\u30F3\u30BB\u30EB"
    });
    const saveButton = buttonGroup.createEl("button", {
      type: "button",
      cls: "taskchute-button-save",
      text: "\u4FDD\u5B58"
    });
    const closeModal = () => {
      document.body.removeChild(modal);
    };
    const handleEsc = (e) => {
      if (e.key === "Escape") {
        closeModal();
        document.removeEventListener("keydown", handleEsc);
      }
    };
    document.addEventListener("keydown", handleEsc);
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        closeModal();
      }
    });
    cancelButton.addEventListener("click", closeModal);
    saveButton.addEventListener("click", async () => {
      const focusValue = parseInt(focusRating.getAttribute("data-rating") || "0");
      const energyValue = parseInt(energyRating.getAttribute("data-rating") || "0");
      await this.saveTaskComment(inst, {
        comment: commentInput.value,
        energy: energyValue,
        focus: focusValue,
        focusLevel: focusValue,
        // 新形式との互換性
        energyLevel: energyValue,
        // 新形式との互換性
        executionComment: commentInput.value,
        // 新形式との互換性
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
      closeModal();
      this.renderTaskList();
    });
    document.body.appendChild(modal);
    commentInput.focus();
  }
  // 星評価ヘルパー関数
  setRating(ratingEl, value) {
    ratingEl.setAttribute("data-rating", value.toString());
    this.updateRatingDisplay(ratingEl, value);
  }
  highlightRating(ratingEl, value) {
    this.updateRatingDisplay(ratingEl, value);
  }
  resetRatingHighlight(ratingEl) {
    const currentRating = parseInt(ratingEl.getAttribute("data-rating") || "0");
    this.updateRatingDisplay(ratingEl, currentRating);
  }
  updateRatingDisplay(ratingEl, value) {
    const stars = ratingEl.querySelectorAll(".star");
    stars.forEach((star, index) => {
      if (index < value) {
        star.classList.add("taskchute-star-filled");
        star.classList.remove("taskchute-star-empty");
      } else {
        star.classList.add("taskchute-star-empty");
        star.classList.remove("taskchute-star-filled");
      }
    });
  }
  // 10段階を5段階に変換
  convertToFiveScale(value) {
    if (value === 0) return 0;
    if (value > 5) return Math.ceil(value / 2);
    return value;
  }
  async hasCommentData(inst) {
    try {
      const existingComment = await this.getExistingTaskComment(inst);
      if (!existingComment) {
        return false;
      }
      return existingComment.executionComment && existingComment.executionComment.trim().length > 0 || existingComment.focusLevel > 0 || existingComment.energyLevel > 0;
    } catch (error) {
      return false;
    }
  }
  async getExistingTaskComment(inst) {
    var _a;
    try {
      if (!inst.instanceId) {
        return null;
      }
      const currentDate = this.currentDate;
      const year = currentDate.getFullYear();
      const month = (currentDate.getMonth() + 1).toString().padStart(2, "0");
      const day = currentDate.getDate().toString().padStart(2, "0");
      const monthString = `${year}-${month}`;
      const logDataPath = this.plugin.pathManager.getLogDataPath();
      const logFilePath = `${logDataPath}/${monthString}-tasks.json`;
      const logFile = this.app.vault.getAbstractFileByPath(logFilePath);
      if (!logFile || !(logFile instanceof import_obsidian7.TFile)) {
        return null;
      }
      const logContent = await this.app.vault.read(logFile);
      const monthlyLog = JSON.parse(logContent);
      const dateString = `${year}-${month}-${day}`;
      const todayTasks = ((_a = monthlyLog.taskExecutions) == null ? void 0 : _a[dateString]) || [];
      const existingEntry = todayTasks.find(
        (entry) => entry.instanceId === inst.instanceId
      );
      return existingEntry || null;
    } catch (error) {
      return null;
    }
  }
  async saveTaskComment(inst, data) {
    var _a, _b, _c, _d, _e, _f;
    try {
      if (!inst.instanceId) {
        throw new Error("instanceId is required");
      }
      const currentDate = this.currentDate;
      const year = currentDate.getFullYear();
      const month = (currentDate.getMonth() + 1).toString().padStart(2, "0");
      const day = currentDate.getDate().toString().padStart(2, "0");
      const monthString = `${year}-${month}`;
      const logDataPath = this.plugin.pathManager.getLogDataPath();
      const logFilePath = `${logDataPath}/${monthString}-tasks.json`;
      const dateString = `${year}-${month}-${day}`;
      const logFile = this.app.vault.getAbstractFileByPath(logFilePath);
      let monthlyLog = { taskExecutions: {} };
      if (logFile && logFile instanceof import_obsidian7.TFile) {
        const logContent = await this.app.vault.read(logFile);
        monthlyLog = JSON.parse(logContent);
      }
      if (!monthlyLog.taskExecutions) {
        monthlyLog.taskExecutions = {};
      }
      if (!monthlyLog.taskExecutions[dateString]) {
        monthlyLog.taskExecutions[dateString] = [];
      }
      const todayTasks = monthlyLog.taskExecutions[dateString];
      const existingIndex = todayTasks.findIndex(
        (entry) => entry.instanceId === inst.instanceId
      );
      const existingTaskData = existingIndex >= 0 ? { ...todayTasks[existingIndex] } : null;
      const pad = (n) => String(n).padStart(2, "0");
      const toHMS = (d) => d ? `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}` : "";
      const durationSec = inst.startTime && inst.stopTime ? Math.floor(this.calculateCrossDayDuration(inst.startTime, inst.stopTime) / 1e3) : 0;
      const commentData = {
        instanceId: inst.instanceId,
        taskPath: ((_a = inst.task) == null ? void 0 : _a.path) || "",
        taskName: ((_b = inst.task) == null ? void 0 : _b.name) || "",
        startTime: toHMS(inst.startTime),
        stopTime: toHMS(inst.stopTime),
        duration: durationSec,
        executionComment: (data.comment || "").trim(),
        focusLevel: data.focus || 0,
        energyLevel: data.energy || 0,
        isCompleted: inst.state === "done",
        project_path: ((_c = inst.task) == null ? void 0 : _c.projectPath) || null,
        project: ((_d = inst.task) == null ? void 0 : _d.projectTitle) ? `[[${inst.task.projectTitle}]]` : null,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
      if (existingIndex >= 0) {
        todayTasks[existingIndex] = {
          ...todayTasks[existingIndex],
          // 変化しうるフィールドのみ更新
          executionComment: commentData.executionComment,
          focusLevel: commentData.focusLevel,
          energyLevel: commentData.energyLevel,
          startTime: commentData.startTime || todayTasks[existingIndex].startTime,
          stopTime: commentData.stopTime || todayTasks[existingIndex].stopTime,
          duration: durationSec || todayTasks[existingIndex].duration,
          isCompleted: commentData.isCompleted,
          project_path: (_e = commentData.project_path) != null ? _e : todayTasks[existingIndex].project_path,
          project: (_f = commentData.project) != null ? _f : todayTasks[existingIndex].project,
          lastCommentUpdate: (/* @__PURE__ */ new Date()).toISOString(),
          timestamp: commentData.timestamp
        };
      } else {
        todayTasks.push(commentData);
      }
      if (logFile && logFile instanceof import_obsidian7.TFile) {
        await this.app.vault.modify(logFile, JSON.stringify(monthlyLog, null, 2));
      } else {
        await this.app.vault.create(logFilePath, JSON.stringify(monthlyLog, null, 2));
      }
      const completionData = {
        executionComment: (data.comment || "").trim(),
        focusLevel: data.focus,
        energyLevel: data.energy
      };
      if (completionData.executionComment && (inst.task.projectPath || inst.task.projectTitle) && this.hasCommentChanged(existingTaskData, completionData)) {
        await this.syncCommentToProjectNote(inst, completionData);
      }
      new import_obsidian7.Notice("\u30B3\u30E1\u30F3\u30C8\u3092\u4FDD\u5B58\u3057\u307E\u3057\u305F");
    } catch (error) {
      console.error("Failed to save comment:", error);
      new import_obsidian7.Notice("\u30B3\u30E1\u30F3\u30C8\u306E\u4FDD\u5B58\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  // コメント本文の変更検出
  hasCommentChanged(oldData, newData) {
    var _a, _b;
    const oldComment = (_a = oldData == null ? void 0 : oldData.executionComment) != null ? _a : "";
    const newComment = (_b = newData == null ? void 0 : newData.executionComment) != null ? _b : "";
    return oldComment !== newComment;
  }
  // プロジェクトノートにコメントを同期
  async syncCommentToProjectNote(inst, completionData) {
    try {
      const syncManager = new ProjectNoteSyncManager(this.app, this.plugin.pathManager);
      const projectPath = await syncManager.getProjectNotePath(inst);
      if (!projectPath) return;
      await syncManager.updateProjectNote(projectPath, inst, completionData);
    } catch (error) {
      new import_obsidian7.Notice(`\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30CE\u30FC\u30C8\u306E\u66F4\u65B0\u306B\u5931\u6557\u3057\u307E\u3057\u305F: ${error.message || error}`);
    }
  }
  showRoutineEditModal(task, button) {
    const modal = document.createElement("div");
    modal.className = "task-modal-overlay";
    const modalContent = modal.createEl("div", { cls: "task-modal-content" });
    const modalHeader = modalContent.createEl("div", { cls: "modal-header" });
    modalHeader.createEl("h3", { text: `\u300C${task.title}\u300D\u306E\u30EB\u30FC\u30C1\u30F3\u8A2D\u5B9A` });
    const closeButton = modalHeader.createEl("button", {
      cls: "modal-close-button",
      text: "\xD7",
      attr: { title: "\u9589\u3058\u308B" }
    });
    const form = modalContent.createEl("form", { cls: "task-form" });
    const typeGroup = form.createEl("div", { cls: "form-group" });
    typeGroup.createEl("label", { text: "\u30EB\u30FC\u30C1\u30F3\u30BF\u30A4\u30D7:", cls: "form-label" });
    const typeSelect = typeGroup.createEl("select", {
      cls: "form-input"
    });
    const options = [
      { value: "daily", text: "\u6BCE\u65E5" },
      { value: "weekdays", text: "\u5E73\u65E5\u306E\u307F" },
      { value: "weekends", text: "\u9031\u672B\u306E\u307F" },
      { value: "weekly", text: "\u9031\u6B21\uFF08\u66DC\u65E5\u6307\u5B9A\uFF09" },
      { value: "monthly", text: "\u6708\u6B21\uFF08\u7B2CX\u9031\u306EX\u66DC\u65E5\uFF09" }
    ];
    options.forEach((opt) => {
      const option = typeSelect.createEl("option", {
        value: opt.value,
        text: opt.text
      });
      if (task.routine_type === opt.value) {
        option.selected = true;
      }
    });
    if (!task.routine_type) {
      typeSelect.value = "daily";
    }
    const timeGroup = form.createEl("div", { cls: "form-group" });
    timeGroup.createEl("label", { text: "\u958B\u59CB\u4E88\u5B9A\u6642\u523B:", cls: "form-label" });
    const timeInput = timeGroup.createEl("input", {
      type: "time",
      cls: "form-input",
      value: task.scheduledTime || "09:00"
    });
    const weeklyGroup = form.createEl("div", {
      cls: "form-group",
      style: "display: none;"
    });
    weeklyGroup.createEl("label", { text: "\u66DC\u65E5\u3092\u9078\u629E:", cls: "form-label" });
    const weekdayContainer = weeklyGroup.createEl("div", { cls: "weekday-checkboxes" });
    const weekdays = [
      { value: 0, label: "\u65E5" },
      { value: 1, label: "\u6708" },
      { value: 2, label: "\u706B" },
      { value: 3, label: "\u6C34" },
      { value: 4, label: "\u6728" },
      { value: 5, label: "\u91D1" },
      { value: 6, label: "\u571F" }
    ];
    const weekdayCheckboxes = [];
    weekdays.forEach((day) => {
      const label = weekdayContainer.createEl("label", {
        cls: "weekday-checkbox-label"
      });
      const checkbox = label.createEl("input", {
        type: "checkbox",
        value: day.value.toString()
      });
      weekdayCheckboxes.push(checkbox);
      if (task.weekdays && Array.isArray(task.weekdays)) {
        checkbox.checked = task.weekdays.includes(day.value);
      }
      label.createEl("span", { text: day.label });
    });
    const monthlyGroup = form.createEl("div", {
      cls: "form-group",
      style: "display: none;"
    });
    monthlyGroup.createEl("label", { text: "\u6708\u6B21\u8A2D\u5B9A:", cls: "form-label" });
    const monthlyContainer = monthlyGroup.createEl("div", {
      cls: "monthly-settings",
      style: "display: flex; gap: 10px; align-items: center;"
    });
    monthlyContainer.createEl("span", { text: "\u7B2C" });
    const weekSelect = monthlyContainer.createEl("select", {
      cls: "form-input",
      style: "width: 60px;"
    });
    for (let i = 1; i <= 5; i++) {
      const option = weekSelect.createEl("option", {
        value: (i - 1).toString(),
        text: i.toString()
      });
      if (task.monthly_week === i - 1) {
        option.selected = true;
      }
    }
    monthlyContainer.createEl("span", { text: "\u9031\u306E" });
    const monthlyWeekdaySelect = monthlyContainer.createEl("select", {
      cls: "form-input",
      style: "width: 80px;"
    });
    weekdays.forEach((day) => {
      const option = monthlyWeekdaySelect.createEl("option", {
        value: day.value.toString(),
        text: day.label + "\u66DC\u65E5"
      });
      if (task.monthly_weekday === day.value) {
        option.selected = true;
      }
    });
    typeSelect.addEventListener("change", () => {
      const selectedType = typeSelect.value;
      weeklyGroup.style.display = "none";
      monthlyGroup.style.display = "none";
      if (selectedType === "weekly") {
        weeklyGroup.style.display = "block";
      } else if (selectedType === "monthly") {
        monthlyGroup.style.display = "block";
      }
    });
    if (task.routine_type === "weekly") {
      weeklyGroup.style.display = "block";
    } else if (task.routine_type === "monthly") {
      monthlyGroup.style.display = "block";
    }
    const buttonGroup = form.createEl("div", { cls: "form-button-group" });
    const cancelButton = buttonGroup.createEl("button", {
      type: "button",
      cls: "form-button cancel",
      text: "\u30AD\u30E3\u30F3\u30BB\u30EB"
    });
    const saveButton = buttonGroup.createEl("button", {
      type: "submit",
      cls: "form-button create",
      text: "\u4FDD\u5B58"
    });
    let removeButton = null;
    if (task.isRoutine) {
      removeButton = buttonGroup.createEl("button", {
        type: "button",
        cls: "form-button cancel",
        text: "\u30EB\u30FC\u30C1\u30F3\u3092\u5916\u3059"
      });
    }
    closeButton.addEventListener("click", () => {
      document.body.removeChild(modal);
    });
    cancelButton.addEventListener("click", () => {
      document.body.removeChild(modal);
    });
    if (removeButton) {
      removeButton.addEventListener("click", async (e) => {
        e.preventDefault();
        e.stopPropagation();
        await this.toggleRoutine(task, button);
        if (modal.parentNode) document.body.removeChild(modal);
      });
    }
    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      const scheduledTime = timeInput.value;
      const routineType = typeSelect.value;
      if (!scheduledTime) {
        new import_obsidian7.Notice("\u958B\u59CB\u6642\u523B\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044");
        return;
      }
      if (routineType === "weekly") {
        const selectedWeekdays = weekdayCheckboxes.filter((cb) => cb.checked).map((cb) => parseInt(cb.value));
        if (selectedWeekdays.length === 0) {
          new import_obsidian7.Notice("\u66DC\u65E5\u3092\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044");
          return;
        }
      }
      await this.setRoutineTaskWithDetails(
        task,
        button,
        scheduledTime,
        routineType,
        {
          weekdays: routineType === "weekly" ? weekdayCheckboxes.filter((cb) => cb.checked).map((cb) => parseInt(cb.value)) : void 0,
          monthly_week: routineType === "monthly" ? parseInt(weekSelect.value) : void 0,
          monthly_weekday: routineType === "monthly" ? parseInt(monthlyWeekdaySelect.value) : void 0
        }
      );
      document.body.removeChild(modal);
    });
    document.body.appendChild(modal);
    timeInput.focus();
  }
  async toggleRoutine(task, button) {
    try {
      const taskFolderPath = this.plugin.pathManager.getTaskFolderPath();
      const filePath = `${taskFolderPath}/${task.title}.md`;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file || !(file instanceof import_obsidian7.TFile)) {
        new import_obsidian7.Notice(`\u30BF\u30B9\u30AF\u30D5\u30A1\u30A4\u30EB\u300C${task.title}.md\u300D\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093`);
        return;
      }
      if (task.isRoutine) {
        await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
          const y = this.currentDate.getFullYear();
          const m = (this.currentDate.getMonth() + 1).toString().padStart(2, "0");
          const d = this.currentDate.getDate().toString().padStart(2, "0");
          frontmatter.routine_end = `${y}-${m}-${d}`;
          frontmatter.isRoutine = false;
          delete frontmatter.\u958B\u59CB\u6642\u523B;
          return frontmatter;
        });
        task.isRoutine = false;
        task.scheduledTime = null;
        button.classList.remove("active");
        button.setAttribute("title", "\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306B\u8A2D\u5B9A");
        await this.loadTasks();
        new import_obsidian7.Notice(`\u300C${task.title}\u300D\u3092\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u304B\u3089\u89E3\u9664\u3057\u307E\u3057\u305F`);
      } else {
        this.showRoutineEditModal(task, button);
      }
    } catch (error) {
      new import_obsidian7.Notice("\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306E\u8A2D\u5B9A\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  showTaskSettingsTooltip(inst, button) {
    const existingTooltip = document.querySelector(".task-settings-tooltip");
    if (existingTooltip) {
      existingTooltip.remove();
    }
    const tooltip = document.createElement("div");
    tooltip.className = "task-settings-tooltip";
    const tooltipHeader = tooltip.createEl("div", {
      cls: "tooltip-header"
    });
    const closeButton = tooltipHeader.createEl("button", {
      cls: "tooltip-close-button",
      text: "\xD7",
      attr: { title: "\u9589\u3058\u308B" }
    });
    closeButton.addEventListener("click", (e) => {
      e.stopPropagation();
      tooltip.remove();
    });
    const resetItem = tooltip.createEl("div", {
      cls: "tooltip-item",
      text: "\u21A9\uFE0F \u672A\u5B9F\u884C\u306B\u623B\u3059"
    });
    if (inst.state === "idle") {
      resetItem.classList.add("disabled");
      resetItem.setAttribute("title", "\u3053\u306E\u30BF\u30B9\u30AF\u306F\u672A\u5B9F\u884C\u3067\u3059");
    } else {
      resetItem.setAttribute("title", "\u30BF\u30B9\u30AF\u3092\u5B9F\u884C\u524D\u306E\u72B6\u614B\u306B\u623B\u3057\u307E\u3059");
    }
    resetItem.addEventListener("click", async (e) => {
      e.stopPropagation();
      tooltip.remove();
      if (inst.state !== "idle") {
        await this.resetTaskToIdle(inst);
      }
    });
    const moveItem = tooltip.createEl("div", {
      cls: "tooltip-item",
      text: "\u{1F4C5} \u30BF\u30B9\u30AF\u3092\u79FB\u52D5"
    });
    moveItem.setAttribute("title", "\u30BF\u30B9\u30AF\u3092\u5225\u306E\u65E5\u4ED8\u306B\u79FB\u52D5\u3057\u307E\u3059");
    moveItem.addEventListener("click", (e) => {
      e.stopPropagation();
      tooltip.remove();
      this.showTaskMoveDatePicker(inst, button);
    });
    const duplicateItem = tooltip.createEl("div", {
      cls: "tooltip-item",
      text: "\u{1F4C4} \u30BF\u30B9\u30AF\u3092\u8907\u88FD"
    });
    duplicateItem.setAttribute("title", "\u540C\u3058\u30BF\u30B9\u30AF\u3092\u3059\u3050\u4E0B\u306B\u8FFD\u52A0\u3057\u307E\u3059");
    duplicateItem.addEventListener("click", async (e) => {
      e.stopPropagation();
      tooltip.remove();
      await this.duplicateInstance(inst);
    });
    const deleteItem = tooltip.createEl("div", {
      cls: "tooltip-item delete-item",
      text: "\u{1F5D1}\uFE0F \u30BF\u30B9\u30AF\u3092\u524A\u9664"
    });
    deleteItem.addEventListener("click", async (e) => {
      e.stopPropagation();
      tooltip.remove();
      const hasHistory = await this.hasExecutionHistory(inst.task.path);
      if (inst.task.isRoutine || hasHistory) {
        await this.deleteRoutineTask(inst);
      } else {
        await this.deleteNonRoutineTask(inst);
      }
    });
    const buttonRect = button.getBoundingClientRect();
    const windowHeight = window.innerHeight;
    const windowWidth = window.innerWidth;
    const tooltipHeight = 250;
    const tooltipWidth = 200;
    tooltip.style.position = "fixed";
    tooltip.style.zIndex = "10000";
    if (buttonRect.bottom + tooltipHeight > windowHeight) {
      tooltip.style.bottom = `${windowHeight - buttonRect.top + 5}px`;
      tooltip.style.top = "auto";
    } else {
      tooltip.style.top = `${buttonRect.bottom + 5}px`;
      tooltip.style.bottom = "auto";
    }
    if (buttonRect.left + tooltipWidth > windowWidth) {
      tooltip.style.right = `${windowWidth - buttonRect.right}px`;
      tooltip.style.left = "auto";
    } else {
      tooltip.style.left = `${buttonRect.left}px`;
      tooltip.style.right = "auto";
    }
    tooltip.style.minWidth = "180px";
    tooltip.style.maxWidth = "250px";
    document.body.appendChild(tooltip);
    const closeTooltip = (e) => {
      if (!tooltip.contains(e.target) && e.target !== button) {
        tooltip.remove();
        document.removeEventListener("click", closeTooltip);
      }
    };
    setTimeout(() => {
      document.addEventListener("click", closeTooltip);
    }, 100);
  }
  // ===========================================
  // Task State Management Methods
  // ===========================================
  async startInstance(inst) {
    try {
      if (this.currentInstance && this.currentInstance.state === "running") {
        await this.stopInstance(this.currentInstance);
      }
      inst.state = "running";
      inst.startTime = /* @__PURE__ */ new Date();
      this.currentInstance = inst;
      this.saveInstanceState(inst);
      await this.saveRunningTasksState();
      this.renderTaskList();
      if (!this.globalTimerInterval) {
        this.startGlobalTimer();
      }
      new import_obsidian7.Notice(`\u958B\u59CB: ${inst.task.name}`);
    } catch (error) {
      console.error("Failed to start instance:", error);
      new import_obsidian7.Notice("\u30BF\u30B9\u30AF\u306E\u958B\u59CB\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  async stopInstance(inst) {
    try {
      if (inst.state !== "running") {
        return;
      }
      inst.state = "done";
      inst.stopTime = /* @__PURE__ */ new Date();
      if (inst.startTime) {
        const duration = this.calculateCrossDayDuration(inst.startTime, inst.stopTime);
        inst.actualMinutes = Math.floor(duration / (1e3 * 60));
      }
      if (this.currentInstance === inst) {
        this.currentInstance = null;
      }
      this.saveInstanceState(inst);
      await this.saveTaskLog(inst);
      await this.saveRunningTasksState();
      try {
        const start = inst.startTime || /* @__PURE__ */ new Date();
        const yyyy = start.getFullYear();
        const mm = String(start.getMonth() + 1).padStart(2, "0");
        const dd = String(start.getDate()).padStart(2, "0");
        const dateStr = `${yyyy}-${mm}-${dd}`;
        const heatmap = new HeatmapService(this.plugin);
        await heatmap.updateDailyStats(dateStr);
      } catch (_) {
      }
      this.initializeTaskOrders();
      this.renderTaskList();
      new import_obsidian7.Notice(`\u5B8C\u4E86: ${inst.task.name} (${inst.actualMinutes || 0}\u5206)`);
    } catch (error) {
      console.error("Failed to stop instance:", error);
      new import_obsidian7.Notice("\u30BF\u30B9\u30AF\u306E\u505C\u6B62\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  calculateCrossDayDuration(startTime, stopTime) {
    if (!startTime || !stopTime) return 0;
    let duration = stopTime.getTime() - startTime.getTime();
    if (duration < 0) {
      duration += 24 * 60 * 60 * 1e3;
    }
    return duration;
  }
  // ===========================================
  // Running Task Persistence Methods
  // ===========================================
  async saveRunningTasksState() {
    try {
      const runningInstances = this.taskInstances.filter(
        (inst) => inst.state === "running"
      );
      const dataToSave = runningInstances.map((inst) => {
        const today = inst.startTime ? new Date(inst.startTime) : /* @__PURE__ */ new Date();
        const y = today.getFullYear();
        const m = (today.getMonth() + 1).toString().padStart(2, "0");
        const d = today.getDate().toString().padStart(2, "0");
        const dateString = `${y}-${m}-${d}`;
        return {
          date: dateString,
          taskTitle: inst.task.name,
          taskPath: inst.task.path,
          startTime: inst.startTime ? inst.startTime.toISOString() : (/* @__PURE__ */ new Date()).toISOString(),
          slotKey: inst.slotKey,
          instanceId: inst.instanceId,
          taskDescription: inst.task.description || "",
          isRoutine: inst.task.isRoutine === true
        };
      });
      const logDataPath = this.plugin.pathManager.getLogDataPath();
      const dataPath = `${logDataPath}/running-task.json`;
      await this.app.vault.adapter.write(dataPath, JSON.stringify(dataToSave, null, 2));
    } catch (e) {
      console.error("[TaskChute] \u5B9F\u884C\u4E2D\u30BF\u30B9\u30AF\u306E\u4FDD\u5B58\u306B\u5931\u6557:", e);
    }
  }
  async restoreRunningTaskState() {
    try {
      const logDataPath = this.plugin.pathManager.getLogDataPath();
      const dataPath = `${logDataPath}/running-task.json`;
      const dataFile = this.app.vault.getAbstractFileByPath(dataPath);
      if (!dataFile || !(dataFile instanceof import_obsidian7.TFile)) {
        return;
      }
      const content = await this.app.vault.read(dataFile);
      const runningTasksData = JSON.parse(content);
      if (!Array.isArray(runningTasksData)) {
        return;
      }
      const currentDateString = this.getCurrentDateString();
      const deletedInstances = this.getDeletedInstances(currentDateString);
      const deletedTasks = deletedInstances.filter((inst) => inst.deletionType === "permanent").map((inst) => inst.path);
      let restored = false;
      for (const runningData of runningTasksData) {
        if (runningData.date !== currentDateString) {
          continue;
        }
        if (runningData.taskPath && deletedTasks.includes(runningData.taskPath)) {
          continue;
        }
        let runningInstance = this.taskInstances.find(
          (inst) => inst.task.path === runningData.taskPath && inst.state === "idle" && (runningData.slotKey ? inst.slotKey === runningData.slotKey : true)
        );
        if (runningInstance) {
          runningInstance.state = "running";
          runningInstance.startTime = new Date(runningData.startTime);
          runningInstance.stopTime = null;
          this.currentInstance = runningInstance;
          restored = true;
        }
      }
      if (restored) {
        this.startGlobalTimer();
        this.renderTaskList();
      }
    } catch (e) {
      console.error("[TaskChute] \u5B9F\u884C\u4E2D\u30BF\u30B9\u30AF\u306E\u5FA9\u5143\u306B\u5931\u6557:", e);
    }
  }
  saveInstanceState(inst) {
    var _a, _b;
    const stateKey = `taskchute-instance-state-${inst.instanceId}`;
    const state = {
      state: inst.state,
      startTime: (_a = inst.startTime) == null ? void 0 : _a.toISOString(),
      stopTime: (_b = inst.stopTime) == null ? void 0 : _b.toISOString(),
      pausedDuration: inst.pausedDuration,
      actualMinutes: inst.actualMinutes,
      comment: inst.comment,
      focusLevel: inst.focusLevel,
      energyLevel: inst.energyLevel
    };
    try {
      localStorage.setItem(stateKey, JSON.stringify(state));
    } catch (error) {
      console.error("Failed to save instance state:", error);
    }
  }
  async saveTaskLog(inst) {
  }
  // ===========================================
  // Timer Management Methods
  // ===========================================
  startGlobalTimer() {
    if (this.globalTimerInterval) {
      clearInterval(this.globalTimerInterval);
    }
    this.globalTimerInterval = setInterval(() => {
      this.updateAllTimers();
    }, 1e3);
  }
  updateAllTimers() {
    const runningInstances = this.taskInstances.filter((inst) => inst.state === "running");
    if (runningInstances.length === 0) {
      this.stopGlobalTimer();
      return;
    }
    runningInstances.forEach((inst) => {
      const timerEl = this.taskList.querySelector(`[data-task-path="${inst.task.path}"] .task-timer-display`);
      if (timerEl) {
        this.updateTimerDisplay(timerEl, inst);
      }
    });
  }
  updateTimerDisplay(timerEl, inst) {
    if (!inst.startTime) return;
    const now = /* @__PURE__ */ new Date();
    const elapsed = now.getTime() - inst.startTime.getTime();
    const hours = Math.floor(elapsed / (1e3 * 60 * 60));
    const minutes = Math.floor(elapsed % (1e3 * 60 * 60) / (1e3 * 60));
    const seconds = Math.floor(elapsed % (1e3 * 60) / 1e3);
    timerEl.textContent = `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
  }
  stopGlobalTimer() {
    if (this.globalTimerInterval) {
      clearInterval(this.globalTimerInterval);
      this.globalTimerInterval = null;
    }
  }
  // ===========================================
  // Event Handler Methods
  // ===========================================
  setupEventListeners() {
    this.registerDomEvent(document, "keydown", (e) => {
      this.handleKeyboardShortcut(e);
    });
    this.registerDomEvent(this.containerEl, "click", (e) => {
      if (!e.target.closest(".task-item")) {
        this.clearTaskSelection();
      }
    });
    this.registerEvent(
      this.app.vault.on("rename", async (file, oldPath) => {
        await this.handleFileRename(file, oldPath);
      })
    );
  }
  setupPlayStopButton(button, inst) {
    button.addEventListener("click", async (e) => {
      e.stopPropagation();
      if (inst.state === "running") {
        await this.stopInstance(inst);
      } else if (inst.state === "idle") {
        await this.startInstance(inst);
      }
    });
  }
  setupTaskItemEventListeners(taskItem, inst) {
    taskItem.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      this.showTaskContextMenu(e, inst);
    });
    this.setupTaskItemDragDrop(taskItem, inst);
  }
  setupTaskItemDragDrop(taskItem, inst) {
    taskItem.addEventListener("dragover", (e) => {
      e.preventDefault();
      this.handleDragOver(e, taskItem, inst);
    });
    taskItem.addEventListener("dragleave", () => {
      this.clearDragoverClasses(taskItem);
    });
    taskItem.addEventListener("drop", (e) => {
      e.preventDefault();
      this.handleDrop(e, taskItem, inst);
    });
  }
  setupDragEvents(dragHandle, taskItem, slot, idx) {
    dragHandle.addEventListener("dragstart", (e) => {
      e.dataTransfer.setData("text/plain", `${slot != null ? slot : "none"}::${idx}`);
      taskItem.classList.add("dragging");
    });
    dragHandle.addEventListener("dragend", () => {
      taskItem.classList.remove("dragging");
    });
  }
  setupTimeSlotDragHandlers(header, slot) {
    header.addEventListener("dragover", (e) => {
      e.preventDefault();
      header.classList.add("dragover");
    });
    header.addEventListener("dragleave", () => {
      header.classList.remove("dragover");
    });
    header.addEventListener("drop", (e) => {
      e.preventDefault();
      header.classList.remove("dragover");
      this.handleSlotDrop(e, slot);
    });
  }
  // ===========================================
  // Command Methods (for external commands)
  // ===========================================
  duplicateSelectedTask() {
    if (this.selectedTaskInstance) {
      this.duplicateTask(this.selectedTaskInstance);
    } else {
      new import_obsidian7.Notice("\u30BF\u30B9\u30AF\u304C\u9078\u629E\u3055\u308C\u3066\u3044\u307E\u305B\u3093");
    }
  }
  deleteSelectedTask() {
    if (this.selectedTaskInstance) {
      this.showDeleteConfirmDialog(this.selectedTaskInstance).then((confirmed) => {
        if (confirmed) {
          this.deleteTask(this.selectedTaskInstance);
        }
      });
    } else {
      new import_obsidian7.Notice("\u30BF\u30B9\u30AF\u304C\u9078\u629E\u3055\u308C\u3066\u3044\u307E\u305B\u3093");
    }
  }
  resetSelectedTask() {
    if (this.selectedTaskInstance) {
      this.resetTask(this.selectedTaskInstance);
    } else {
      new import_obsidian7.Notice("\u30BF\u30B9\u30AF\u304C\u9078\u629E\u3055\u308C\u3066\u3044\u307E\u305B\u3093");
    }
  }
  showTodayTasks() {
    const today = /* @__PURE__ */ new Date();
    this.currentDate = new Date(today.getFullYear(), today.getMonth(), today.getDate());
    const dateLabel = this.containerEl.querySelector(".date-nav-label");
    if (dateLabel) {
      this.updateDateLabel(dateLabel);
    }
    this.loadTasks().then(() => {
      new import_obsidian7.Notice(`\u4ECA\u65E5\u306E\u30BF\u30B9\u30AF\u3092\u8868\u793A\u3057\u307E\u3057\u305F`);
    });
  }
  reorganizeIdleTasks() {
    this.moveIdleTasksToCurrentTime();
    new import_obsidian7.Notice("\u30A2\u30A4\u30C9\u30EB\u30BF\u30B9\u30AF\u3092\u6574\u7406\u3057\u307E\u3057\u305F");
  }
  // ===========================================
  // Utility Methods
  // ===========================================
  getTimeSlotKeys() {
    return ["0:00-8:00", "8:00-12:00", "12:00-16:00", "16:00-0:00"];
  }
  sortTaskInstancesByTimeOrder() {
    if (this.useOrderBasedSort) {
      const savedOrders = this.loadSavedOrders();
      this.taskInstances.forEach((inst) => {
        const key = `${inst.task.path || inst.instanceId}::${inst.slotKey || "none"}`;
        if (savedOrders[key] !== void 0) {
          inst.order = savedOrders[key];
        }
      });
      this.initializeTaskOrders();
    }
  }
  initializeTaskOrders() {
    const slotGroups = {};
    this.taskInstances.forEach((inst) => {
      const slot = inst.slotKey || "none";
      if (!slotGroups[slot]) {
        slotGroups[slot] = [];
      }
      slotGroups[slot].push(inst);
    });
    Object.keys(slotGroups).forEach((slot) => {
      const instances = slotGroups[slot];
      const done = instances.filter((i) => i.state === "done");
      const running = instances.filter((i) => i.state === "running" || i.state === "paused");
      const idle = instances.filter((i) => i.state === "idle");
      let currentOrderBase = 0;
      done.sort((a, b) => {
        const ta = a.startTime ? a.startTime.getTime() : Infinity;
        const tb = b.startTime ? b.startTime.getTime() : Infinity;
        return ta - tb;
      });
      done.forEach((inst, idx) => {
        inst.order = (idx + 1) * 100;
      });
      currentOrderBase = done.length * 100;
      const existingRunningOrders = running.filter((i) => i.order !== void 0 && i.order !== null).map((i) => i.order);
      const maxExistingOrder = existingRunningOrders.length > 0 ? Math.max(...existingRunningOrders) : currentOrderBase;
      let nextOrder = Math.max(currentOrderBase, maxExistingOrder) + 100;
      running.filter((i) => i.order === void 0 || i.order === null).forEach((inst) => {
        inst.order = nextOrder;
        nextOrder += 100;
      });
      const savedIdle = idle.filter((i) => i.order !== void 0 && i.order !== null);
      const unsavedIdle = idle.filter((i) => i.order === void 0 || i.order === null);
      const existingOrdersInSlot = instances.filter((i) => i.order !== void 0 && i.order !== null).map((i) => i.order);
      const idleBase = existingOrdersInSlot.length > 0 ? Math.max(...existingOrdersInSlot) : nextOrder - 100;
      unsavedIdle.sort((a, b) => {
        var _a, _b;
        const ta = (_a = a == null ? void 0 : a.task) == null ? void 0 : _a.scheduledTime;
        const tb = (_b = b == null ? void 0 : b.task) == null ? void 0 : _b.scheduledTime;
        if (!ta && !tb) return 0;
        if (!ta) return 1;
        if (!tb) return -1;
        const [ha, ma] = ta.split(":").map((n) => parseInt(n, 10));
        const [hb, mb] = tb.split(":").map((n) => parseInt(n, 10));
        return ha * 60 + ma - (hb * 60 + mb);
      });
      let idleOrder = idleBase + 100;
      unsavedIdle.forEach((inst) => {
        inst.order = idleOrder;
        idleOrder += 100;
      });
    });
    this.saveTaskOrders();
  }
  saveTaskOrders() {
    const dateStr = this.getCurrentDateString();
    const orderKey = `taskchute-orders-${dateStr}`;
    const orders = {};
    this.taskInstances.forEach((inst) => {
      if (inst.order !== void 0) {
        const key = `${inst.task.path || inst.instanceId}::${inst.slotKey || "none"}`;
        orders[key] = inst.order;
      }
    });
    try {
      localStorage.setItem(orderKey, JSON.stringify(orders));
    } catch (error) {
      console.error("Failed to save task orders:", error);
    }
  }
  loadSavedOrders() {
    const dateStr = this.getCurrentDateString();
    const orderKey = `taskchute-orders-${dateStr}`;
    try {
      const saved = localStorage.getItem(orderKey);
      if (saved) {
        return JSON.parse(saved);
      }
    } catch (error) {
      console.error("Failed to load saved orders:", error);
    }
    return {};
  }
  sortByOrder(instances) {
    return instances.sort((a, b) => {
      var _a, _b, _c, _d;
      const statePriority = { done: 0, running: 1, paused: 1, idle: 2 };
      const sa = (_a = statePriority[a.state]) != null ? _a : 3;
      const sb = (_b = statePriority[b.state]) != null ? _b : 3;
      if (sa !== sb) return sa - sb;
      const hasOrderA = a.order !== void 0 && a.order !== null;
      const hasOrderB = b.order !== void 0 && b.order !== null;
      if (hasOrderA && hasOrderB) {
        if (a.order !== b.order) return a.order - b.order;
      } else if (hasOrderA && !hasOrderB) {
        return -1;
      } else if (!hasOrderA && hasOrderB) {
        return 1;
      }
      if (a.state === "done" && b.state === "done") {
        const ta = a.startTime ? a.startTime.getTime() : Infinity;
        const tb = b.startTime ? b.startTime.getTime() : Infinity;
        if (ta !== tb) return ta - tb;
        return 0;
      }
      const tA = (_c = a == null ? void 0 : a.task) == null ? void 0 : _c.scheduledTime;
      const tB = (_d = b == null ? void 0 : b.task) == null ? void 0 : _d.scheduledTime;
      if (!tA && !tB) return 0;
      if (!tA) return 1;
      if (!tB) return -1;
      const [ha, ma] = tA.split(":").map((n) => parseInt(n, 10));
      const [hb, mb] = tB.split(":").map((n) => parseInt(n, 10));
      return ha * 60 + ma - (hb * 60 + mb);
    });
  }
  moveTaskToSlot(inst, newSlot, position) {
    const oldSlot = inst.slotKey;
    inst.slotKey = newSlot;
    const slotTasks = this.taskInstances.filter(
      (t) => t.slotKey === newSlot && t !== inst
    );
    this.sortByOrder(slotTasks);
    if (position !== void 0 && position >= 0) {
      slotTasks.splice(position, 0, inst);
    } else {
      slotTasks.push(inst);
    }
    slotTasks.forEach((task, idx) => {
      task.order = idx;
    });
    this.saveTaskOrders();
    this.renderTaskList();
  }
  applyResponsiveClasses() {
    const width = this.containerEl.clientWidth;
    const classList = this.containerEl.classList;
    classList.remove("narrow", "medium", "wide");
    if (width < 400) {
      classList.add("narrow");
    } else if (width < 600) {
      classList.add("medium");
    } else {
      classList.add("wide");
    }
  }
  setupResizeObserver() {
    const resizeObserver = new ResizeObserver(() => {
      this.applyResponsiveClasses();
    });
    resizeObserver.observe(this.containerEl);
  }
  initializeNavigationEventListeners() {
    const drawerToggle = this.containerEl.querySelector(".drawer-toggle");
    if (drawerToggle) {
      drawerToggle.addEventListener("click", () => {
        this.toggleNavigation();
      });
    }
    if (this.navigationOverlay) {
      this.navigationOverlay.addEventListener("click", () => {
        this.closeNavigation();
      });
    }
  }
  scheduleBoundaryCheck() {
    const now = /* @__PURE__ */ new Date();
    const nextHour = new Date(now);
    nextHour.setHours(nextHour.getHours() + 1, 0, 0, 0);
    const msUntilNextHour = nextHour.getTime() - now.getTime();
    this.boundaryCheckTimeout = setTimeout(() => {
      this.checkBoundaryTasks();
      this.scheduleBoundaryCheck();
    }, msUntilNextHour);
  }
  checkBoundaryTasks() {
    const now = /* @__PURE__ */ new Date();
    const currentHour = now.getHours();
    const currentSlot = `${currentHour.toString().padStart(2, "0")}:00`;
  }
  updateTotalTasksCount() {
    const completedTasks = this.taskInstances.filter((inst) => inst.state === "done");
  }
  cleanupAutocompleteInstances() {
    if (this.autocompleteInstances) {
      this.autocompleteInstances.forEach((instance) => {
        if (instance && instance.cleanup) {
          instance.cleanup();
        }
      });
      this.autocompleteInstances = [];
    }
  }
  cleanupTimers() {
    if (this.globalTimerInterval) {
      clearInterval(this.globalTimerInterval);
      this.globalTimerInterval = null;
    }
    if (this.boundaryCheckTimeout) {
      clearTimeout(this.boundaryCheckTimeout);
      this.boundaryCheckTimeout = null;
    }
    if (this.renderDebounceTimer) {
      clearTimeout(this.renderDebounceTimer);
      this.renderDebounceTimer = null;
    }
  }
  applyStyles() {
    const style = document.createElement("style");
    style.textContent = TASKCHUTE_FULL_CSS;
    document.head.appendChild(style);
  }
  // ===========================================
  // Placeholder Methods (to be implemented)
  // ===========================================
  async handleNavigationItemClick(section) {
    if (section === "log") {
      this.openLogModal();
      this.closeNavigation();
      return;
    }
    if (section === "review") {
      await this.showReviewSection();
      this.closeNavigation();
      return;
    }
    new import_obsidian7.Notice(`${section} \u6A5F\u80FD\u306F\u5B9F\u88C5\u4E2D\u3067\u3059`);
  }
  // Show Daily Review in right split
  async showReviewSection() {
    try {
      const today = /* @__PURE__ */ new Date();
      const todayStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, "0")}-${String(today.getDate()).padStart(2, "0")}`;
      const selectedStr = this.getCurrentDateString();
      const reviewDate = new Date(selectedStr);
      const dateStr = reviewDate > new Date(todayStr) ? todayStr : selectedStr;
      const review = new ReviewService(this.plugin);
      const file = await review.ensureReviewFile(dateStr);
      await review.openInSplit(file, this.leaf);
    } catch (error) {
      new import_obsidian7.Notice("\u30EC\u30D3\u30E5\u30FC\u306E\u8868\u793A\u306B\u5931\u6557\u3057\u307E\u3057\u305F: " + ((error == null ? void 0 : error.message) || error));
    }
  }
  openLogModal() {
    const overlay = document.createElement("div");
    overlay.className = "taskchute-log-modal-overlay";
    const content = overlay.createEl("div", { cls: "taskchute-log-modal-content" });
    const closeBtn = content.createEl("button", { cls: "log-modal-close", text: "\xD7", attr: { title: "\u9589\u3058\u308B" } });
    closeBtn.addEventListener("click", () => {
      if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
    });
    const logView = new LogView(this.plugin, content);
    logView.render();
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) {
        if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
      }
    });
    document.body.appendChild(overlay);
  }
  handleKeyboardShortcut(e) {
  }
  selectTaskForKeyboard(inst, taskItem) {
    this.selectedTaskInstance = inst;
    this.containerEl.querySelectorAll(".task-item.keyboard-selected").forEach((el) => el.classList.remove("keyboard-selected"));
    taskItem.classList.add("keyboard-selected");
  }
  clearTaskSelection() {
    this.selectedTaskInstance = null;
    this.containerEl.querySelectorAll(".task-item.keyboard-selected").forEach((el) => el.classList.remove("keyboard-selected"));
  }
  async deleteTask(inst) {
    if (!inst) return;
    if (!inst.task.isRoutine) {
      await this.deleteNonRoutineTask(inst);
    } else {
      await this.deleteRoutineTask(inst);
    }
  }
  async deleteNonRoutineTask(inst) {
    await this.deleteInstance(inst);
  }
  async deleteRoutineTask(inst) {
    const dateStr = this.getCurrentDateString();
    const hiddenKey = `taskchute-hidden-routines-${dateStr}`;
    const hiddenRoutines = JSON.parse(localStorage.getItem(hiddenKey) || "[]");
    const isDuplicated = this.isDuplicatedTask(inst);
    const alreadyHidden = hiddenRoutines.some((h) => {
      if (isDuplicated) {
        return h.instanceId === inst.instanceId;
      }
      if (typeof h === "string") {
        return h === inst.task.path;
      }
      return h.path === inst.task.path && !h.instanceId;
    });
    if (!alreadyHidden) {
      if (isDuplicated) {
        hiddenRoutines.push({
          path: inst.task.path,
          instanceId: inst.instanceId
        });
      } else {
        hiddenRoutines.push({
          path: inst.task.path,
          instanceId: null
        });
      }
      localStorage.setItem(hiddenKey, JSON.stringify(hiddenRoutines));
    }
    if (inst.instanceId) {
      await this.deleteTaskLogsByInstanceId(inst.task.path, inst.instanceId);
    }
    await this.deleteInstance(inst);
  }
  isDuplicatedTask(inst) {
    const dateStr = this.getCurrentDateString();
    const duplicationKey = `taskchute-duplicated-instances-${dateStr}`;
    const duplicatedInstances = JSON.parse(localStorage.getItem(duplicationKey) || "[]");
    return duplicatedInstances.some((d) => d.instanceId === inst.instanceId);
  }
  async deleteTaskLogsByInstanceId(taskPath, instanceId) {
    try {
      const logDataPath = this.plugin.pathManager.getLogDataPath();
      const [year, month] = this.getCurrentDateString().split("-");
      const monthString = `${year}-${month}`;
      const logPath = `${logDataPath}/${monthString}-tasks.json`;
      const logFile = this.app.vault.getAbstractFileByPath(logPath);
      if (!logFile || !(logFile instanceof import_obsidian7.TFile)) {
        return 0;
      }
      const content = await this.app.vault.read(logFile);
      const monthlyLog = JSON.parse(content);
      let deletedCount = 0;
      for (const dateKey in monthlyLog.taskExecutions) {
        const dayExecutions = monthlyLog.taskExecutions[dateKey];
        const beforeLength = dayExecutions.length;
        monthlyLog.taskExecutions[dateKey] = dayExecutions.filter(
          (exec) => exec.instanceId !== instanceId
        );
        deletedCount += beforeLength - monthlyLog.taskExecutions[dateKey].length;
      }
      if (deletedCount > 0) {
        await this.app.vault.modify(logFile, JSON.stringify(monthlyLog, null, 2));
      }
      return deletedCount;
    } catch (error) {
      console.error("Failed to delete task logs:", error);
      return 0;
    }
  }
  showTaskContextMenu(e, inst) {
    new import_obsidian7.Notice("\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8\u30E1\u30CB\u30E5\u30FC\u306F\u5B9F\u88C5\u4E2D\u3067\u3059");
  }
  handleDragOver(e, taskItem, inst) {
    e.preventDefault();
    this.clearDragoverClasses(taskItem);
    if (inst.state === "done") {
      taskItem.classList.add("dragover-invalid");
      return;
    }
    const rect = taskItem.getBoundingClientRect();
    const y = e.clientY - rect.top;
    const height = rect.height;
    const isBottomHalf = y > height / 2;
    if (isBottomHalf) {
      taskItem.classList.add("dragover-bottom");
    } else {
      taskItem.classList.add("dragover-top");
    }
  }
  clearDragoverClasses(taskItem) {
    taskItem.classList.remove("dragover", "dragover-top", "dragover-bottom", "dragover-invalid");
  }
  handleDrop(e, taskItem, targetInst) {
    var _a;
    const data = (_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain");
    if (!data) return;
    const [sourceSlot, sourceIdx] = data.split("::");
    const targetSlot = targetInst.slotKey || "none";
    const sourceInst = this.taskInstances.find((inst) => {
      const instSlot = inst.slotKey || "none";
      const slotInstances = this.taskInstances.filter((t) => (t.slotKey || "none") === instSlot);
      const sortedSlotInstances = this.sortByOrder(slotInstances);
      const idx = sortedSlotInstances.indexOf(inst);
      return instSlot === sourceSlot && idx === parseInt(sourceIdx);
    });
    if (!sourceInst || sourceInst.state === "done") return;
    const rect = taskItem.getBoundingClientRect();
    const y = e.clientY - rect.top;
    const isBottomHalf = y > rect.height / 2;
    const targetSlotTasks = this.taskInstances.filter(
      (t) => (t.slotKey || "none") === targetSlot
    );
    const sortedTargetTasks = this.sortByOrder(targetSlotTasks);
    const targetIndex = sortedTargetTasks.indexOf(targetInst);
    let newPosition = isBottomHalf ? targetIndex + 1 : targetIndex;
    if (sourceSlot === targetSlot) {
      const sourceIndex = sortedTargetTasks.indexOf(sourceInst);
      if (sourceIndex < newPosition) {
        newPosition--;
      }
    }
    this.moveTaskToSlot(sourceInst, targetSlot, newPosition);
  }
  handleSlotDrop(e, slot) {
    var _a;
    const data = (_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain");
    if (!data) return;
    const [sourceSlot, sourceIdx] = data.split("::");
    const sourceInst = this.taskInstances.find((inst) => {
      const instSlot = inst.slotKey || "none";
      const slotInstances = this.taskInstances.filter((t) => (t.slotKey || "none") === instSlot);
      const sortedSlotInstances = this.sortByOrder(slotInstances);
      const idx = sortedSlotInstances.indexOf(inst);
      return instSlot === sourceSlot && idx === parseInt(sourceIdx);
    });
    if (!sourceInst || sourceInst.state === "done") return;
    this.moveTaskToSlot(sourceInst, slot);
  }
  toggleNavigation() {
    this.navigationState.isOpen = !this.navigationState.isOpen;
    if (this.navigationState.isOpen) {
      this.openNavigation();
    } else {
      this.closeNavigation();
    }
  }
  openNavigation() {
    this.navigationPanel.classList.remove("navigation-panel-hidden");
    this.navigationOverlay.classList.remove("navigation-overlay-hidden");
  }
  closeNavigation() {
    this.navigationPanel.classList.add("navigation-panel-hidden");
    this.navigationOverlay.classList.add("navigation-overlay-hidden");
  }
  async setRoutineTask(task, button, scheduledTime) {
    try {
      const taskFolderPath = this.plugin.pathManager.getTaskFolderPath();
      const filePath = `${taskFolderPath}/${task.title}.md`;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file || !(file instanceof import_obsidian7.TFile)) {
        new import_obsidian7.Notice(`\u30BF\u30B9\u30AF\u30D5\u30A1\u30A4\u30EB\u300C${task.title}.md\u300D\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093`);
        return;
      }
      await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
        frontmatter.isRoutine = true;
        frontmatter.\u958B\u59CB\u6642\u523B = scheduledTime;
        frontmatter.routine_type = "daily";
        const y = this.currentDate.getFullYear();
        const m = (this.currentDate.getMonth() + 1).toString().padStart(2, "0");
        const d = this.currentDate.getDate().toString().padStart(2, "0");
        frontmatter.routine_start = `${y}-${m}-${d}`;
        delete frontmatter.routine_end;
        return frontmatter;
      });
      task.isRoutine = true;
      task.scheduledTime = scheduledTime;
      button.classList.add("active");
      button.setAttribute("title", `\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\uFF08${scheduledTime}\u958B\u59CB\u4E88\u5B9A\uFF09`);
      await this.loadTasks();
      new import_obsidian7.Notice(`\u300C${task.title}\u300D\u3092\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306B\u8A2D\u5B9A\u3057\u307E\u3057\u305F\uFF08${scheduledTime}\u958B\u59CB\u4E88\u5B9A\uFF09`);
    } catch (error) {
      console.error("Failed to set routine task:", error);
      new import_obsidian7.Notice("\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306E\u8A2D\u5B9A\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  async setRoutineTaskWithDetails(task, button, scheduledTime, routineType, details) {
    try {
      const taskFolderPath = this.plugin.pathManager.getTaskFolderPath();
      const filePath = `${taskFolderPath}/${task.title}.md`;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file || !(file instanceof import_obsidian7.TFile)) {
        new import_obsidian7.Notice(`\u30BF\u30B9\u30AF\u30D5\u30A1\u30A4\u30EB\u300C${task.title}.md\u300D\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093`);
        return;
      }
      await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
        frontmatter.isRoutine = true;
        frontmatter.\u958B\u59CB\u6642\u523B = scheduledTime;
        frontmatter.routine_type = routineType;
        const y = this.currentDate.getFullYear();
        const m = (this.currentDate.getMonth() + 1).toString().padStart(2, "0");
        const d = this.currentDate.getDate().toString().padStart(2, "0");
        frontmatter.routine_start = `${y}-${m}-${d}`;
        delete frontmatter.routine_end;
        delete frontmatter.weekday;
        delete frontmatter.weekdays;
        delete frontmatter.monthly_week;
        delete frontmatter.monthly_weekday;
        switch (routineType) {
          case "daily":
          case "weekdays":
          case "weekends":
            break;
          case "weekly":
            if (details.weekdays && details.weekdays.length > 0) {
              if (details.weekdays.length === 1) {
                frontmatter.weekday = details.weekdays[0];
              } else {
                frontmatter.weekdays = details.weekdays;
              }
            }
            break;
          case "monthly":
            if (details.monthly_week !== void 0 && details.monthly_weekday !== void 0) {
              frontmatter.monthly_week = details.monthly_week;
              frontmatter.monthly_weekday = details.monthly_weekday;
            }
            break;
        }
        return frontmatter;
      });
      task.isRoutine = true;
      task.scheduledTime = scheduledTime;
      task.routine_type = routineType;
      if (routineType === "weekly" && details.weekdays) {
        task.weekdays = details.weekdays;
      } else if (routineType === "monthly") {
        task.monthly_week = details.monthly_week;
        task.monthly_weekday = details.monthly_weekday;
      }
      button.classList.add("active");
      let tooltipText = `\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\uFF08${scheduledTime}\u958B\u59CB\u4E88\u5B9A\uFF09`;
      switch (routineType) {
        case "daily":
          tooltipText += " - \u6BCE\u65E5";
          break;
        case "weekdays":
          tooltipText += " - \u5E73\u65E5\u306E\u307F";
          break;
        case "weekends":
          tooltipText += " - \u9031\u672B\u306E\u307F";
          break;
        case "weekly":
          if (details.weekdays) {
            const dayNames = ["\u65E5", "\u6708", "\u706B", "\u6C34", "\u6728", "\u91D1", "\u571F"];
            const days = details.weekdays.map((d) => dayNames[d]).join(",");
            tooltipText += ` - \u6BCE\u9031${days}`;
          }
          break;
        case "monthly":
          if (details.monthly_week !== void 0 && details.monthly_weekday !== void 0) {
            const dayNames = ["\u65E5", "\u6708", "\u706B", "\u6C34", "\u6728", "\u91D1", "\u571F"];
            tooltipText += ` - \u7B2C${details.monthly_week + 1}${dayNames[details.monthly_weekday]}\u66DC\u65E5`;
          }
          break;
      }
      button.setAttribute("title", tooltipText);
      await this.loadTasks();
      new import_obsidian7.Notice(`\u300C${task.title}\u300D\u3092\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306B\u8A2D\u5B9A\u3057\u307E\u3057\u305F`);
    } catch (error) {
      console.error("Failed to set routine task:", error);
      new import_obsidian7.Notice("\u30EB\u30FC\u30C1\u30F3\u30BF\u30B9\u30AF\u306E\u8A2D\u5B9A\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  async deleteInstanceWithConfirm(inst) {
    const confirmed = await this.showDeleteConfirmDialog(inst);
    if (confirmed) {
      await this.deleteInstance(inst);
    }
  }
  showDeleteConfirmDialog(inst) {
    return new Promise((resolve) => {
      const modal = document.createElement("div");
      modal.className = "task-modal-overlay";
      const modalContent = modal.createEl("div", { cls: "task-modal-content" });
      modalContent.createEl("h3", { text: "\u30BF\u30B9\u30AF\u306E\u524A\u9664\u78BA\u8A8D" });
      modalContent.createEl("p", {
        text: `\u300C${inst.task.title}\u300D\u3092\u524A\u9664\u3057\u3066\u3082\u3088\u308D\u3057\u3044\u3067\u3059\u304B\uFF1F`
      });
      const buttonContainer = modalContent.createEl("div", {
        cls: "modal-button-container"
      });
      const confirmButton = buttonContainer.createEl("button", {
        text: "\u524A\u9664",
        cls: "mod-cta"
      });
      const cancelButton = buttonContainer.createEl("button", {
        text: "\u30AD\u30E3\u30F3\u30BB\u30EB"
      });
      confirmButton.addEventListener("click", () => {
        modal.remove();
        resolve(true);
      });
      cancelButton.addEventListener("click", () => {
        modal.remove();
        resolve(false);
      });
      document.body.appendChild(modal);
    });
  }
  async deleteInstance(inst) {
    try {
      const index = this.taskInstances.indexOf(inst);
      if (index > -1) {
        this.taskInstances.splice(index, 1);
      }
      const dateStr = this.getCurrentDateString();
      const deletedInstances = this.getDeletedInstances(dateStr);
      deletedInstances.push({
        instanceId: inst.instanceId,
        path: inst.task.path,
        deletionType: inst.task.isRoutine ? "today" : "permanent",
        deletedAt: (/* @__PURE__ */ new Date()).toISOString()
      });
      this.saveDeletedInstances(dateStr, deletedInstances);
      if (!inst.task.isRoutine) {
        const samePathInstances = this.taskInstances.filter(
          (i) => i.task.path === inst.task.path
        );
        if (samePathInstances.length === 0 && inst.task.file) {
          this.tasks = this.tasks.filter((t) => t.path !== inst.task.path);
          await this.app.vault.delete(inst.task.file);
          new import_obsidian7.Notice(`\u300C${inst.task.title}\u300D\u3092\u5B8C\u5168\u306B\u524A\u9664\u3057\u307E\u3057\u305F\u3002`);
        } else {
          new import_obsidian7.Notice(`\u300C${inst.task.title}\u300D\u3092\u672C\u65E5\u306E\u30EA\u30B9\u30C8\u304B\u3089\u524A\u9664\u3057\u307E\u3057\u305F\u3002`);
        }
      } else {
        new import_obsidian7.Notice(`\u300C${inst.task.title}\u300D\u3092\u672C\u65E5\u306E\u30EA\u30B9\u30C8\u304B\u3089\u524A\u9664\u3057\u307E\u3057\u305F\u3002`);
      }
      this.renderTaskList();
    } catch (error) {
      console.error("Failed to delete instance:", error);
      new import_obsidian7.Notice("\u30BF\u30B9\u30AF\u306E\u524A\u9664\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  async resetTaskToIdle(inst) {
    try {
      inst.state = "idle";
      inst.startTime = void 0;
      inst.stopTime = void 0;
      this.saveInstanceState(inst);
      this.renderTaskList();
      new import_obsidian7.Notice(`\u300C${inst.task.title}\u300D\u3092\u30A2\u30A4\u30C9\u30EB\u72B6\u614B\u306B\u623B\u3057\u307E\u3057\u305F`);
    } catch (error) {
      console.error("Failed to reset task:", error);
      new import_obsidian7.Notice("\u30BF\u30B9\u30AF\u306E\u30EA\u30BB\u30C3\u30C8\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  async showProjectSettingsModal(inst, tooltip) {
    if (tooltip) {
      tooltip.remove();
    }
    const modal = document.createElement("div");
    modal.className = "task-modal-overlay";
    const modalContent = modal.createEl("div", { cls: "task-modal-content" });
    const modalHeader = modalContent.createEl("div", { cls: "modal-header" });
    modalHeader.createEl("h3", {
      text: `\u300C${inst.task.title}\u300D\u306E\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u8A2D\u5B9A`
    });
    const closeButton = modalHeader.createEl("button", {
      cls: "modal-close-button",
      text: "\xD7"
    });
    const form = modalContent.createEl("form", { cls: "task-form" });
    const projectGroup = form.createEl("div", { cls: "form-group" });
    projectGroup.createEl("label", { text: "\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8:", cls: "form-label" });
    const projectSelect = projectGroup.createEl("select", {
      cls: "form-select"
    });
    const projects = await this.getAvailableProjects();
    const noneOption = projectSelect.createEl("option", {
      value: "",
      text: "\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u306A\u3057"
    });
    projects.forEach((project) => {
      projectSelect.createEl("option", {
        value: project,
        text: project
      });
    });
    if (inst.task.project) {
      projectSelect.value = inst.task.project;
    }
    const buttonGroup = form.createEl("div", { cls: "form-button-group" });
    const cancelButton = buttonGroup.createEl("button", {
      type: "button",
      cls: "form-button cancel",
      text: "\u30AD\u30E3\u30F3\u30BB\u30EB"
    });
    const saveButton = buttonGroup.createEl("button", {
      type: "submit",
      cls: "form-button create",
      text: "\u4FDD\u5B58"
    });
    closeButton.addEventListener("click", () => {
      document.body.removeChild(modal);
    });
    cancelButton.addEventListener("click", () => {
      document.body.removeChild(modal);
    });
    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      const selectedProject = projectSelect.value;
      await this.updateTaskProject(inst, selectedProject);
      document.body.removeChild(modal);
    });
    document.body.appendChild(modal);
  }
  async getAvailableProjects() {
    try {
      const projectFolderPath = this.plugin.pathManager.getProjectFolderPath();
      const projectFolder = this.app.vault.getAbstractFileByPath(projectFolderPath);
      if (!projectFolder || !("children" in projectFolder)) {
        return [];
      }
      const projects = [];
      for (const file of projectFolder.children) {
        if (file instanceof import_obsidian7.TFile && file.extension === "md") {
          projects.push(file.basename);
        }
      }
      return projects;
    } catch (error) {
      console.error("Failed to get projects:", error);
      return [];
    }
  }
  async updateTaskProject(inst, projectName) {
    try {
      const taskFolderPath = this.plugin.pathManager.getTaskFolderPath();
      const filePath = `${taskFolderPath}/${inst.task.title}.md`;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file || !(file instanceof import_obsidian7.TFile)) {
        new import_obsidian7.Notice(`\u30BF\u30B9\u30AF\u30D5\u30A1\u30A4\u30EB\u300C${inst.task.title}.md\u300D\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093`);
        return;
      }
      await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
        if (projectName) {
          frontmatter.project = `[[${projectName}]]`;
          frontmatter.project_path = `TaskChute/Project/${projectName}.md`;
        } else {
          delete frontmatter.project;
          delete frontmatter.project_path;
        }
        return frontmatter;
      });
      inst.task.project = projectName || void 0;
      inst.task.projectPath = projectName ? `TaskChute/Project/${projectName}.md` : void 0;
      inst.task.projectTitle = projectName || void 0;
      this.renderTaskList();
      const message = projectName ? `\u300C${inst.task.title}\u300D\u3092${projectName}\u306B\u95A2\u9023\u4ED8\u3051\u307E\u3057\u305F` : `\u300C${inst.task.title}\u300D\u306E\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u95A2\u9023\u4ED8\u3051\u3092\u89E3\u9664\u3057\u307E\u3057\u305F`;
      new import_obsidian7.Notice(message);
    } catch (error) {
      console.error("Failed to update project:", error);
      new import_obsidian7.Notice("\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u306E\u66F4\u65B0\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  moveIdleTasksToCurrentTime() {
    new import_obsidian7.Notice("\u30A2\u30A4\u30C9\u30EB\u30BF\u30B9\u30AF\u79FB\u52D5\u6A5F\u80FD\u306F\u5B9F\u88C5\u4E2D\u3067\u3059");
  }
  async showAddTaskModal() {
    const modal = document.createElement("div");
    modal.className = "task-modal-overlay";
    const modalContent = modal.createEl("div", { cls: "task-modal-content" });
    const modalHeader = modalContent.createEl("div", { cls: "modal-header" });
    modalHeader.createEl("h3", { text: "\u65B0\u3057\u3044\u30BF\u30B9\u30AF\u3092\u8FFD\u52A0" });
    const closeButton = modalHeader.createEl("button", {
      cls: "modal-close-button",
      text: "\xD7"
    });
    const form = modalContent.createEl("form", { cls: "task-form" });
    const nameGroup = form.createEl("div", { cls: "form-group" });
    nameGroup.createEl("label", { text: "\u30BF\u30B9\u30AF\u540D:", cls: "form-label" });
    const nameInput = nameGroup.createEl("input", {
      type: "text",
      cls: "form-input",
      placeholder: "\u30BF\u30B9\u30AF\u540D\u3092\u5165\u529B"
    });
    const estimatedMinutes = 30;
    const buttonGroup = form.createEl("div", { cls: "form-button-group" });
    const cancelButton = buttonGroup.createEl("button", {
      type: "button",
      cls: "form-button cancel",
      text: "\u30AD\u30E3\u30F3\u30BB\u30EB"
    });
    const saveButton = buttonGroup.createEl("button", {
      type: "submit",
      cls: "form-button create",
      text: "\u4FDD\u5B58"
    });
    closeButton.addEventListener("click", () => {
      document.body.removeChild(modal);
    });
    cancelButton.addEventListener("click", () => {
      document.body.removeChild(modal);
    });
    form.addEventListener("submit", async (e) => {
      e.preventDefault();
      const taskName = nameInput.value.trim();
      if (!taskName) {
        new import_obsidian7.Notice("\u30BF\u30B9\u30AF\u540D\u3092\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044");
        return;
      }
      await this.createNewTask(taskName, estimatedMinutes);
      document.body.removeChild(modal);
    });
    document.body.appendChild(modal);
    nameInput.focus();
  }
  async createNewTask(taskName, estimatedMinutes) {
    try {
      const taskFolderPath = this.plugin.pathManager.getTaskFolderPath();
      const filePath = `${taskFolderPath}/${taskName}.md`;
      const dateStr = this.getCurrentDateString();
      const frontmatter = [
        "---",
        `target_date: "${dateStr}"`,
        "---",
        "",
        `#task`,
        "",
        `# ${taskName}`,
        ""
      ].join("\n");
      await this.app.vault.create(filePath, frontmatter);
      setTimeout(async () => {
        await this.loadTasks();
        this.renderTaskList();
      }, 100);
      new import_obsidian7.Notice(`\u30BF\u30B9\u30AF\u300C${taskName}\u300D\u3092\u4F5C\u6210\u3057\u307E\u3057\u305F`);
    } catch (error) {
      console.error("Failed to create task:", error);
      new import_obsidian7.Notice("\u30BF\u30B9\u30AF\u306E\u4F5C\u6210\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  async showTaskMoveDatePicker(inst, button) {
    const modal = document.createElement("div");
    modal.className = "task-modal-overlay";
    const modalContent = modal.createEl("div", { cls: "task-modal-content" });
    modalContent.createEl("h3", { text: "\u30BF\u30B9\u30AF\u3092\u79FB\u52D5" });
    const dateInput = modalContent.createEl("input", {
      type: "date",
      value: this.getCurrentDateString()
    });
    const buttonContainer = modalContent.createEl("div", {
      cls: "modal-button-container"
    });
    const cancelButton = buttonContainer.createEl("button", {
      text: "\u30AD\u30E3\u30F3\u30BB\u30EB"
    });
    const moveButton = buttonContainer.createEl("button", {
      text: "\u79FB\u52D5",
      cls: "mod-cta"
    });
    cancelButton.addEventListener("click", () => {
      modal.remove();
    });
    moveButton.addEventListener("click", async () => {
      const newDate = dateInput.value;
      if (newDate) {
        await this.moveTaskToDate(inst, newDate);
        modal.remove();
      }
    });
    document.body.appendChild(modal);
  }
  async moveTaskToDate(inst, dateStr) {
    try {
      const file = this.app.vault.getAbstractFileByPath(inst.task.path);
      if (file instanceof import_obsidian7.TFile) {
        await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
          frontmatter.target_date = dateStr;
          return frontmatter;
        });
      }
      new import_obsidian7.Notice(`\u30BF\u30B9\u30AF\u300C${inst.task.title}\u300D\u3092${dateStr}\u306B\u79FB\u52D5\u3057\u307E\u3057\u305F`);
      await this.loadTasks();
    } catch (error) {
      console.error("Failed to move task:", error);
      new import_obsidian7.Notice("\u30BF\u30B9\u30AF\u306E\u79FB\u52D5\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  async showProjectModal(inst) {
    await this.showUnifiedProjectModal(inst);
  }
  async showUnifiedProjectModal(inst) {
    try {
      const modal = document.createElement("div");
      modal.className = "task-modal-overlay";
      const modalContent = modal.createEl("div", { cls: "task-modal-content" });
      const modalHeader = modalContent.createEl("div", { cls: "modal-header" });
      modalHeader.createEl("h3", {
        text: `\u300C${inst.task.title}\u300D\u306E\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u8A2D\u5B9A`
      });
      const closeButton = modalHeader.createEl("button", {
        cls: "modal-close-button",
        text: "\xD7",
        attr: { title: "\u9589\u3058\u308B" }
      });
      const form = modalContent.createEl("form", { cls: "task-form" });
      let projectFiles = [];
      try {
        projectFiles = await this.getProjectFiles();
      } catch (error) {
        new import_obsidian7.Notice("\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30EA\u30B9\u30C8\u306E\u8AAD\u307F\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
        modal.remove();
        return;
      }
      if (projectFiles.length === 0) {
        const noProjectGroup = form.createEl("div", { cls: "form-group" });
        noProjectGroup.createEl("p", {
          text: "\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30D5\u30A1\u30A4\u30EB\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002",
          cls: "form-description"
        });
        noProjectGroup.createEl("p", {
          text: "\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30D5\u30A1\u30A4\u30EB\u306B #project \u30BF\u30B0\u3092\u8FFD\u52A0\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
          cls: "form-description"
        });
      } else {
        const projectGroup = form.createEl("div", { cls: "form-group" });
        projectGroup.createEl("label", {
          text: "\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3092\u9078\u629E:",
          cls: "form-label"
        });
        const projectSelect = projectGroup.createEl("select", {
          cls: "form-input"
        });
        if (inst.task.projectPath) {
          const removeProjectOption = projectSelect.createEl("option", {
            value: "",
            text: "\u2796 \u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3092\u5916\u3059"
          });
        } else {
          const emptyOption = projectSelect.createEl("option", {
            value: "",
            text: ""
          });
          emptyOption.selected = true;
        }
        projectFiles.forEach((project) => {
          const option = projectSelect.createEl("option", {
            value: project.path,
            text: project.basename
          });
          if (inst.task.projectPath === project.path) {
            option.selected = true;
          }
        });
        const descGroup = form.createEl("div", { cls: "form-group" });
        if (inst.task.projectPath) {
          descGroup.createEl("p", {
            text: "\u5225\u306E\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3092\u9078\u629E\u3059\u308B\u304B\u3001\u300C\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3092\u5916\u3059\u300D\u3092\u9078\u629E\u3057\u3066\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3092\u89E3\u9664\u3067\u304D\u307E\u3059\u3002",
            cls: "form-description"
          });
        } else {
          descGroup.createEl("p", {
            text: "\u30BF\u30B9\u30AF\u306B\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3092\u8A2D\u5B9A\u3059\u308B\u3068\u3001\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30DA\u30FC\u30B8\u304B\u3089\u95A2\u9023\u30BF\u30B9\u30AF\u3092\u78BA\u8A8D\u3067\u304D\u307E\u3059\u3002",
            cls: "form-description"
          });
        }
        const buttonGroup = form.createEl("div", { cls: "form-button-group" });
        const cancelButton = buttonGroup.createEl("button", {
          type: "button",
          cls: "form-button cancel",
          text: "\u30AD\u30E3\u30F3\u30BB\u30EB"
        });
        const saveButton = buttonGroup.createEl("button", {
          type: "submit",
          cls: "form-button create",
          text: "\u4FDD\u5B58"
        });
        form.addEventListener("submit", async (e) => {
          e.preventDefault();
          const selectedProject = projectSelect.value;
          await this.setProjectForTask(inst.task, selectedProject);
          this.updateProjectDisplay(inst);
          modal.remove();
        });
        cancelButton.addEventListener("click", () => {
          modal.remove();
        });
      }
      closeButton.addEventListener("click", () => {
        modal.remove();
      });
      document.body.appendChild(modal);
    } catch (error) {
      console.error("Failed to show project modal:", error);
      new import_obsidian7.Notice("\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u9078\u629E\u753B\u9762\u306E\u8868\u793A\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  async getProjectFiles() {
    const files = this.app.vault.getMarkdownFiles();
    const projectFiles = [];
    const projectFolderPath = this.plugin.pathManager.getProjectFolderPath();
    for (const file of files) {
      if (file.path.startsWith(projectFolderPath + "/") && file.basename.startsWith("Project - ")) {
        projectFiles.push(file);
        continue;
      }
      if (file.basename.startsWith("Project - ")) {
        projectFiles.push(file);
        continue;
      }
      const content = await this.app.vault.read(file);
      if (content.includes("#project")) {
        projectFiles.push(file);
      }
    }
    return projectFiles;
  }
  async setProjectForTask(task, projectPath) {
    try {
      if (!task.file || !(task.file instanceof import_obsidian7.TFile)) {
        new import_obsidian7.Notice("\u30BF\u30B9\u30AF\u30D5\u30A1\u30A4\u30EB\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093");
        return;
      }
      await this.app.fileManager.processFrontMatter(
        task.file,
        (frontmatter) => {
          if (projectPath) {
            const projectFile = this.app.vault.getAbstractFileByPath(projectPath);
            if (projectFile) {
              frontmatter.project = projectFile.basename;
              frontmatter.project_path = projectPath;
            }
          } else {
            delete frontmatter.project;
            delete frontmatter.project_path;
          }
          return frontmatter;
        }
      );
      if (projectPath) {
        const projectFile = this.app.vault.getAbstractFileByPath(projectPath);
        if (projectFile) {
          task.projectPath = projectPath;
          task.projectTitle = projectFile.basename;
        }
      } else {
        task.projectPath = null;
        task.projectTitle = null;
      }
      new import_obsidian7.Notice(`\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u8A2D\u5B9A\u3092\u4FDD\u5B58\u3057\u307E\u3057\u305F`);
    } catch (error) {
      console.error("Failed to set project:", error);
      new import_obsidian7.Notice("\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u8A2D\u5B9A\u306B\u5931\u6557\u3057\u307E\u3057\u305F");
    }
  }
  updateProjectDisplay(inst) {
    var _a;
    const taskItem = (_a = this.taskList) == null ? void 0 : _a.querySelector(
      `[data-task-path="${inst.task.path}"]`
    );
    if (taskItem) {
      const projectDisplay = taskItem.querySelector(
        ".taskchute-project-display"
      );
      if (projectDisplay) {
        projectDisplay.empty();
        if (inst.task.projectPath && inst.task.projectTitle) {
          const projectButton = projectDisplay.createEl("span", {
            cls: "taskchute-project-button",
            attr: {
              title: `\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8: ${inst.task.projectTitle}`
            }
          });
          const folderIcon = projectButton.createEl("span", {
            cls: "taskchute-project-icon",
            text: "\u{1F4C1}"
          });
          const projectName = projectButton.createEl("span", {
            cls: "taskchute-project-name",
            text: inst.task.projectTitle.replace(/^Project\s*-\s*/, "")
          });
          projectButton.addEventListener("click", async (e) => {
            e.stopPropagation();
            await this.showUnifiedProjectModal(inst);
          });
          const externalLinkIcon = projectDisplay.createEl("span", {
            cls: "taskchute-external-link",
            text: "\u{1F517}",
            attr: { title: "\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30CE\u30FC\u30C8\u3092\u958B\u304F" }
          });
          externalLinkIcon.addEventListener("click", async (e) => {
            e.stopPropagation();
            await this.openProjectInSplit(inst.task.projectPath);
          });
        } else {
          const projectPlaceholder = projectDisplay.createEl("span", {
            cls: "taskchute-project-placeholder",
            attr: { title: "\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u3092\u8A2D\u5B9A" }
          });
          projectPlaceholder.addEventListener("click", async (e) => {
            e.stopPropagation();
            await this.showProjectModal(inst);
          });
        }
      }
    }
  }
  async openProjectInSplit(projectPath) {
    try {
      const file = this.app.vault.getAbstractFileByPath(projectPath);
      if (file instanceof import_obsidian7.TFile) {
        const leaf = this.app.workspace.getLeaf("split");
        await leaf.openFile(file);
      } else {
        new import_obsidian7.Notice(`\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30D5\u30A1\u30A4\u30EB\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093: ${projectPath}`);
      }
    } catch (error) {
      console.error("Failed to open project:", error);
      new import_obsidian7.Notice("\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30D5\u30A1\u30A4\u30EB\u3092\u958B\u3051\u307E\u305B\u3093\u3067\u3057\u305F");
    }
  }
  async hasExecutionHistory(taskPath) {
    return false;
  }
  async handleFileRename(file, oldPath) {
  }
  moveInstanceToSlot(fromSlot, fromIdx, toSlot, toIdx) {
  }
  // State management methods for deletion/hiding
  getDeletedInstances(dateStr) {
    const key = `taskchute-deleted-instances-${dateStr}`;
    try {
      const data = localStorage.getItem(key);
      if (!data) return [];
      return JSON.parse(data);
    } catch (e) {
      return [];
    }
  }
  saveDeletedInstances(dateStr, instances) {
    const key = `taskchute-deleted-instances-${dateStr}`;
    try {
      localStorage.setItem(key, JSON.stringify(instances));
    } catch (e) {
      console.error("Failed to save deleted instances:", e);
    }
  }
  getHiddenRoutines(dateStr) {
    const key = `taskchute-hidden-routines-${dateStr}`;
    try {
      const data = localStorage.getItem(key);
      if (!data) return [];
      return JSON.parse(data);
    } catch (e) {
      return [];
    }
  }
  saveHiddenRoutines(dateStr, routines) {
    const key = `taskchute-hidden-routines-${dateStr}`;
    try {
      localStorage.setItem(key, JSON.stringify(routines));
    } catch (e) {
      console.error("Failed to save hidden routines:", e);
    }
  }
  isInstanceDeleted(instanceId, taskPath, dateStr) {
    const deletedInstances = this.getDeletedInstances(dateStr);
    return deletedInstances.some((del) => {
      if (instanceId && del.instanceId === instanceId) return true;
      if (del.deletionType === "permanent" && del.path === taskPath) return true;
      return false;
    });
  }
  isInstanceHidden(instanceId, taskPath, dateStr) {
    const hiddenRoutines = this.getHiddenRoutines(dateStr);
    return hiddenRoutines.some((hidden) => {
      if (hidden.instanceId && hidden.instanceId === instanceId) return true;
      if (hidden.instanceId === null && hidden.path && hidden.path === taskPath) return true;
      return false;
    });
  }
};

// src/main.ts
var VIEW_TYPE_TASKCHUTE = "taskchute-view";
var TaskChuteSettingTab = class extends import_obsidian8.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian8.Setting(containerEl).setName("\u30D1\u30B9\u8A2D\u5B9A").setHeading();
    new import_obsidian8.Setting(containerEl).setName("\u30BF\u30B9\u30AF\u30D5\u30A9\u30EB\u30C0\u30D1\u30B9").setDesc("\u30BF\u30B9\u30AF\u30D5\u30A1\u30A4\u30EB\u3092\u4FDD\u5B58\u3059\u308B\u30D5\u30A9\u30EB\u30C0\u306E\u30D1\u30B9").addText((text) => {
      text.setPlaceholder(PathManager.DEFAULT_PATHS.taskFolder).setValue(this.plugin.settings.taskFolderPath || "").onChange(async (value) => {
        const validation = this.plugin.pathManager.validatePath(value);
        if (validation.valid || value === "") {
          this.plugin.settings.taskFolderPath = value;
          await this.plugin.saveSettings();
        } else {
          new import_obsidian8.Notice(validation.error);
          text.setValue(this.plugin.settings.taskFolderPath || "");
        }
      });
      text.inputEl.addEventListener("blur", async () => {
        if (this.plugin.settings.taskFolderPath || !this.plugin.settings.taskFolderPath) {
          try {
            await this.plugin.pathManager.ensureFolderExists(
              this.plugin.pathManager.getTaskFolderPath()
            );
          } catch (error) {
          }
        }
      });
    });
    new import_obsidian8.Setting(containerEl).setName("\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30D5\u30A9\u30EB\u30C0\u30D1\u30B9").setDesc("\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30D5\u30A1\u30A4\u30EB\u3092\u4FDD\u5B58\u3059\u308B\u30D5\u30A9\u30EB\u30C0\u306E\u30D1\u30B9").addText((text) => {
      text.setPlaceholder(PathManager.DEFAULT_PATHS.projectFolder).setValue(this.plugin.settings.projectFolderPath || "").onChange(async (value) => {
        const validation = this.plugin.pathManager.validatePath(value);
        if (validation.valid || value === "") {
          this.plugin.settings.projectFolderPath = value;
          await this.plugin.saveSettings();
        } else {
          new import_obsidian8.Notice(validation.error);
          text.setValue(this.plugin.settings.projectFolderPath || "");
        }
      });
    });
    new import_obsidian8.Setting(containerEl).setName("\u30ED\u30B0\u30C7\u30FC\u30BF\u30D1\u30B9").setDesc("\u30ED\u30B0\u30C7\u30FC\u30BF\u3092\u4FDD\u5B58\u3059\u308B\u30D5\u30A9\u30EB\u30C0\u306E\u30D1\u30B9").addText((text) => {
      text.setPlaceholder(PathManager.DEFAULT_PATHS.logData).setValue(this.plugin.settings.logDataPath || "").onChange(async (value) => {
        const validation = this.plugin.pathManager.validatePath(value);
        if (validation.valid || value === "") {
          this.plugin.settings.logDataPath = value;
          await this.plugin.saveSettings();
        } else {
          new import_obsidian8.Notice(validation.error);
          text.setValue(this.plugin.settings.logDataPath || "");
        }
      });
    });
    new import_obsidian8.Setting(containerEl).setName("\u30EC\u30D3\u30E5\u30FC\u30C7\u30FC\u30BF\u30D1\u30B9").setDesc("\u30EC\u30D3\u30E5\u30FC\u30C7\u30FC\u30BF\u3092\u4FDD\u5B58\u3059\u308B\u30D5\u30A9\u30EB\u30C0\u306E\u30D1\u30B9").addText((text) => {
      text.setPlaceholder(PathManager.DEFAULT_PATHS.reviewData).setValue(this.plugin.settings.reviewDataPath || "").onChange(async (value) => {
        const validation = this.plugin.pathManager.validatePath(value);
        if (validation.valid || value === "") {
          this.plugin.settings.reviewDataPath = value;
          await this.plugin.saveSettings();
        } else {
          new import_obsidian8.Notice(validation.error);
          text.setValue(this.plugin.settings.reviewDataPath || "");
        }
      });
    });
    new import_obsidian8.Setting(containerEl).setName("\u8996\u899A\u52B9\u679C\u8A2D\u5B9A").setHeading();
    new import_obsidian8.Setting(containerEl).setName("\u52B9\u679C\u97F3\u3092\u6709\u52B9\u5316").setDesc("\u30BF\u30B9\u30AF\u5B8C\u4E86\u6642\u306B\u52B9\u679C\u97F3\u3092\u518D\u751F\u3059\u308B").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableSound).onChange(async (value) => {
        this.plugin.settings.enableSound = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian8.Setting(containerEl).setName("\u82B1\u706B\u30A8\u30D5\u30A7\u30AF\u30C8\u3092\u6709\u52B9\u5316").setDesc("\u30BF\u30B9\u30AF\u5B8C\u4E86\u6642\u306B\u82B1\u706B\u30A8\u30D5\u30A7\u30AF\u30C8\u3092\u8868\u793A\u3059\u308B").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableFireworks).onChange(async (value) => {
        this.plugin.settings.enableFireworks = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian8.Setting(containerEl).setName("\u7D19\u5439\u96EA\u30A8\u30D5\u30A7\u30AF\u30C8\u3092\u6709\u52B9\u5316").setDesc("\u30BF\u30B9\u30AF\u5B8C\u4E86\u6642\u306B\u7D19\u5439\u96EA\u30A8\u30D5\u30A7\u30AF\u30C8\u3092\u8868\u793A\u3059\u308B").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableConfetti).onChange(async (value) => {
        this.plugin.settings.enableConfetti = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
var TaskChutePlusPlugin = class extends import_obsidian8.Plugin {
  // Simple logger/notification wrapper
  _log(level, ...args) {
    var _a;
    try {
      (_a = console[level || "log"]) == null ? void 0 : _a.call(console, ...args);
    } catch (_) {
    }
  }
  _notify(message, timeout) {
    try {
      new import_obsidian8.Notice(message, timeout);
    } catch (_) {
      this._log("warn", "[Notice]", message);
    }
  }
  async onload() {
    const loaded = await this.loadData() || {};
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loaded);
    this.pathManager = new PathManager(this);
    this.routineAliasManager = new RoutineAliasManager(this);
    await this.routineAliasManager.loadAliases();
    await this.ensureRequiredFolders();
    try {
      this.addSettingTab(new TaskChuteSettingTab(this.app, this));
    } catch (error) {
      this._log("warn", "Settings tab not available:", error);
    }
    this.registerView(
      VIEW_TYPE_TASKCHUTE,
      (leaf) => new TaskChuteView(leaf, this)
    );
    this.addRibbonIcon("checkmark", "TaskChute\u3092\u958B\u304F", () => {
      this.activateTaskChuteView();
    });
    this.registerCommands();
  }
  async onunload() {
    if (this.globalTimerInterval) {
      clearInterval(this.globalTimerInterval);
      this.globalTimerInterval = null;
    }
    const view = this.getTaskChuteView();
    if (view && view.boundaryCheckTimeout) {
      clearTimeout(view.boundaryCheckTimeout);
      view.boundaryCheckTimeout = null;
    }
    this.app.workspace.getLeavesOfType(VIEW_TYPE_TASKCHUTE).forEach((leaf) => {
      if (leaf.view && leaf.view.onunload) {
        leaf.view.onunload();
      }
    });
    try {
      const today = /* @__PURE__ */ new Date();
      const cutoffDate = new Date(today);
      cutoffDate.setDate(today.getDate() - 30);
      const keysToCheck = Object.keys(localStorage);
      keysToCheck.forEach((key) => {
        const dateMatch = key.match(/taskchute-.*-(\d{4}-\d{2}-\d{2})/);
        if (dateMatch) {
          const keyDate = new Date(dateMatch[1]);
          if (keyDate < cutoffDate) {
            localStorage.removeItem(key);
          }
        }
      });
    } catch (error) {
    }
  }
  registerCommands() {
    this.addCommand({
      id: "open-taskchute-view",
      name: "TaskChute\u3092\u958B\u304F",
      callback: () => {
        this.activateTaskChuteView();
      }
    });
    this.addCommand({
      id: "taskchute-settings",
      name: "TaskChute\u8A2D\u5B9A",
      callback: () => {
        this.showSettingsModal();
      }
    });
    this.addCommand({
      id: "duplicate-selected-task",
      name: "\u9078\u629E\u3055\u308C\u305F\u30BF\u30B9\u30AF\u3092\u8907\u88FD",
      // ホットキーはデフォルトで設定しない
      callback: async () => {
        const view = this.getTaskChuteView();
        if (view && view.selectedTaskInstance) {
          await view.duplicateInstance(view.selectedTaskInstance);
          view.clearTaskSelection();
        } else {
          new import_obsidian8.Notice("\u30BF\u30B9\u30AF\u304C\u9078\u629E\u3055\u308C\u3066\u3044\u307E\u305B\u3093");
        }
      }
    });
    this.addCommand({
      id: "delete-selected-task",
      name: "\u9078\u629E\u3055\u308C\u305F\u30BF\u30B9\u30AF\u3092\u524A\u9664",
      // ホットキーはデフォルトで設定しない
      callback: () => {
        const view = this.getTaskChuteView();
        if (view && view.selectedTaskInstance) {
          view.deleteSelectedTask();
        } else {
          new import_obsidian8.Notice("\u30BF\u30B9\u30AF\u304C\u9078\u629E\u3055\u308C\u3066\u3044\u307E\u305B\u3093");
        }
      }
    });
    this.addCommand({
      id: "reset-selected-task",
      name: "\u9078\u629E\u3055\u308C\u305F\u30BF\u30B9\u30AF\u3092\u672A\u5B9F\u884C\u306B\u623B\u3059",
      callback: () => {
        const view = this.getTaskChuteView();
        if (view && view.selectedTaskInstance) {
          if (view.selectedTaskInstance.state !== "idle") {
            view.resetTaskToIdle(view.selectedTaskInstance);
          } else {
            new import_obsidian8.Notice("\u65E2\u306B\u672A\u5B9F\u884C\u72B6\u614B\u3067\u3059");
          }
        } else {
          new import_obsidian8.Notice("\u30BF\u30B9\u30AF\u304C\u9078\u629E\u3055\u308C\u3066\u3044\u307E\u305B\u3093");
        }
      }
    });
    this.addCommand({
      id: "show-today-tasks",
      name: "\u4ECA\u65E5\u306E\u30BF\u30B9\u30AF\u3092\u8868\u793A",
      description: "Show today's tasks",
      hotkeys: [
        {
          modifiers: ["Alt"],
          key: "t"
        }
      ],
      callback: () => {
        const view = this.getTaskChuteView();
        if (view) {
          view.showTodayTasks();
        } else {
          new import_obsidian8.Notice("TaskChute\u30D3\u30E5\u30FC\u304C\u958B\u304B\u308C\u3066\u3044\u307E\u305B\u3093");
        }
      }
    });
    this.addCommand({
      id: "reorganize-idle-tasks",
      name: "\u672A\u5B9F\u884C\u30BF\u30B9\u30AF\u3092\u73FE\u5728\u306E\u6642\u9593\u5E2F\u306B\u6574\u7406",
      callback: () => {
        const view = this.getTaskChuteView();
        if (view) {
          view.reorganizeIdleTasks();
        } else {
          new import_obsidian8.Notice("TaskChute\u30D3\u30E5\u30FC\u304C\u958B\u304B\u308C\u3066\u3044\u307E\u305B\u3093");
        }
      }
    });
  }
  async ensureRequiredFolders() {
    const targets = [
      ["\u30BF\u30B9\u30AF\u30D5\u30A9\u30EB\u30C0", () => this.pathManager.getTaskFolderPath()],
      ["\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30D5\u30A9\u30EB\u30C0", () => this.pathManager.getProjectFolderPath()],
      ["\u30ED\u30B0\u30C7\u30FC\u30BF\u30D5\u30A9\u30EB\u30C0", () => this.pathManager.getLogDataPath()],
      ["\u30EC\u30D3\u30E5\u30FC\u30C7\u30FC\u30BF\u30D5\u30A9\u30EB\u30C0", () => this.pathManager.getReviewDataPath()]
    ];
    for (const [label, getter] of targets) {
      try {
        const path = getter();
        await this.pathManager.ensureFolderExists(path);
      } catch (error) {
        try {
          new import_obsidian8.Notice(`${label}\u306E\u4F5C\u6210\u306B\u5931\u6557\u3057\u307E\u3057\u305F`);
        } catch (_) {
        }
      }
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  getTaskChuteView() {
    const leaf = this.app.workspace.getLeavesOfType(VIEW_TYPE_TASKCHUTE)[0];
    if (leaf && leaf.view instanceof TaskChuteView) {
      return leaf.view;
    }
    return null;
  }
  async activateTaskChuteView() {
    const { workspace } = this.app;
    const leaf = workspace.getLeaf(true);
    await leaf.setViewState({
      type: VIEW_TYPE_TASKCHUTE,
      active: true
    });
  }
  showSettingsModal() {
    const modal = document.createElement("div");
    modal.className = "task-modal-overlay";
    const modalContent = modal.createEl("div", { cls: "task-modal-content" });
    const modalHeader = modalContent.createEl("div", { cls: "modal-header" });
    modalHeader.createEl("h3", { text: "TaskChute\u8A2D\u5B9A" });
    const closeButton = modalHeader.createEl("button", {
      cls: "modal-close-button",
      text: "\xD7",
      attr: { title: "\u9589\u3058\u308B" }
    });
    const form = modalContent.createEl("form", { cls: "task-form" });
    const pathSection = form.createEl("div", { cls: "settings-section" });
    pathSection.createEl("h4", { text: "\u30D1\u30B9\u8A2D\u5B9A" });
    this.createPathSetting(
      pathSection,
      "\u30BF\u30B9\u30AF\u30D5\u30A9\u30EB\u30C0\u30D1\u30B9",
      "taskFolderPath",
      PathManager.DEFAULT_PATHS.taskFolder
    );
    this.createPathSetting(
      pathSection,
      "\u30D7\u30ED\u30B8\u30A7\u30AF\u30C8\u30D5\u30A9\u30EB\u30C0\u30D1\u30B9",
      "projectFolderPath",
      PathManager.DEFAULT_PATHS.projectFolder
    );
    this.createPathSetting(
      pathSection,
      "\u30ED\u30B0\u30C7\u30FC\u30BF\u30D1\u30B9",
      "logDataPath",
      PathManager.DEFAULT_PATHS.logData
    );
    this.createPathSetting(
      pathSection,
      "\u30EC\u30D3\u30E5\u30FC\u30C7\u30FC\u30BF\u30D1\u30B9",
      "reviewDataPath",
      PathManager.DEFAULT_PATHS.reviewData
    );
    const effectsSection = form.createEl("div", { cls: "settings-section" });
    effectsSection.createEl("h4", { text: "\u8996\u899A\u52B9\u679C\u8A2D\u5B9A" });
    this.createToggleSetting(effectsSection, "\u52B9\u679C\u97F3\u3092\u6709\u52B9\u5316", "enableSound");
    this.createToggleSetting(effectsSection, "\u82B1\u706B\u30A8\u30D5\u30A7\u30AF\u30C8\u3092\u6709\u52B9\u5316", "enableFireworks");
    this.createToggleSetting(effectsSection, "\u7D19\u5439\u96EA\u30A8\u30D5\u30A7\u30AF\u30C8\u3092\u6709\u52B9\u5316", "enableConfetti");
    closeButton.addEventListener("click", () => {
      document.body.removeChild(modal);
    });
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        document.body.removeChild(modal);
      }
    });
    document.body.appendChild(modal);
  }
  createPathSetting(container, label, settingKey, placeholder) {
    const group = container.createEl("div", { cls: "form-group" });
    group.createEl("label", { text: label + ":", cls: "form-label" });
    const input = group.createEl("input", {
      type: "text",
      cls: "form-input",
      attr: { placeholder }
    });
    input.value = this.settings[settingKey] || "";
    input.addEventListener("change", async () => {
      const value = input.value.trim();
      const validation = this.pathManager.validatePath(value);
      if (validation.valid || value === "") {
        this.settings[settingKey] = value;
        await this.saveSettings();
        try {
          if (settingKey === "taskFolderPath") {
            await this.pathManager.ensureFolderExists(this.pathManager.getTaskFolderPath());
          } else if (settingKey === "projectFolderPath") {
            await this.pathManager.ensureFolderExists(this.pathManager.getProjectFolderPath());
          } else if (settingKey === "logDataPath") {
            await this.pathManager.ensureFolderExists(this.pathManager.getLogDataPath());
          } else if (settingKey === "reviewDataPath") {
            await this.pathManager.ensureFolderExists(this.pathManager.getReviewDataPath());
          }
        } catch (error) {
        }
      } else {
        new import_obsidian8.Notice(validation.error);
        input.value = this.settings[settingKey] || "";
      }
    });
  }
  createToggleSetting(container, label, settingKey) {
    const group = container.createEl("div", { cls: "form-group checkbox-group" });
    const checkbox = group.createEl("input", {
      type: "checkbox",
      cls: "form-checkbox"
    });
    group.createEl("label", { text: label, cls: "form-label" });
    checkbox.checked = this.settings[settingKey];
    checkbox.addEventListener("change", async () => {
      this.settings[settingKey] = checkbox.checked;
      await this.saveSettings();
    });
  }
};
